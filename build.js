require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/youzi/dev/mtv-play/api/email.js":[function(require,module,exports){
var Value = require('old-vigour-js/value')
var config = require('old-vigour-js/util/config')
var cases = require('old-vigour-js/browser/cases')
var location = window.location

module.exports = exports = new Value({
  send: {
    apiDefer: function (update, args) {
      if (this.body || this.address || this.subject) {
        var body = this.body && this.body.val
        var subject = this.subject && this.subject.val
        var address = this.address && this.address.val
        var _this = this

        if (cases.android && !!window.cordova && window.plugins.socialsharing) {
          window.plugins.socialsharing
            .shareViaEmail(body, // can contain HTML tags, but support on Android is rather limited:  http://stackoverflow.com/questions/15136480/how-to-send-html-content-with-image-through-android-default-email-client
              subject, address ? [address] : [], // TO: must be null or an array
              null, // CC: must be null or an array
              null, // BCC: must be null or an array
              null, // FILES: can be null, a string, or an array
              function (response) {
                update('success')
                this.$empty('loading')
              }, // called when sharing worked, but also when the user cancelled sharing via email (I've found no way to detect the difference)
              function (err) {
                _this.type = err
                update('error')
                this.$empty('loading')
              }
          )
        } else {
          var redirect = 'mailto:' + (address || '') + '?subject=' + (subject || '') + '&body=' + (body || '')

          if (cases.android) {
            location.replace(redirect)
          } else {
            var old = location.href
            location.href = redirect
          }
          update('success')
          this.$empty('loading')
        }

      } else {
        update(true)
      }

    }
  },
  share: {
    apiDefer: function (update, args) {
      var email = this._parent
      if (this.val === true || args[0] === true) {
        email.send.once(function (val) {
          update(val)
        })
        email.send.val = {
          address: this.address.val,
          body: this.body.val,
          subject: this.subject.val,
          val: true
        }
      } else {
        update(true)
      }
    }
  }
})

},{"old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/facebook/index.js":[function(require,module,exports){
var Value = require('old-vigour-js/value')
var config = require('old-vigour-js/util/config')
var defer = require('old-vigour-js/value/flags/process')
var facebookApi

// TODO: script defer type / css defer type / file api
// TODO: localflags e.g. facebook api
// api flag
module.exports = exports = new Value({
  api: {
    defer: function (update, args) {
      if (args[0] !== true || facebookApi) {
        return true
      }

      if (!!window.cordova && !facebookApi) {
        facebookApi = true
        update()
      } else {
        if (args[0] !== true || facebookApi) return true

        var script = document.createElement('script')
        var _this = this
        var error = script.onerror = function () {
          _this.clearCache()
          _this.val = args[0] = 'error'
          update()
        }

        script.src = config.facebook.web
        script.id = 'facebook-jssdk'

        window.fbAsyncInit = function () {
          try {
            window.FB.init({
              appId: config.facebook.id,
              xfbml: true,
              version: 'v2.1'
            })
            facebookApi = true // select it!
            update()
          } catch (e) {
            _this.type = e.message
            error()
          }
        }
        document.getElementsByTagName('head')[0].appendChild(script)
      }
    }
  }
})

// TODO: this is a tempfix
exports._name = 'facebook'

// TODO: coding style for nested modules purely for smaller filesizes
require('./login')
require('./share')

},{"./login":"/Users/youzi/dev/mtv-play/api/facebook/login.js","./share":"/Users/youzi/dev/mtv-play/api/facebook/share.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","old-vigour-js/value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/api/facebook/login.js":[function(require,module,exports){
var Value = require( 'old-vigour-js/value' )
var config = require( 'old-vigour-js/util/config' )
var util = require( 'old-vigour-js/util' )
var facebook = require( './index.js' )
var ua = require( 'old-vigour-js/browser/ua' )
var url = require( 'old-vigour-js/browser/network/url' )
var app = require( 'old-vigour-js/app/' )

//TODO: script defer type / css defer type / file api
//TODO: localflags e.g. facebook api

/*
  app.api.facebook.login = true (requests facebook login window)
*/

facebook.val = {
  login: {
    apiDefer: function facebookLogin( update, args ) {

      var _this = this
        //api update
      if( args[ 0 ] !== true ) {
        update( 'error' )
        this.type = 'type'
      } else {
        //TODO: replace this later
        if( !!window.cordova && !( ua.platform === "windows" && ua.device === "phone" ) ) {

          facebookConnectPlugin.login(
            [ 'public_profile', 'email' ],
            function cordovaFBSuccess( res ) {

              if( res.status === 'connected' ) {

                if( !_this.token || _this.token.val !== res.authResponse.accessToken ) { //block for double callback
                  _this.set( 'token', res.authResponse.accessToken )
                  _this.set( 'id', res.authResponse.userID )
                    //userID: "1607598096139074"
                  update( 'success' )
                } else {
                  update( 'error' )
                }

              } else {
                _this.type = res
                update( 'error' )
              }
            },
            function cordovaFBFail( status ) {
              _this.type = status
              update( 'error' )
            }
          )
        } else {
          window.FB.login( function( res ) {
            if( res.status === 'connected' ) {
              _this.set( 'token', res.authResponse.accessToken )
              _this.set( 'id', res.authResponse.userID )
              update( 'success' )
            } else {
              _this.type = res
                // console.warn( 'fb error', res)
              update( 'error' )
            }
          }, {
            scope: 'public_profile,email'
          } )
        }
      }
    }
  }
}
},{"./index.js":"/Users/youzi/dev/mtv-play/api/facebook/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/network/url":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/url.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/facebook/share.js":[function(require,module,exports){
var Value = require( 'old-vigour-js/value' )
var config = require( 'old-vigour-js/util/config' )
var util = require( 'old-vigour-js/util' )
var facebook = require( './index.js' )
var cases = require( 'old-vigour-js/browser/cases' )
var url = require( 'old-vigour-js/browser/network/url' )
var ua = require( 'old-vigour-js/browser/ua' )
var app = require( 'old-vigour-js/app/' )
var cordovaFallback

facebook.val = {
  share: {
    apiDefer: function( update, args ) {

      var _this = this,
        url = this.url && this.url.val //shareUrl(this.parent.data)

      if( !url ) {
        update( true )
      } else if( !!window.cordova ) {
        if( ua.platform === "windows" && ua.device === "phone" ) {
          window.plugins.socialsharing.share(
            null, this.title && this.title.val, null, this.url && this.url.val /* url */ ,
            function( msg ) {
              update( 'success' )
            },
            function( err ) {
              if( err ) {
                if( cordovaFallback ) {
                  cordovaFallback.call( _this, update, args )
                } else {
                  _this.type = 'no cordovaFallback'
                  update( 'error' )
                }
              }
            } )
        } else {

          window.plugins.socialsharing
            .shareViaFacebook( null, null //this.img ? this.img.val : null
              , this.url ? this.url.val : null /* url */ ,
              function( msg ) {
                update( 'success' )
              },
              function( err ) {
                if( err ) {
                  if( cordovaFallback ) {
                    cordovaFallback.call( _this, update, args )
                  } else {
                    _this.type = 'no cordovaFallback'
                    update( 'error' )
                  }
                }
              }
            )
        }
      } else {
        console.log( "FB.ui" )
          //TODO: add img and title support!
        FB.ui( {
          method: 'share',
          href: url
        }, function( res ) {
          if( !res || res && res.error_code ) {
            if( res && res.error_code == 4201 ) _this.type = 'cancelled'
            update( 'error' )
          } else {
            update( 'success' )
          }
        } )
      }
    }
  }
}

if( !!window.cordova ) {
  //TODO: cordovaFallback will be replaced later!
  ;( function() {
    cordovaFallback = function shareThroughFBFallback( update, args ) {

      var url = this.url && this.url.val,
        _this = this

      function share() {
        window.facebookConnectPlugin
          .showDialog( {
            method: 'share',
            href: url,
            link: url
          }, function( val ) {
            if( ( typeof val !== 'string' ) ) {
              update( 'success' )
            } else if( ~val.indexOf( 'User cancelled' ) ) {
              _this.type = 'cancelled'
              update( 'error' )
            }
          }, function( err ) {
            if( typeof err === 'string' && err.indexOf( 'User cancelled' ) ) {
              _this.type = 'cancelled'
            }
            update( 'error' )
          } )
      }

      function login() {
        window.facebookConnectPlugin
          .login( [ 'public_profile' ], share, function( error ) {
            _this.type = 'login'
            update( 'error' )
          } )
      }

      if( cases.android ) {
        window.facebookConnectPlugin
          .getLoginStatus( function( msg ) {;
              ( msg.status === 'connected' ? share() : login() )
            },
            login
          )
      } else {
        share()
      }

    }
  } )()
}

},{"./index.js":"/Users/youzi/dev/mtv-play/api/facebook/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/network/url":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/url.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/index.js":[function(require,module,exports){
exports.login = require('./login')
exports.verify = require('./verify')
exports.register = require('./register')
exports.facebook = require('./facebook')
exports.email = require('./email')
exports.network = require('./network')
exports.password = require('./password')
exports.mobile = require('./mobile')
exports.user = require('./user')
exports.purchase = require('./purchase')
exports.receipt = require('./receipt')
exports.url = require('./url')
exports.player = require('./player')
exports.price = require('./purchase/pricing')
exports.operator = require('./operator')
exports.info = require('./info')

},{"./email":"/Users/youzi/dev/mtv-play/api/email.js","./facebook":"/Users/youzi/dev/mtv-play/api/facebook/index.js","./info":"/Users/youzi/dev/mtv-play/api/info.js","./login":"/Users/youzi/dev/mtv-play/api/login.js","./mobile":"/Users/youzi/dev/mtv-play/api/mobile.js","./network":"/Users/youzi/dev/mtv-play/api/network.js","./operator":"/Users/youzi/dev/mtv-play/api/operator.js","./password":"/Users/youzi/dev/mtv-play/api/password.js","./player":"/Users/youzi/dev/mtv-play/api/player.js","./purchase":"/Users/youzi/dev/mtv-play/api/purchase/index.js","./purchase/pricing":"/Users/youzi/dev/mtv-play/api/purchase/pricing.js","./receipt":"/Users/youzi/dev/mtv-play/api/receipt.js","./register":"/Users/youzi/dev/mtv-play/api/register.js","./url":"/Users/youzi/dev/mtv-play/api/url.js","./user":"/Users/youzi/dev/mtv-play/api/user.js","./verify":"/Users/youzi/dev/mtv-play/api/verify.js"}],"/Users/youzi/dev/mtv-play/api/info.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value')
var url = config.api.url

window.TEST = module.exports = exports = new Value({
  episode_pass_available: 0,
  ajax: {
    url: function () {
      // todo make this an internal part of ajax defer --- add to the defer tempars and compare there
      // TODO: add from - self
      var val = this._val instanceof Value ? this._val : this
      if (typeof val.val === 'string') {
        var str = url + 'api/v1/utt_info/c153f28d950ae49a/' + val.val + '.json'
        this._cached = val.val
        return str
      }
    },
    defer: function (update, args, err, data) {
      if (data.country_info) {
        for (var i in data.country_info) {
          if (this[i]) {
            this[i].val = data.country_info[i]
          }
        }
      }
      update()
    }
  }
})

},{"old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/login.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value')
var util = require('./util')
var url = config.api.url
var defer = require('old-vigour-js/value/flags/process')

module.exports = exports = new Value({
  ajax: {
    condition: function (ajax, val) {
      // TODO: clearing perhaps? or handle from login/logout
      if (this.email && this.password) {
        ajax.url = url + 'api/v2/sessions.json'
        ajax.data = {
          user: {
            email: this.email.val,
            password: this.password.val,
            app_version: window.package.version
          }
        }
        return true
      } else if (this.region && this.facebook && this.facebook.token) {
        ajax.url = url + 'api/v2/sessions.json'
        ajax.data = {
          auth_method: 1,
          user: {
            oauth_token: this.facebook.token.val,
            accept_data_protection_tcs: true,
            accept_mtv_country_tcs_for: this.region.val,
            app_version: window.package.version
          }
        }
        return true
      }
    },
    headers: {
      appVersion: 3
    },
    method: 'POST',
    encode: 'json',
    defer: function (update, args, err, data) {
      if (err || !data || !data.success) {
        this.type = err ? err.message : util.findError(data)
        update('error')
        this.$empty(['loading', 'region'])
      } else {
        this.set('token', data.authentication_token)
        if (data.new_record) {
          this.set('new_record', data.new_record)
        } else if (this.new_record) {
          this.new_record.remove()
        }
        update('success')
      }
    }
  }
})

// TODO: get rid of this temp fix
exports._name = '_mtvlogin'

},{"./util":"/Users/youzi/dev/mtv-play/api/util.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","old-vigour-js/value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/api/mobile.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value')
var util = require('./util')
var url = config.api.url

/*
mobile.verify.val = 
{ phone:'jim@vigour.io'
, country:'schaap99'
}
*/

module.exports = exports = new Value({
  verify: // this validates that the number is ok and sends sms
  {
    ajax: {
      url: url + 'api/v2/mbl_verifications.json',
      encode: 'json',
      method: 'POST',
      headers: {
        Accept: '*/*',
        redirectUrl: config.packer.domain + '/?m=$data'
      }, // TODO: double check, maybe just use .json ?
      data: function (ajax, val) {
        if (this.token && this.token.val && this.phonenumber && this.phonenumber.val && this.country && this.country.val) {
          return {
            auth_token: this.token.val,
            user: {
              mobile_number: Number(this.phonenumber.val),
              mobile_country_prefix: Number(this.country.val),
              app_version: window.package.version
            }
          }
        }
      },
      defer: function (update, args, err, data) {
        if (err || !data || !data.valid) {
          this.type = err ? err.message : util.findError(data)
          update('error')
          // this way you make sure you can retry on error
          this.$empty(['loading', 'token'])
        } else {
          update('success')
        }
      }
    }
  },
  sms: {
    ajax: // this verifies sms token
    {
      url: function (ajax, val) {
        return typeof val === 'string' && url + 'api/v2/mblconfirmation/' + val + '.json'
      },
      method: 'GET',
      defer: function (update, args, err, data) {
        if (!data.success) {
          this.type = err ? err.message : util.findError(data)
          update('error')
        } else {
          // TODO: get token, no token very bad!
          this.set('token', data.authentication_token)
          update('success')
        }
      }
    }
  },
  available: {
    ajax: {
      url: function () {
        // todo make this an internal part of ajax defer --- add to the defer tempars and compare there
        // TODO: add from - self
        var val = this._val instanceof Value ? this._val : this
        if (typeof val.val === 'string') {
          var str = url + 'api/v1/utt_info/c153f28d950ae49a/' + val.val // +.json
          this._cached = val.val
          return str
        }
      },
      defer: function (update, args, err, data) {
        var val = this._val instanceof Value ? this._val : this
        if (val.val !== this._cached) {
          update(true)
          this._update()
        } else {
          if (!data || !data.success) {
            update(true)
          } else {
            this.set('transform', (data && data.country_info && data.country_info.mbl_available && true) || false)
            update()
          }
        }
      }
    }
  }
})

},{"./util":"/Users/youzi/dev/mtv-play/api/util.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/network.js":[function(require,module,exports){
var Value = require('old-vigour-js/value')

module.exports = exports = new Value()

if (!!window.cordova) {
  document.addEventListener('offline', function () {
    exports.val = false
  }, false)

  document.addEventListener('online', function () {
    exports.val = navigator.connection.type
  }, false)
}

},{"old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/operator.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value')
var app = require('old-vigour-js/app')
var util = require('./util')
var url = config.api.url

exports.login = new Value({
  ajax: {
    condition: function (ajax, val) {
      // TODO: clearing perhaps? or handle from login/logout
      if (this.username && this.password && this.operator) {
        ajax.url = url + 'api/v2/sessions.json'
        ajax.data = {
          auth_method: 3,
          operator_name: this.operator.val,
          operator_credentials: {
            username: this.username.val,
            password: this.password.val
          },
          user: {
            accept_mtv_country_tcs: ['de'],
            language_code: 'de'
          }
        }
        return true
      }
    },
    headers: {
      appVersion: 3
    },
    method: 'POST',
    encode: 'json',
    defer: function (update, args, err, data) {
      if (err || !data || !data.success) {
        this.type = err ? err.message : util.findError(data)
        update('error')
        this.$empty(['loading', 'region'])
      } else {
        this.set('token', data.authentication_token)
        if (data.new_record) {
          this.set('new_record', data.new_record)
        } else if (this.new_record) {
          this.new_record.remove()
        }
        update('success')
      }
    }
  }
})

exports.upgrade = new Value({
  ajax: {
    condition: function (ajax, val) {
      // TODO: clearing perhaps? or handle from login/logout
      if (this.username && this.password && this.operator) {
        ajax.url = url + 'api/v2/operators/upgrade.json'
        ajax.data = {
          auth_token: app.user.token.val,
          operator_name: this.operator.val,
          operator_credentials: {
            username: this.username.val,
            password: this.password.val
          }
        }
        return true
      }
    },
    headers: {
      appVersion: 3
    },
    method: 'POST',
    encode: 'json',
    defer: function (update, args, err, data) {
      if (err || !data || !data.success) {
        this.type = 'operatorUpgradeError'//text.operator.credentials.wrong'//err ? err.message : util.findError(data)
        update('error')
        this.$empty('loading')
      } else {
        update('success')
      }
    }
  }
})

},{"./util":"/Users/youzi/dev/mtv-play/api/util.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/password.js":[function(require,module,exports){
var config = require( 'old-vigour-js/util/config' )
var Value = require( 'old-vigour-js/value' )
var util = require( './util' )
var cases = require( 'old-vigour-js/browser/cases' )
var url = config.api.url

module.exports = exports = new Value( {
  reset: {
    ajax: {
      url: function( ajax, val ) {
        val = typeof val === 'string' ? val : this.token && this.token.val
        return typeof val === 'string' && url + 'api/v1/password_resets/' + val + '.json'
      },
      data: function( ajax, val ) {
        return this.password && this.password.val && {
          user: {
            password: this.password.val,
            password_confirmation: this.password.val,
            app_version: window.package.version
          }
        }
      },
      encode: 'json',
      method: 'PUT',
      defer: function( update, args, err, data ) {
        if( !data.success ) {
          this.type = err ? err.message : util.findError( data )
          update( 'error' )
        } else {
          this.set( 'token', data.authentication_token )
          update( 'success' )
        }
      }
    }
  },
  forgot: {
    ajax: {
      url: url + 'api/v1/password_resets.json',
      method: 'POST',
      encode: 'uri',
      headers: {
        appVersion: 3,
        redirectUrl: config.packer.domain + "/?reset=$data"
      },
      data: function( ajax, val ) {
        if( typeof val === 'string' ) {
          //verify check
          return {
            email: val
          }
        }
      },
      defer: function( update, args, err, data ) {
        if( !data.success ) {
          this.type = err ? err.message : util.findError( data )
          update( 'error' )
        } else {
          //TODO: get token, no token very bad!
          update( 'success' )
        }
      }
    }
  }
} )

//control.resetToken 
exports._name = 'password'

},{"./util":"/Users/youzi/dev/mtv-play/api/util.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/player.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value')
var playerApi

module.exports = exports = new Value({
  api: {
    defer: function (update, args) {
      if (args[0] !== true || playerApi) return true

      playerApi = true

      // window.$ = require('jquery').$
      // window.jQuery = window.$
      window.jQuery = window.$ = require('jquery')

      var _this = this
      var script = document.createElement('script')
      script.onerror = function (err) {
        console.error(err)
        _this.type = 'script'
        _this.clearCache()
        _this.val = args[0] = 'error'
        update()
      }

      script.onload = function () {
        update('success')
      }
      script.src = config.player.web
      script.id = 'player-script'

      this._parent.debug = config.player.debug
      this._parent.settings = config.player.settings

      document.getElementsByTagName('head')[0].appendChild(script)
    }
  },
  apiDefer: function (update, args) {
    update('success')
  }
})

},{"jquery":"/Users/youzi/dev/mtv-play/node_modules/jquery/dist/jquery.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/purchase/index.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value')
var util = require('../util')
var url = config.api.url
var cases = require('old-vigour-js/browser/cases')

var config = require('old-vigour-js/util/config')
var ua = require('old-vigour-js/browser/ua')
var platform = ua.platform
if (platform === 'android' && window.AmazonIapV2) {
  platform = 'amazon'
}
var store = config.store[platform]

module.exports = exports = new Value({
  apiDefer: function (update) {
    var _this = this

    if (!window.Store) { // no vigour cordova plugin

      if (window.AmazonIapV2) { // amazon cordova plugin
        console.log('[pay] purchase/index.js apiDefer fun times!')

        var product = (this.subscription && this.subscription.val) // monthly_de
          || (this.product && this.product.val) // single_nl

        if (!product) {
          update(true)
          if (this.subscription) this.subscription.val = false
          if (this.product) this.product.val = false
        } else {
          console.log('[pay] wow go and buy it?!', product)
          // Obtain object used to interact with plugin


          // Create a variable to store the saved requestId
          var theSavedRequestId = "";

          // Construct object passed to method as input

          var requestOptions = {
              "sku": product
          };
          var iapPlugin = window.AmazonIapV2;
          // Add a listener for the purchaseResponse event
          iapPlugin.addListener("purchaseResponse", function(event) {
              console.log('[pay] purchaseResponse!!!!!!!!!!!!', event)
              var response = event.response
              if (response && response.requestId === theSavedRequestId) {
                if (response.status === 'SUCCESSFUL') {
                  console.log('[pay] success! go continues')
                  window.purchaseValue = _this
                  console.log('[pay] setting info on window.purchaseValue', _this)
                  _this.set('amazonUserData', response.amazonUserData)
                  _this.set('purchaseReceipt', response.purchaseReceipt)
                  _this.set('token', response.purchaseReceipt.receiptId)
                  update('success')
                } else {
                  console.log('[pay] ERRORERROR')
                  update('error')
                }
              }
              if (event.requestId == theSavedRequestId) {
                // do something
                console.log('\n\n\n[pay] I bought something yeee!!!!', event)
              }
          });

          // Call method with input
          iapPlugin.purchase(
              function (operationResponse) {
                  // Save returned requestId
                  console.log('[pay] amazon callback style', operationResponse)
                  theSavedRequestId = operationResponse.requestId;

              }, function (errorResponse) {
                  // Handle error response
                  console.error('[pay] error buying!', errorResponse)
              },
              [requestOptions]
          );
        }

      } else { // no sture
        this.type = 'no store available'

        if (this.subscription) this.subscription.val = false
        if (this.product) this.product.val = false
      }


    } else {
      var product = (this.subscription && this.subscription.val) // monthly_de
        || (this.product && this.product.val) // single_nl

      if (!product) {
        update(true)
        if (this.subscription) this.subscription.val = false
        if (this.product) this.product.val = false
      } else if (cases.ios) {
        Store.buy(product, function (err, response) {
          if (response) err = null
          if (!err) {
            try {
              localStorage.setItem('receiptData', JSON.stringify(response))
            } catch (e) {
              _this.type = e
              update('error')
            }

            _this.set('token', window.atob(response.restoreTransaction ? response.restoreTransaction.transactionReceipt : response.completeTransaction.transactionReceipt))

            update('success')
          } else {
            _this.type = err.description
            // _this.blurf = true
            update('error')
          }
          if (_this.subscription) _this.subscription.val = false
          if (_this.product) _this.product.val = false
        })
      } else if (cases.windowsMobile) {
        Store.buy(product, function (err, response) {
          if (response) err = null
          if (!err) {
            try {
              localStorage.setItem('receiptData', JSON.stringify(response))
            } catch (e) {
              // console.error(e)
              _this.type = e
              update('error')
            }
            if (response.purchaseResults && response.purchaseResults.status === 'Succeeded') {
              _this.set('token', response.purchaseResults.receiptXml)

              _this.set('transactionId', response.purchaseResults.transactionId)

              update('success')
            } else {
              _this.type = response.purchaseResults
              update('error')
            }
          } else {
            _this.type = err
            update('error')
          }
          if (_this.subscription) _this.subscription.val = false
          if (_this.product) _this.product.val = false
        })
      } else {
        function callback (err, response) {
          if (response) err = null
          if (!err) {
            try {
              console.log('response ' + JSON.stringify(response, false, 2))
              localStorage.setItem('receiptData', JSON.stringify(response))
            } catch (e) {
              _this.type = e
            }

            _this.set('packageName', response.packageName)
            _this.set('subscriptionId', response.productId)
            _this.set('orderId', response.orderId)
            _this.set('purchaseTime', response.purchaseTime)
            _this.set('purchaseState', response.purchaseState)
            _this.set('developerPayload', response.developerPayload)
            _this.set('signature', response.signature)
            _this.set('token', response.purchaseToken)

            update('success')

          } else {
            _this.type = err

            update('error')
          }
          if (_this.subscription) _this.subscription.val = false
          if (_this.product) _this.product.val = false
        }

        if (this.subscription && this.subscription.val) {
          Store.subscribe(product, callback)
        } else {
          Store.buy(product, callback)
        }
      }
    }
  }
})

exports._name = 'purchase'

},{"../util":"/Users/youzi/dev/mtv-play/api/util.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/purchase/pricing.js":[function(require,module,exports){
var cases = require('old-vigour-js/browser/cases')
var app = require('old-vigour-js/app')
var config = require('old-vigour-js/util/config')
var ua = require('old-vigour-js/browser/ua')
var Value = require('old-vigour-js/value')

var platform = ua.platform
if (platform === 'android' && window.AmazonIapV2) {
  platform = 'amazon'
}
var store = config.store[platform]
var typeMap = {}
var currencyMap = {
      EUR:'€'
    , PLN:'zł'
    , RON:'Lei'
    }

function iosParseCurrency(val) {
  var currency = val.split('=')[1]
  return currencyMap[currency] || currency
}

function prepare( types ){
  for (var i = types.length - 1; i >= 0; i--) {
    var productId = store && store[ types[i] ]
    if( productId ){
      typeMap[types[i]] = types[i] = productId.replace( '$region', ( app.region.val || '' ).toLowerCase())
    } else {
      types.splice(i,1)
    }
  }
}

function findType( productIdentifier ){
  for( var type in typeMap ){
    if( typeMap[type] === productIdentifier ) return type
  }
}

module.exports = exports = function( types ) {
  console.log('[pay] pricing!')
  if( !types ) types = [ 'single', 'yearly', 'monthly' ]
  else if( !( types instanceof Array ) ) types = [ types ]

  prepare( types )

  if (types.length &&
    ((window.cordova && window.Store) || window.AmazonIapV2)
    ) {
    if (!exports._fetching) {
      exports._fetching = true
      console.log('[pay] ====> Store.fetch', types )
      if (window.Store) { // vigour cordova
        Store.fetch(types, gotProducts)
      } else { // amazon cordova
        console.log('[pay] get dat amazon products!', !!window.AmazonIapV2)
        // Obtain object used to interact with plugin
        var iapPlugin = window.AmazonIapV2;

        var theSavedRequestId

        // Define event handler
        var eventHandler = function(event) {
            console.log('[pay] got respuns!!', event)
            var products = event.response && event.response.productDataMap

            if (products) {
              var validProducts = [products]
              // for (var p in products) {
              //   validProducts.push(products[p])
              // }
              gotProducts(null, { validProducts: validProducts })
            }

            iapPlugin.removeListener("getProductDataResponse", eventHandler)
            //
            // var response = event.response
            // var requestId = response.requestId; // string
            // var products = response.productDataMap; // object containing key-value pairs where the key
            //                                            // is a SKU and the value is a ProductData object
            //
            // if (theSavedRequestId === requestId) {
            //   console.log('[pay] yes same')
            // } else {
            //   console.error('[pay] what its different?!', theSavedRequestId, requestId)
            //
            // }

        };

        // Register for an event
        iapPlugin.addListener("getProductDataResponse", eventHandler);

        // Construct object passed to method as input
        var requestOptions = {
            "skus": types
        };

        // Call method with input
        iapPlugin.getProductData(
            function (operationResponse) {
                // Handle operation response
                var requestId = operationResponse.requestId;
                theSavedRequestId = requestId
                console.log('[pay] amazone style callback for getProductData', operationResponse)
            }, function (errorResponse) {
                // Handle error response
                console.error('[pay] error getting products', errorResponse)
            },
            [requestOptions]
        );


      }

    }
  }


  if( !exports._fetching && window.cordova && window.Store && types.length ) {
    console.log('====> Store.fetch', types )
    exports._fetching = true

  }
}

function gotProducts (err, data) {
  exports._fetching = null
  try {
    console.log('[pay]====> fetch returns ' + JSON.stringify(data, null, 2))
  } catch (e) {
    console.log('[pay]====> fetch returns. Impossible to stringify data')
  }
  if( err || !data ){
    console.error( err )
    exports.single._fetching = null // bad but im in a hurry
    exports.monthly._fetching = null
    exports.yearly._fetching = null
    return
  }
  var validProducts = data.validProducts
  var typeSpecific
  var validProduct
  var productIdentifier
  var type
  var i

  if( cases.ios ) {
    for (i = validProducts.length - 1; i >= 0; i--) {
      validProduct = validProducts[i]
      productIdentifier = validProduct.productIdentifier
      type = findType( productIdentifier )
      if( exports[type] ) {
        exports[type].val = iosParseCurrency( validProduct.priceLocale )
        + validProduct.price
      }else{
        console.error( '[pay]can not find type ',type )
      }
    }
  } else {  // android
    for (i = validProducts.length - 1; i >= 0; i--) {
      validProduct = validProducts[i]
      for(type in typeMap) {
        productIdentifier = typeMap[type]
        if( validProduct[ productIdentifier ] ){
          console.log('[pay] yes put dat price', type, productIdentifier, validProduct[ productIdentifier ].price)
          exports[type].val = validProduct[ productIdentifier ].price
        } else {
          console.error( '[pay]can not find type ',type )
        }
      }
    }
  }
}

exports.single = new Value(
{ val:function(){
    if( !this._fetching ) exports()
    this._fetching = true
  }
})
exports.monthly = new Value(
{ val:function(){
    if( !this._fetching ) exports()
    this._fetching = true
  }
})
exports.yearly = new Value(
{ val:function(){
    if( !this._fetching ) exports()
    this._fetching = true
  }
})

},{"old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/receipt.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value')
var util = require('./util')
var url = config.api.url
var cases = require('old-vigour-js/browser/cases')
var base64 = require('old-vigour-js/util/encode64.js')
var dataKey = 'receiptData'
var loginTimeout = 10000
var previousRetryTime = 0
var retryTimer

function retryAfterTimeout () {
  var retryTime
  if (retryTimer) {
    clearTimeout(retryTimer)
    retryTimer = null
  }

  retryTime = previousRetryTime + (0.08 * loginTimeout)
  previousRetryTime = retryTime <= 60000 ? retryTime : 0

  retryTimer = setTimeout(function () {
    retryTimer = null
    finish()
  }, retryTime)
}

module.exports = exports = new Value({
  ajax: {
    url: url + 'api/v2/subscriptions',
    encode: 'json',
    method: 'POST',
    headers: {
      Accept: '*/*'
    },
    data: function (ajax, val) {
      console.log('[pay] receipt things ----------- next level, gonna send to', url + 'api/v2/subscriptions')
      var data
      if (this.token && this.token.val && this.receipt && this.receipt.val) {
        try {
          localStorage.setItem(dataKey, JSON.stringify(this.raw))
          console.log('successfully set', dataKey, 'to', JSON.stringify(this.raw))
        } catch (e) {
          this.type = e
          console.error('setting localStorage went wrong', e)
          update('error')
        }

        // DO DIFFERENT THINGS FOR PRODUCTS OR SUBSCRIPTIONS!

        if (cases.ios) {
          data = {
            receipt: this.receipt.val,
            vendor: 'apple'
          }

          if (this.episodeId) {
            data.episode = this.episodeId.val
          }
        } else if (cases.android) {

          if (window.AmazonIapV2) { // amazon
            console.log('[pay] bought something on amazon lets tell mtv about it')
            console.log('[pay] read stuff from window.receiptValue', this)
            window.receiptValue = this
            console.log('[pay] lets get some info')
            console.log('token?', this.receipt.val)
            console.log('userId?', this.userId.val)

            data = {
              auth_token: this.token.val,
              receipt :{
                user_id: this.userId.val,
                receipt_id: this.receiptId.val, 
              },
              vendor: 'amazon'
            }
            console.log('[pay] >>>> sending amazon receipt data', data)
          } else { // android play store
            if (!this.packageName) {
              console.error(' add a packagename for android!')
              return
            }

            data = {
              packageName: this.packageName.val,
              token: this.receipt.val,
              orderId: this.orderId.val,
              purchaseTime: this.purchaseTime.val,
              purchaseState: this.purchaseState.val,
              developerPayload: this.developerPayload.val,
              signature: this.signature.val,
              vendor: 'google'
            }

            if (this.episodeId) {
              data.episode = this.episodeId.val
            }

            if (this.subscriptionId) {
              data.subscriptionId = this.subscriptionId.val
            }
          }


        } else if (cases.windowsMobile) {
          data = {
            receipt: base64.encode(this.receipt.val),
            vendor: 'microsoft'
          }
          if (this.episodeId) {
            data.episode = this.episodeId.val
          }
        }

        if (data) {
          data.auth_token = this.token.val
          retryAfterTimeout()
        }
      }
      console.log('[pay] sending to Michael:', data)
      return data // data to send to Michael
    },
    defer: function (update, args, err, data) {
      localStorage.removeItem(dataKey)

      if (err || !data || !data.success) {
        this.type = err ? err.message : util.findError(data)
        update('error')
        this.$empty('loading')
      } else {
        previousRetryTime = 0
        update('success')
      }
    }
  }
})

exports._name = 'receipt'

function finish () {
  console.log('[pay] finish..?')
  var data = localStorage.getItem(dataKey),
    token
  if (data) {
    token = exports.token && exports.token._val

    exports.once('success', resetAuthToken)
      .once('error', resetAuthToken)

    try {
      console.log('Resending receipt data to backend', data)
      exports.val = JSON.parse(data)
    } catch (e) {
      console.error("Something went wrong processing receipt from localStorage:\n", e)
    }
  } else {
    return true
  }

  function resetAuthToken () {
    if (token) {
      console.log('resetting auth token')
      exports.token.val = token
    }
  }
}

if (cases.native) {
  document.addEventListener('resume', finish, false)
  finish()
}

},{"./util":"/Users/youzi/dev/mtv-play/api/util.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/util/encode64.js":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/encode64.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/register.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value')
var cases = require('old-vigour-js/browser/cases')
var util = require('./util')
var url = config.api.url

module.exports = exports = new Value({
  ajax: {
    url: url + 'api/v1/users.json',
    headers: {
      appVersion: 3,
      redirectUrl: config.packer.domain + '/?e=$data'
    },
    method: 'POST',
    encode: 'json',
    data: function () {
      if (!this.email || !this.password) return

      var devicetype = cases.iphone && 'iphone' || cases.android && 'android'
      var data = {
        user: {
          email: this.email.val,
          password: this.password.val,
          password_confirmation: this.password.val,
          accept_data_protection_tcs: true,
          accept_mtv_country_tcs_for: this.region.val,
          app_version: window.package.version
        }
      }

      if (this.gender) {
        data.user.gender = this.gender.val
      }
      if (this.newsletter) {
        data.user.accept_newsletter = this.newsletter.val
      }
      if (this.age && this.age.min_age) {
        data.user.min_age = this.age.min_age.val
        data.user.max_age = this.age.max_age.val
      }
      if (devicetype) {
        data.user.device_type = devicetype
      }

      return data
    },
    defer: function (update, args, err, data) {
      if (err || !data || !data.success) {
        this.type = err ? err.message : util.findError(data)
        update('error')
        this.$empty('region')
      } else {
        update('success')
      }
    }
  }
})

exports._name = 'register'

},{"./util":"/Users/youzi/dev/mtv-play/api/util.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/tracking/context.js":[function(require,module,exports){
var map = require( './map' )
var ua = require( 'old-vigour-js/browser/ua' )
var config = require( 'old-vigour-js/util/config' )
var omniture = require( './omniture' )
var cases = require( 'old-vigour-js/browser/cases' )
var app = require( 'old-vigour-js/app/' )

module.exports = function context( title, pageView, franchise ) {

  var user = omniture.user
  var pckg = window.package
  var userData = user && user.data && user.data.from.cloud && user.data.from

  var role = user ? user.role.val : 0
  var d = new Date()
  var select
  var prop
  var _contextMap
  var branch = pckg ? pckg.repository && pckg.repository.branch : 'master'
  var device
  var userId = ( userData && userData._name ) || 'not available'

  if( userId === 'userData' ) userId = 'unregistered'

  if( branch === 'master' ) branch = 'dev'

  if( pageView ) {
    select = 0
    prop = 'prop'
  } else {
    select = 1
    prop = 'eVar'
      // alert('evars?')
  }

  if( role === 0 ) {
    role = 'free'
  } else if( role === 1 ) {
    role = 'premium'
  } else if( role === 2 ) {
    role = 'mtv mobile'
  } else if( role === 3 ) {
    role = 'trial'
  } else {
    role = 'unregistered'
  }

  if( ua.platform === 'ios' ) {
    if( ua.device === 'phone' ) {
      device = 'iPhone'
    } else {
      device = 'iPad'
    }
  }

  // console.log( '-------->', title )

  _contextMap = {
    branch: branch,
    title: title,
    version: window.package && window.package.version,
    role: role,
    device: device || ( ua.platform + ' ' + ua.device ),
    region: app.country || config.region.val, //when app.region/config.region is overwritten app.country === the real region
    lang: config.language.val,
    weekDay: map.weekDays[ d.getDay() ],
    hour: d.getHours() || 24
      //age gender
      ,
    age: userData && userData.get && userData.get( 'birthday', false ).val || 'not available',
    gender: userData && userData.get && userData.get( 'gender', false ).val || 'not available',
    native: ( window.cordova || ( ua.device === 'tv' || ua.device === 'cast' ) ) ? 'native' : 'web',
    userId: userId || 'unregistered',
    connected: String( cases.$hasReceiver.val ) || 'none',
    secondscreen: String( !cases.$isActive.val ) || 'none',
    devicesPresent: String( cases.$hasDevices.val ) || 'none',
    loginStyle: cases.$isLoggedIn.val && userData ? userData.facebook_id && userData.facebook_id.val ? 'facebook' : 'email' : 'none',
    network: app.network.val || 'not available',
    networkOperator: 'not available'
  }

  if( !franchise ) _contextMap.title = 'none'

  for( var i in _contextMap ) {
    omniture[ prop + map.vars[ i ][ select ] ] = _contextMap[ i ]
  }

}

},{"./map":"/Users/youzi/dev/mtv-play/api/tracking/map.js","./omniture":"/Users/youzi/dev/mtv-play/api/tracking/omniture.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/api/tracking/dataform.js":[function(require,module,exports){
var ajax = require( 'old-vigour-js/browser/network/ajax' );
var postpone = require( 'old-vigour-js/browser/events/util' ).postpone;
require( './ga' )

var cid

if( window.device ) {
  cid = window.device.uuid
} else {
  ga( function( tracker ) {
    cid = tracker.get( 'clientId' )
  } )
}

var sendData = function( payload ) {
  payload.an = 'MTV Play',
    payload.tid = 'UA-43955457-6',
    payload.cid = cid

  ajax( {
    url: 'https://www.google-analytics.com/collect?v=1',
    method: 'POST',
    headers: {
      accept: 'text/plain'
    },
    data: payload
  } )
}

var sendEvent = function( category, action, label ) {
  sendData( {
    t: 'event',
    ec: category,
    ea: action,
    el: label
  } )
}

var setUserid = function( uid ) {
  sendData( {
    uid: uid
  } )
}

var setDimension = function( dimension ) {
  var dataform = {}
  dataform.cm1 = dimension
  sendData( dataform )
}

exports.sendData = sendData;
exports.sendEvent = sendEvent;
exports.setUserid = setUserid;
exports.setDimension = setDimension;

},{"./ga":"/Users/youzi/dev/mtv-play/api/tracking/ga.js","old-vigour-js/browser/events/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js","old-vigour-js/browser/network/ajax":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/ajax.js"}],"/Users/youzi/dev/mtv-play/api/tracking/dfp.js":[function(require,module,exports){
var cases = require('old-vigour-js/browser/cases')
var googletag = window.googletag

if (!cases.phone && googletag && googletag.apiReady) {
  googletag.cmd.push(function () {
    googletag.defineSlot('/7869/intl_mtvplay.tv/' + 'discover', [
      [728, 90],
      [970, 90],
      [970, 250]
    ], 'leaderboard').setTargeting('pos', ['atf']).setTargeting('slot', ['1']).addService(googletag.pubads())
    googletag.pubads().enableSingleRequest()
    googletag.pubads().collapseEmptyDivs(true)
    googletag.pubads().setCentering(true)
    googletag.enableServices()
    googletag.display('leaderboard')
  })
}

module.exports = function (page) {
//   var mapping = googletag.sizeMapping().
//   addSize([1024, 768], [970, 250]).
//   addSize([980, 690], [728, 90]).
//   addSize([640, 480], [120, 60]).
//   addSize([0, 0], [88, 31]).
//   // Fits browsers of any size smaller than 640 x 480
//   build();
// adSlot.defineSizeMapping(mapping)

  function displayBillboard (pageName, info) {
    var show
    var season
    var episode
    var contentType

    if (info) {
      show = info[1]
      season = info[3]
      episode = info[5]
      contentType = 'video'
    } else {
      show = season = episode = contentType = 'none'
    }
    googletag.cmd.push(function () {
      googletag.pubads()
        .setTargeting('show_season', [season])
        .setTargeting('subject_schema', ['none'])
        .setTargeting('content_type', [contentType])
        .setTargeting('testmode', ['on'])
        .setTargeting('subject', [show])
        .setTargeting('show_episode', [episode])
        .setTargeting('section', [pageName])
        .setCentering(true)
      googletag.enableServices()
    })
  }

  var name = page.name
  // console.error('-- doing dfp')
  if (cases.phone) {
    if (window.googletag && googletag.apiReady) {
      googletag.cmd.push(function () {
        googletag.defineSlot('/7869/intl_mtvplay.tv/discover', [1, 2],
          'div-gpt-ad-1445622141110-3')
          .setTargeting('pos', ['atf'])
          .setTargeting('slot', ['3'])
          .addService(googletag.pubads())
        googletag.pubads().enableSingleRequest()
        googletag.pubads().collapseEmptyDivs()
        googletag.pubads()
          .setTargeting('show_season', ['none'])
          .setTargeting('subject_schema', ['none'])
          .setTargeting('content_type', ['none'])
          .setTargeting('testmode', ['on'])
          .setTargeting('subject', ['none'])
          .setTargeting('show_episode', ['none'])
          .setTargeting('section', ['discover'])
        googletag.enableServices()
        googletag.display('div-gpt-ad-1445622141110-3')
      })  
    }
  } else {
    if (!page.title) {
      displayBillboard(name)
    }
    if (page.title) {
      var info = page.name.split('>')
      displayBillboard('shows', info)
      googletag.cmd.push(function () {
        googletag.defineSlot('/7869/intl_mtvplay.tv/shows', [
          [300, 250],
          [300, 600]
        ], 'div-gpt-ad-1445622141110-2')
          .setTargeting('pos', ['atf'])
          .setTargeting('slot', ['2'])
          .addService(googletag.pubads())
        googletag.pubads()
          .setTargeting('show_season', [info[3]])
          .setTargeting('subject_schema', ['none'])
          .setTargeting('content_type', ['video'])
          .setTargeting('testmode', ['on'])
          .setTargeting('subject', [info[1]])
          .setTargeting('show_episode', [info[5]])
          .setTargeting('section', ['shows'])
        googletag.pubads().enableSingleRequest()
        googletag.pubads().collapseEmptyDivs(true)
        googletag.enableServices()
        googletag.display('div-gpt-ad-1445622141110-2')
      })
    }
  }
}

},{"old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/api/tracking/ga.js":[function(require,module,exports){
var cases = require( 'old-vigour-js/browser/cases' );

( function( i, s, o, g, r, a, m ) {
  i[ 'GoogleAnalyticsObject' ] = r;
  i[ r ] = i[ r ] || function() {
    ( i[ r ].q = i[ r ].q || [] ).push( arguments )
  }, i[ r ].l = 1 * new Date();
  a = s.createElement( o ),
    m = s.getElementsByTagName( o )[ 0 ];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore( a, m )
} )( window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga' );

if( !cases.native ) {
  ga( 'create', 'UA-43955457-6', 'auto' )
} else {
  ga( 'set', {
    'checkProtocolTask': null,
    'storage': 'none',
  } );
}


module.exports = window.ga

},{"old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/api/tracking/index.js":[function(require,module,exports){
var omniture = require('./omniture')
var postpone = require('old-vigour-js/browser/events/util').postpone
var ua = require('old-vigour-js/browser/ua')
var config = require('old-vigour-js/util/config')
var url = require('old-vigour-js/browser/network/url')
var map = require('./map')
var context = require('./context')
var pageName = require('./pagename')
var ajax = require('old-vigour-js/browser/network/ajax')
var user = require('../../app/user')
var cases = require('old-vigour-js/browser/cases')
var uid
var lastVid
var sendData = require('./dataform').sendData
var sendEvent = require('./dataform').sendEvent
var dfp = require('./dfp')
var infoOnline = require('./infoOnline')
var nuggad = require('./nuggad')


infoOnline.init()
nuggad.initialize()
// if (!cases.native) {
//   nuggad.initialize()
// }

exports.omniture = omniture
omniture.account = config.omniture

var tlDelayed = postpone(function () {
  omniture.tl.apply(this, arguments)
  delete omniture.events
}, 1e3)

exports.setSearchProp = postpone(function (search) {
  if (search) {
    omniture['prop' + map.vars.search[0]] = search
  }
}, 1e3)

exports.video = function (val, media, title) {

  if (!title) {
    title = media
  }

  if (media.from) {
    title = media.from._cachedPath
  }

  if (typeof title !== 'string') {
    return
  }

  var eventType = (val === 'videoPlay' || val === 'videoPause') ? val : ''
  var compare
  var vidEventMap = {
    videostart: [0, 0.1],
    video25: [0.25, 0.26],
    video50: [0.5, 0.51],
    video75: [0.75, 0.76],
    videofinished: [0.9, 0.95]
  }
  val = -1 * val
  if (!eventType) {
    for (var event$ in vidEventMap) {
      if (val > vidEventMap[event$][0] && val < vidEventMap[event$][1]) {
        eventType = event$
        compare = eventType + title
        if (lastVid && (eventType + title) === lastVid) {
          return
        }
        lastVid = eventType + title
        break
      }
    }
  }

  //track watch, id to utt backend
  if (eventType && media.from._parent._parent) {
    var pageNameObj = pageName(media.from._parent._parent._parent._cachedPath)
    var vidname = 'video > ' + pageNameObj.name

    context(pageNameObj.title, false, true)

    if (vidname.split('>').length < 7) {
      vidname += ' > seasons 1 > episodes 1'
    }

    vidname += (' : ' + media.get('title', '').val).toLowerCase()

    if (cases.$isOnChannel.val) {
      vidname = media.get('title', '').val
    }
    omniture['eVar' + map.vars.videoName[1]] = vidname
    omniture.events = 'event' + map.events[eventType]

    if (eventType === 'videostart') {
      triggerWatch(media.id.val)
      console.log('doing this')
      infoOnline.sendData(pageNameObj, true)
    }
    omniture.tl(true, 'o', eventType)
  }
}

function triggerWatch (id) {
  var token = user.token.val
  var url = config.api.url + 'api/v1/users/' + token + '/activities'
  var isChannel = cases.$isOnChannel.val
  var payload = {
    activity: {
      action: 'watch',
      resource_type: (isChannel) ? 'simulcast' : 'episode',
      resource_id: id,
      repository: 'sensei',
      environment: 'production'
    }
  }
  sendEvent('event', 'video', 'watch')

  if (token) {
    ajax({
      url: url,
      method: 'POST',
      headers: {
        accept: 'application/json'
      },
      encode: 'json',
      data: payload,
      error: function (err) {
        console.error('POST', url, payload, err)
      }
    })
  }
}

exports.event = postpone(function (eventType, flag, link, video) {
  // send event same for all
  if (eventType === 'swipeUp') {
    sendEvent('event', 'multiscreen', 'swipe-up')
  };

  omniture.events = 'event' + map.events[eventType]

  context()

  if (eventType === 'upgradeMtvFailed') {
    omniture['eVar' + map.events.mtvMobileFailed] = flag
  } else if (eventType === 'teaserClick') {
    // alert('fuckery')
    // omniture['eVar'+map.events.teaserCollection ] = flag
    // omniture['eVar'+map.events.teaserClicked ] = link && pageName(link).name //get link yourself its a path
  } else if (eventType) {
    // omniture['eVar'+map.events[eventType] ] = flag || true
  }
  if (eventType === 'search') {
    tlDelayed(true, 'o', eventType)
  } else {
    omniture.tl(true, 'o', eventType)
    delete omniture.events
  }
  if (eventType === 'sharingFacebookSucces') {
    triggerFbShare()
  }
}, 1e3)

function triggerFbShare () {
  var auth_token = user.token.val
  var resourceType = 'UNKNOWN'
  var id = 'UNKNOWN'
  var url = config.api.url + '/api/v1/users/' + auth_token + '/activities'
  var payload = {
    'activity': {
      'action': 'share',
      'resource_type': resourceType,
      'resource_id': id,
      'repository': 'sensei',
      'environment': 'production'
    }
  }
  sendEvent('event', 'sharing', 'facebook')
}

exports.popup = postpone(function (name) {
  if (!name) {
    return
  }
  var pageName = ''
  context(name, true, false)
  omniture.pageName = (pageName + 'other > ' + name).toLowerCase()
  omniture.t()
}, 1e3)

exports.pageView = postpone(function (obj) {
  if (obj.from) {
    obj = obj.from._cachedPath
  }

  if (typeof obj !== 'string') {
    return
  }

  var pageNameObj = pageName(obj)
  var title = pageNameObj.title

  omniture.pageName = (pageNameObj.name).toLowerCase()

  context(title, true, ~obj.lastIndexOf('.'))

  omniture.t()

  infoOnline.sendData(pageNameObj)

  // nuggad.sendData()
  if (!cases.native) {
    nuggad.sendData()
  }

  if ( !cases.$isUpgraded.val || !cases.$hasMobile.val ) {
    if (window && window.googletag) {
      window.googletag.pubads().updateCorrelator()
      window.googletag.pubads().refresh()
    }
    dfp(pageNameObj)
  }

  var dataform = {
    t: 'appview',
    aip: 1,
    cd: pageNameObj.name
  }

  if (uid) {
    dataform.uid = uid
  }
  sendData(dataform)
}, 1e3)

cases.$isLoggedIn.on(function () {
  if (cases.$isLoggedIn.val) {
    uid = user.id.val
  } else {
    uid = false
  }
})

},{"../../app/user":"/Users/youzi/dev/mtv-play/app/user.js","./context":"/Users/youzi/dev/mtv-play/api/tracking/context.js","./dataform":"/Users/youzi/dev/mtv-play/api/tracking/dataform.js","./dfp":"/Users/youzi/dev/mtv-play/api/tracking/dfp.js","./infoOnline":"/Users/youzi/dev/mtv-play/api/tracking/infoOnline.js","./map":"/Users/youzi/dev/mtv-play/api/tracking/map.js","./nuggad":"/Users/youzi/dev/mtv-play/api/tracking/nuggad.js","./omniture":"/Users/youzi/dev/mtv-play/api/tracking/omniture.js","./pagename":"/Users/youzi/dev/mtv-play/api/tracking/pagename.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/events/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js","old-vigour-js/browser/network/ajax":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/ajax.js","old-vigour-js/browser/network/url":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/url.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/api/tracking/infoOnline.js":[function(require,module,exports){
var cases = require('old-vigour-js/browser/cases')
var app = require('old-vigour-js/app')

exports.init = function () {
  var script = document.createElement('script')
  script.onerror = function (err) {
    console.error(err)
  }
  script.src = 'https://script.ioam.de/iam.js'
  script.type = 'text/javascript'

  document.getElementsByTagName('head')[0].appendChild(script)
}

exports.sendData = function (page, videoStart) {
  var region = app.region.val
  if (!cases.native && region === 'DE') {
    var iam_data = {
      'st': 'mtv',
      'cp': 'mtvplay/',
      'sv': '',
      'co': 'kommentar'
    }
    if (cases.phone) {
      iam_data.st = 'mobmtv'
    }

    if (videoStart) {
      iam_data.cp = 'mtvplay/videostarted'
      iam_data.sv = 'in'
    } else {
      if (page.name === 'discover') {
        iam_data.cp += 'homepage'
        iam_data.sv = 'ke'
      }
      if (page.title || page.name === 'shows' || page.name === 'channels') {
        if (page.title) {
          var parsedPage = page.name.split('>')[0]
          if (parsedPage === 'tv ') {
            iam_data.cp = 'mtvplay/channels'
          }
          if (parsedPage === 'shows ') {
            iam_data.cp = 'mtvplay/shows'
          }
        } else {
          iam_data.cp = 'mtvplay/' + page.name
        }
      }
    }
    window.iom.h(iam_data, 1)
  }
}

},{"old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/api/tracking/lib/AppMeasurement.js":[function(require,module,exports){
/*
 ============== DO NOT ALTER ANYTHING BELOW THIS LINE ! ===============

 AppMeasurement for JavaScript version: 1.4.1
 Copyright 1996-2013 Adobe, Inc. All Rights Reserved
 More info available at http://www.omniture.com
*/
function AppMeasurement(){var s=this;s.version="1.4.1";var w=window;if(!w.s_c_in)w.s_c_il=[],w.s_c_in=0;s._il=w.s_c_il;s._in=w.s_c_in;s._il[s._in]=s;w.s_c_in++;s._c="s_c";var k=w.sb;k||(k=null);var m=w,i,o;try{i=m.parent;for(o=m.location;i&&i.location&&o&&""+i.location!=""+o&&m.location&&""+i.location!=""+m.location&&i.location.host==o.host;)m=i,i=m.parent}catch(p){}s.eb=function(s){try{console.log(s)}catch(a){}};s.ta=function(s){return""+parseInt(s)==""+s};s.replace=function(s,a,c){if(!s||s.indexOf(a)<
0)return s;return s.split(a).join(c)};s.escape=function(b){var a,c;if(!b)return b;b=encodeURIComponent(b);for(a=0;a<7;a++)c="+~!*()'".substring(a,a+1),b.indexOf(c)>=0&&(b=s.replace(b,c,"%"+c.charCodeAt(0).toString(16).toUpperCase()));return b};s.unescape=function(b){if(!b)return b;b=b.indexOf("+")>=0?s.replace(b,"+"," "):b;try{return decodeURIComponent(b)}catch(a){}return unescape(b)};s.Va=function(){var b=w.location.hostname,a=s.fpCookieDomainPeriods,c;if(!a)a=s.cookieDomainPeriods;if(b&&!s.cookieDomain&&
!/^[0-9.]+$/.test(b)&&(a=a?parseInt(a):2,a=a>2?a:2,c=b.lastIndexOf("."),c>=0)){for(;c>=0&&a>1;)c=b.lastIndexOf(".",c-1),a--;s.cookieDomain=c>0?b.substring(c):b}return s.cookieDomain};s.c_r=s.cookieRead=function(b){b=s.escape(b);var a=" "+s.d.cookie,c=a.indexOf(" "+b+"="),e=c<0?c:a.indexOf(";",c);b=c<0?"":s.unescape(a.substring(c+2+b.length,e<0?a.length:e));return b!="[[B]]"?b:""};s.c_w=s.cookieWrite=function(b,a,c){var e=s.Va(),d=s.cookieLifetime,f;a=""+a;d=d?(""+d).toUpperCase():"";c&&d!="SESSION"&&
d!="NONE"&&((f=a!=""?parseInt(d?d:0):-60)?(c=new Date,c.setTime(c.getTime()+f*1E3)):c==1&&(c=new Date,f=c.getYear(),c.setYear(f+5+(f<1900?1900:0))));if(b&&d!="NONE")return s.d.cookie=b+"="+s.escape(a!=""?a:"[[B]]")+"; path=/;"+(c&&d!="SESSION"?" expires="+c.toGMTString()+";":"")+(e?" domain="+e+";":""),s.cookieRead(b)==a;return 0};s.C=[];s.B=function(b,a,c){if(s.ma)return 0;if(!s.maxDelay)s.maxDelay=250;var e=0,d=(new Date).getTime()+s.maxDelay,f=s.d.qb,g=["webkitvisibilitychange","visibilitychange"];
if(!f)f=s.d.rb;if(f&&f=="prerender"){if(!s.X){s.X=1;for(c=0;c<g.length;c++)s.d.addEventListener(g[c],function(){var a=s.d.qb;if(!a)a=s.d.rb;if(a=="visible")s.X=0,s.delayReady()})}e=1;d=0}else c||s.q("_d")&&(e=1);e&&(s.C.push({m:b,a:a,t:d}),s.X||setTimeout(s.delayReady,s.maxDelay));return e};s.delayReady=function(){var b=(new Date).getTime(),a=0,c;for(s.q("_d")&&(a=1);s.C.length>0;){c=s.C.shift();if(a&&!c.t&&c.t>b){s.C.unshift(c);setTimeout(s.delayReady,parseInt(s.maxDelay/2));break}s.ma=1;s[c.m].apply(s,
c.a);s.ma=0}};s.setAccount=s.sa=function(b){var a,c;if(!s.B("setAccount",arguments))if(s.account=b,s.allAccounts){a=s.allAccounts.concat(b.split(","));s.allAccounts=[];a.sort();for(c=0;c<a.length;c++)(c==0||a[c-1]!=a[c])&&s.allAccounts.push(a[c])}else s.allAccounts=b.split(",")};s.foreachVar=function(b,a){var c,e,d,f,g="";d=e="";if(s.lightProfileID)c=s.H,(g=s.lightTrackVars)&&(g=","+g+","+s.ba.join(",")+",");else{c=s.c;if(s.pe||s.linkType)if(g=s.linkTrackVars,e=s.linkTrackEvents,s.pe&&(d=s.pe.substring(0,
1).toUpperCase()+s.pe.substring(1),s[d]))g=s[d].pb,e=s[d].ob;g&&(g=","+g+","+s.z.join(",")+",");e&&g&&(g+=",events,")}a&&(a=","+a+",");for(e=0;e<c.length;e++)d=c[e],(f=s[d])&&(!g||g.indexOf(","+d+",")>=0)&&(!a||a.indexOf(","+d+",")>=0)&&b(d,f)};s.J=function(b,a,c,e,d){var f="",g,j,w,q,i=0;b=="contextData"&&(b="c");if(a){for(g in a)if(!Object.prototype[g]&&(!d||g.substring(0,d.length)==d)&&a[g]&&(!c||c.indexOf(","+(e?e+".":"")+g+",")>=0)){w=!1;if(i)for(j=0;j<i.length;j++)g.substring(0,i[j].length)==
i[j]&&(w=!0);if(!w&&(f==""&&(f+="&"+b+"."),j=a[g],d&&(g=g.substring(d.length)),g.length>0))if(w=g.indexOf("."),w>0)j=g.substring(0,w),w=(d?d:"")+j+".",i||(i=[]),i.push(w),f+=s.J(j,a,c,e,w);else if(typeof j=="boolean"&&(j=j?"true":"false"),j){if(e=="retrieveLightData"&&d.indexOf(".contextData.")<0)switch(w=g.substring(0,4),q=g.substring(4),g){case "transactionID":g="xact";break;case "channel":g="ch";break;case "campaign":g="v0";break;default:s.ta(q)&&(w=="prop"?g="c"+q:w=="eVar"?g="v"+q:w=="list"?
g="l"+q:w=="hier"&&(g="h"+q,j=j.substring(0,255)))}f+="&"+s.escape(g)+"="+s.escape(j)}}f!=""&&(f+="&."+b)}return f};s.Xa=function(){var b="",a,c,e,d,f,g,j,w,i="",k="",m=c="";if(s.lightProfileID)a=s.H,(i=s.lightTrackVars)&&(i=","+i+","+s.ba.join(",")+",");else{a=s.c;if(s.pe||s.linkType)if(i=s.linkTrackVars,k=s.linkTrackEvents,s.pe&&(c=s.pe.substring(0,1).toUpperCase()+s.pe.substring(1),s[c]))i=s[c].pb,k=s[c].ob;i&&(i=","+i+","+s.z.join(",")+",");k&&(k=","+k+",",i&&(i+=",events,"));s.events2&&(m+=(m!=
""?",":"")+s.events2)}s.AudienceManagement&&s.AudienceManagement.isReady()&&(b+=s.J("d",s.AudienceManagement.getEventCallConfigParams()));for(c=0;c<a.length;c++){d=a[c];f=s[d];e=d.substring(0,4);g=d.substring(4);!f&&d=="events"&&m&&(f=m,m="");if(f&&(!i||i.indexOf(","+d+",")>=0)){switch(d){case "supplementalDataID":d="sdid";break;case "timestamp":d="ts";break;case "dynamicVariablePrefix":d="D";break;case "visitorID":d="vid";break;case "marketingCloudVisitorID":d="mid";break;case "analyticsVisitorID":d=
"aid";break;case "audienceManagerLocationHint":d="aamlh";break;case "audienceManagerBlob":d="aamb";break;case "authState":d="as";break;case "pageURL":d="g";if(f.length>255)s.pageURLRest=f.substring(255),f=f.substring(0,255);break;case "pageURLRest":d="-g";break;case "referrer":d="r";break;case "vmk":case "visitorMigrationKey":d="vmt";break;case "visitorMigrationServer":d="vmf";s.ssl&&s.visitorMigrationServerSecure&&(f="");break;case "visitorMigrationServerSecure":d="vmf";!s.ssl&&s.visitorMigrationServer&&
(f="");break;case "charSet":d="ce";break;case "visitorNamespace":d="ns";break;case "cookieDomainPeriods":d="cdp";break;case "cookieLifetime":d="cl";break;case "variableProvider":d="vvp";break;case "currencyCode":d="cc";break;case "channel":d="ch";break;case "transactionID":d="xact";break;case "campaign":d="v0";break;case "latitude":d="lat";break;case "longitude":d="lon";break;case "resolution":d="s";break;case "colorDepth":d="c";break;case "javascriptVersion":d="j";break;case "javaEnabled":d="v";
break;case "cookiesEnabled":d="k";break;case "browserWidth":d="bw";break;case "browserHeight":d="bh";break;case "connectionType":d="ct";break;case "homepage":d="hp";break;case "events":m&&(f+=(f!=""?",":"")+m);if(k){g=f.split(",");f="";for(e=0;e<g.length;e++)j=g[e],w=j.indexOf("="),w>=0&&(j=j.substring(0,w)),w=j.indexOf(":"),w>=0&&(j=j.substring(0,w)),k.indexOf(","+j+",")>=0&&(f+=(f?",":"")+g[e])}break;case "events2":f="";break;case "contextData":b+=s.J("c",s[d],i,d);f="";break;case "lightProfileID":d=
"mtp";break;case "lightStoreForSeconds":d="mtss";s.lightProfileID||(f="");break;case "lightIncrementBy":d="mti";s.lightProfileID||(f="");break;case "retrieveLightProfiles":d="mtsr";break;case "deleteLightProfiles":d="mtsd";break;case "retrieveLightData":s.retrieveLightProfiles&&(b+=s.J("mts",s[d],i,d));f="";break;default:s.ta(g)&&(e=="prop"?d="c"+g:e=="eVar"?d="v"+g:e=="list"?d="l"+g:e=="hier"&&(d="h"+g,f=f.substring(0,255)))}f&&(b+="&"+d+"="+(d.substring(0,3)!="pev"?s.escape(f):f))}d=="pev3"&&s.g&&
(b+=s.g)}return b};s.u=function(s){var a=s.tagName;if(""+s.wb!="undefined"||""+s.ib!="undefined"&&(""+s.ib).toUpperCase()!="HTML")return"";a=a&&a.toUpperCase?a.toUpperCase():"";a=="SHAPE"&&(a="");a&&((a=="INPUT"||a=="BUTTON")&&s.type&&s.type.toUpperCase?a=s.type.toUpperCase():!a&&s.href&&(a="A"));return a};s.oa=function(s){var a=s.href?s.href:"",c,e,d;c=a.indexOf(":");e=a.indexOf("?");d=a.indexOf("/");if(a&&(c<0||e>=0&&c>e||d>=0&&c>d))e=s.protocol&&s.protocol.length>1?s.protocol:l.protocol?l.protocol:
"",c=l.pathname.lastIndexOf("/"),a=(e?e+"//":"")+(s.host?s.host:l.host?l.host:"")+(h.substring(0,1)!="/"?l.pathname.substring(0,c<0?0:c)+"/":"")+a;return a};s.D=function(b){var a=s.u(b),c,e,d="",f=0;if(a){c=b.protocol;e=b.onclick;if(b.href&&(a=="A"||a=="AREA")&&(!e||!c||c.toLowerCase().indexOf("javascript")<0))d=s.oa(b);else if(e)d=s.replace(s.replace(s.replace(s.replace(""+e,"\r",""),"\n",""),"\t","")," ",""),f=2;else if(a=="INPUT"||a=="SUBMIT"){if(b.value)d=b.value;else if(b.innerText)d=b.innerText;
else if(b.textContent)d=b.textContent;f=3}else if(b.src&&a=="IMAGE")d=b.src;if(d)return{id:d.substring(0,100),type:f}}return 0};s.tb=function(b){for(var a=s.u(b),c=s.D(b);b&&!c&&a!="BODY";)if(b=b.parentElement?b.parentElement:b.parentNode)a=s.u(b),c=s.D(b);if(!c||a=="BODY")b=0;if(b&&(a=b.onclick?""+b.onclick:"",a.indexOf(".tl(")>=0||a.indexOf(".trackLink(")>=0))b=0;return b};s.hb=function(){var b,a,c=s.linkObject,e=s.linkType,d=s.linkURL,f,g;s.ca=1;if(!c)s.ca=0,c=s.clickObject;if(c){b=s.u(c);for(a=
s.D(c);c&&!a&&b!="BODY";)if(c=c.parentElement?c.parentElement:c.parentNode)b=s.u(c),a=s.D(c);if(!a||b=="BODY")c=0;if(c){var j=c.onclick?""+c.onclick:"";if(j.indexOf(".tl(")>=0||j.indexOf(".trackLink(")>=0)c=0}}else s.ca=1;!d&&c&&(d=s.oa(c));d&&!s.linkLeaveQueryString&&(f=d.indexOf("?"),f>=0&&(d=d.substring(0,f)));if(!e&&d){var i=0,k=0,m;if(s.trackDownloadLinks&&s.linkDownloadFileTypes){j=d.toLowerCase();f=j.indexOf("?");g=j.indexOf("#");f>=0?g>=0&&g<f&&(f=g):f=g;f>=0&&(j=j.substring(0,f));f=s.linkDownloadFileTypes.toLowerCase().split(",");
for(g=0;g<f.length;g++)(m=f[g])&&j.substring(j.length-(m.length+1))=="."+m&&(e="d")}if(s.trackExternalLinks&&!e&&(j=d.toLowerCase(),s.ra(j))){if(!s.linkInternalFilters)s.linkInternalFilters=w.location.hostname;f=0;s.linkExternalFilters?(f=s.linkExternalFilters.toLowerCase().split(","),i=1):s.linkInternalFilters&&(f=s.linkInternalFilters.toLowerCase().split(","));if(f){for(g=0;g<f.length;g++)m=f[g],j.indexOf(m)>=0&&(k=1);k?i&&(e="e"):i||(e="e")}}}s.linkObject=c;s.linkURL=d;s.linkType=e;if(s.trackClickMap||
s.trackInlineStats)if(s.g="",c){e=s.pageName;d=1;c=c.sourceIndex;if(!e)e=s.pageURL,d=0;if(w.s_objectID)a.id=w.s_objectID,c=a.type=1;if(e&&a&&a.id&&b)s.g="&pid="+s.escape(e.substring(0,255))+(d?"&pidt="+d:"")+"&oid="+s.escape(a.id.substring(0,100))+(a.type?"&oidt="+a.type:"")+"&ot="+b+(c?"&oi="+c:"")}};s.Ya=function(){var b=s.ca,a=s.linkType,c=s.linkURL,e=s.linkName;if(a&&(c||e))a=a.toLowerCase(),a!="d"&&a!="e"&&(a="o"),s.pe="lnk_"+a,s.pev1=c?s.escape(c):"",s.pev2=e?s.escape(e):"",b=1;s.abort&&(b=
0);if(s.trackClickMap||s.trackInlineStats){a={};c=0;var d=s.cookieRead("s_sq"),f=d?d.split("&"):0,g,j,w;d=0;if(f)for(g=0;g<f.length;g++)j=f[g].split("="),e=s.unescape(j[0]).split(","),j=s.unescape(j[1]),a[j]=e;e=s.account.split(",");if(b||s.g){b&&!s.g&&(d=1);for(j in a)if(!Object.prototype[j])for(g=0;g<e.length;g++){d&&(w=a[j].join(","),w==s.account&&(s.g+=(j.charAt(0)!="&"?"&":"")+j,a[j]=[],c=1));for(f=0;f<a[j].length;f++)w=a[j][f],w==e[g]&&(d&&(s.g+="&u="+s.escape(w)+(j.charAt(0)!="&"?"&":"")+j+
"&u=0"),a[j].splice(f,1),c=1)}b||(c=1);if(c){d="";g=2;!b&&s.g&&(d=s.escape(e.join(","))+"="+s.escape(s.g),g=1);for(j in a)!Object.prototype[j]&&g>0&&a[j].length>0&&(d+=(d?"&":"")+s.escape(a[j].join(","))+"="+s.escape(j),g--);s.cookieWrite("s_sq",d)}}}return b};s.Za=function(){if(!s.nb){var b=new Date,a=m.location,c,e,d=e=c="",f="",g="",w="1.2",i=s.cookieWrite("s_cc","true",0)?"Y":"N",k="",n="";if(b.setUTCDate&&(w="1.3",(0).toPrecision&&(w="1.5",b=[],b.forEach))){w="1.6";e=0;c={};try{e=new Iterator(c),
e.next&&(w="1.7",b.reduce&&(w="1.8",w.trim&&(w="1.8.1",Date.parse&&(w="1.8.2",Object.create&&(w="1.8.5")))))}catch(o){}}c=screen.width+"x"+screen.height;d=navigator.javaEnabled()?"Y":"N";e=screen.pixelDepth?screen.pixelDepth:screen.colorDepth;f=s.w.innerWidth?s.w.innerWidth:s.d.documentElement.offsetWidth;g=s.w.innerHeight?s.w.innerHeight:s.d.documentElement.offsetHeight;try{s.b.addBehavior("#default#homePage"),k=s.b.ub(a)?"Y":"N"}catch(p){}try{s.b.addBehavior("#default#clientCaps"),n=s.b.connectionType}catch(r){}s.resolution=
c;s.colorDepth=e;s.javascriptVersion=w;s.javaEnabled=d;s.cookiesEnabled=i;s.browserWidth=f;s.browserHeight=g;s.connectionType=n;s.homepage=k;s.nb=1}};s.I={};s.loadModule=function(b,a){var c=s.I[b];if(!c){c=w["AppMeasurement_Module_"+b]?new w["AppMeasurement_Module_"+b](s):{};s.I[b]=s[b]=c;c.Fa=function(){return c.Ja};c.Ka=function(a){if(c.Ja=a)s[b+"_onLoad"]=a,s.B(b+"_onLoad",[s,c],1)||a(s,c)};try{Object.defineProperty?Object.defineProperty(c,"onLoad",{get:c.Fa,set:c.Ka}):c._olc=1}catch(e){c._olc=
1}}a&&(s[b+"_onLoad"]=a,s.B(b+"_onLoad",[s,c],1)||a(s,c))};s.q=function(b){var a,c;for(a in s.I)if(!Object.prototype[a]&&(c=s.I[a])){if(c._olc&&c.onLoad)c._olc=0,c.onLoad(s,c);if(c[b]&&c[b]())return 1}return 0};s.bb=function(){var b=Math.floor(Math.random()*1E13),a=s.visitorSampling,c=s.visitorSamplingGroup;c="s_vsn_"+(s.visitorNamespace?s.visitorNamespace:s.account)+(c?"_"+c:"");var e=s.cookieRead(c);if(a){e&&(e=parseInt(e));if(!e){if(!s.cookieWrite(c,b))return 0;e=b}if(e%1E4>v)return 0}return 1};
s.K=function(b,a){var c,e,d,f,g,w;for(c=0;c<2;c++){e=c>0?s.ia:s.c;for(d=0;d<e.length;d++)if(f=e[d],(g=b[f])||b["!"+f]){if(!a&&(f=="contextData"||f=="retrieveLightData")&&s[f])for(w in s[f])g[w]||(g[w]=s[f][w]);s[f]=g}}};s.Aa=function(b,a){var c,e,d,f;for(c=0;c<2;c++){e=c>0?s.ia:s.c;for(d=0;d<e.length;d++)f=e[d],b[f]=s[f],!a&&!b[f]&&(b["!"+f]=1)}};s.Ua=function(s){var a,c,e,d,f,g=0,w,i="",k="";if(s&&s.length>255&&(a=""+s,c=a.indexOf("?"),c>0&&(w=a.substring(c+1),a=a.substring(0,c),d=a.toLowerCase(),
e=0,d.substring(0,7)=="http://"?e+=7:d.substring(0,8)=="https://"&&(e+=8),c=d.indexOf("/",e),c>0&&(d=d.substring(e,c),f=a.substring(c),a=a.substring(0,c),d.indexOf("google")>=0?g=",q,ie,start,search_key,word,kw,cd,":d.indexOf("yahoo.co")>=0&&(g=",p,ei,"),g&&w)))){if((s=w.split("&"))&&s.length>1){for(e=0;e<s.length;e++)d=s[e],c=d.indexOf("="),c>0&&g.indexOf(","+d.substring(0,c)+",")>=0?i+=(i?"&":"")+d:k+=(k?"&":"")+d;i&&k?w=i+"&"+k:k=""}c=253-(w.length-k.length)-a.length;s=a+(c>0?f.substring(0,c):
"")+"?"+w}return s};s.U=!1;s.O=!1;s.Ia=function(b){s.marketingCloudVisitorID=b;s.O=!0;s.k()};s.R=!1;s.L=!1;s.Ca=function(b){s.analyticsVisitorID=b;s.L=!0;s.k()};s.T=!1;s.N=!1;s.Ea=function(b){s.audienceManagerLocationHint=b;s.N=!0;s.k()};s.S=!1;s.M=!1;s.Da=function(b){s.audienceManagerBlob=b;s.M=!0;s.k()};s.isReadyToTrack=function(){var b=!0,a=s.visitor;if(a&&a.isAllowed()){if(!s.U&&!s.marketingCloudVisitorID&&a.getMarketingCloudVisitorID&&(s.U=!0,s.marketingCloudVisitorID=a.getMarketingCloudVisitorID([s,
s.Ia]),s.marketingCloudVisitorID))s.O=!0;if(!s.R&&!s.analyticsVisitorID&&a.getAnalyticsVisitorID&&(s.R=!0,s.analyticsVisitorID=a.getAnalyticsVisitorID([s,s.Ca]),s.analyticsVisitorID))s.L=!0;if(!s.T&&!s.audienceManagerLocationHint&&a.getAudienceManagerLocationHint&&(s.T=!0,s.audienceManagerLocationHint=a.getAudienceManagerLocationHint([s,s.Ea]),s.audienceManagerLocationHint))s.N=!0;if(!s.S&&!s.audienceManagerBlob&&a.getAudienceManagerBlob&&(s.S=!0,s.audienceManagerBlob=a.getAudienceManagerBlob([s,
s.Da]),s.audienceManagerBlob))s.M=!0;if(s.U&&!s.O&&!s.marketingCloudVisitorID||s.R&&!s.L&&!s.analyticsVisitorID||s.T&&!s.N&&!s.audienceManagerLocationHint||s.S&&!s.M&&!s.audienceManagerBlob)b=!1}return b};s.j=k;s.l=0;s.callbackWhenReadyToTrack=function(b,a,c){var e;e={};e.Oa=b;e.Na=a;e.La=c;if(s.j==k)s.j=[];s.j.push(e);if(s.l==0)s.l=setInterval(s.k,100)};s.k=function(){var b;if(s.isReadyToTrack()){if(s.l)clearInterval(s.l),s.l=0;if(s.j!=k)for(;s.j.length>0;)b=s.j.shift(),b.Na.apply(b.Oa,b.La)}};s.Ga=
function(b){var a,c,e=k,d=k;if(!s.isReadyToTrack()){a=[];if(b!=k)for(c in e={},b)e[c]=b[c];d={};s.Aa(d,!0);a.push(e);a.push(d);s.callbackWhenReadyToTrack(s,s.track,a);return!0}return!1};s.Wa=function(){var b=s.cookieRead("s_fid"),a="",c="",e;e=8;var d=4;if(!b||b.indexOf("-")<0){for(b=0;b<16;b++)e=Math.floor(Math.random()*e),a+="0123456789ABCDEF".substring(e,e+1),e=Math.floor(Math.random()*d),c+="0123456789ABCDEF".substring(e,e+1),e=d=16;b=a+"-"+c}s.cookieWrite("s_fid",b,1)||(b=0);return b};s.t=s.track=
function(b,a){var c,e=new Date,d="s"+Math.floor(e.getTime()/108E5)%10+Math.floor(Math.random()*1E13),f=e.getYear();f="t="+s.escape(e.getDate()+"/"+e.getMonth()+"/"+(f<1900?f+1900:f)+" "+e.getHours()+":"+e.getMinutes()+":"+e.getSeconds()+" "+e.getDay()+" "+e.getTimezoneOffset());if(s.visitor){if(s.visitor.getAuthState)s.authState=s.visitor.getAuthState();if(!s.supplementalDataID&&s.visitor.getSupplementalDataID)s.supplementalDataID=s.visitor.getSupplementalDataID("AppMeasurement:"+s._in,s.expectSupplementalData?
!1:!0)}s.q("_s");if(!s.B("track",arguments)){if(!s.Ga(b)){a&&s.K(a);b&&(c={},s.Aa(c,0),s.K(b));if(s.bb()){if(!s.analyticsVisitorID&&!s.marketingCloudVisitorID)s.fid=s.Wa();s.hb();s.usePlugins&&s.doPlugins&&s.doPlugins(s);if(s.account){if(!s.abort){if(s.trackOffline&&!s.timestamp)s.timestamp=Math.floor(e.getTime()/1E3);e=w.location;if(!s.pageURL)s.pageURL=e.href?e.href:e;if(!s.referrer&&!s.Ba)s.referrer=m.document.referrer,s.Ba=1;s.referrer=s.Ua(s.referrer);s.q("_g")}if(s.Ya()&&!s.abort)s.Za(),f+=
s.Xa(),s.gb(d,f),s.q("_t"),s.referrer=""}}b&&s.K(c,1)}s.abort=s.supplementalDataID=s.timestamp=s.pageURLRest=s.linkObject=s.clickObject=s.linkURL=s.linkName=s.linkType=w.vb=s.pe=s.pev1=s.pev2=s.pev3=s.g=0}};s.tl=s.trackLink=function(b,a,c,e,d){s.linkObject=b;s.linkType=a;s.linkName=c;if(d)s.i=b,s.p=d;return s.track(e)};s.trackLight=function(b,a,c,e){s.lightProfileID=b;s.lightStoreForSeconds=a;s.lightIncrementBy=c;return s.track(e)};s.clearVars=function(){var b,a;for(b=0;b<s.c.length;b++)if(a=s.c[b],
a.substring(0,4)=="prop"||a.substring(0,4)=="eVar"||a.substring(0,4)=="hier"||a.substring(0,4)=="list"||a=="channel"||a=="events"||a=="eventList"||a=="products"||a=="productList"||a=="purchaseID"||a=="transactionID"||a=="state"||a=="zip"||a=="campaign")s[a]=void 0};s.tagContainerMarker="";s.gb=function(b,a){var c,e=s.trackingServer;c="";var d=s.dc,f="sc.",w=s.visitorNamespace;if(e){if(s.trackingServerSecure&&s.ssl)e=s.trackingServerSecure}else{if(!w)w=s.account,e=w.indexOf(","),e>=0&&(w=w.substring(0,
e)),w=w.replace(/[^A-Za-z0-9]/g,"");c||(c="2o7.net");d=d?(""+d).toLowerCase():"d1";c=="2o7.net"&&(d=="d1"?d="112":d=="d2"&&(d="122"),f="");e=w+"."+d+"."+f+c}c=s.ssl?"https://":"http://";d=s.AudienceManagement&&s.AudienceManagement.isReady();c+=e+"/b/ss/"+s.account+"/"+(s.mobile?"5.":"")+(d?"10":"1")+"/JS-"+s.version+(s.mb?"T":"")+(s.tagContainerMarker?"-"+s.tagContainerMarker:"")+"/"+b+"?AQB=1&ndh=1&pf=1&"+(d?"callback=s_c_il["+s._in+"].AudienceManagement.passData&":"")+a+"&AQE=1";s.Sa(c);s.Y()};
s.Sa=function(b){s.e||s.$a();s.e.push(b);s.aa=s.r();s.za()};s.$a=function(){s.e=s.cb();if(!s.e)s.e=[]};s.cb=function(){var b,a;if(s.fa()){try{(a=w.localStorage.getItem(s.da()))&&(b=w.JSON.parse(a))}catch(c){}return b}};s.fa=function(){var b=!0;if(!s.trackOffline||!s.offlineFilename||!w.localStorage||!w.JSON)b=!1;return b};s.pa=function(){var b=0;if(s.e)b=s.e.length;s.v&&b++;return b};s.Y=function(){if(!s.v)if(s.qa=k,s.ea)s.aa>s.G&&s.xa(s.e),s.ha(500);else{var b=s.Ma();if(b>0)s.ha(b);else if(b=s.na())s.v=
1,s.fb(b),s.jb(b)}};s.ha=function(b){if(!s.qa)b||(b=0),s.qa=setTimeout(s.Y,b)};s.Ma=function(){var b;if(!s.trackOffline||s.offlineThrottleDelay<=0)return 0;b=s.r()-s.wa;if(s.offlineThrottleDelay<b)return 0;return s.offlineThrottleDelay-b};s.na=function(){if(s.e.length>0)return s.e.shift()};s.fb=function(b){if(s.debugTracking){var a="AppMeasurement Debug: "+b;b=b.split("&");var c;for(c=0;c<b.length;c++)a+="\n\t"+s.unescape(b[c]);s.eb(a)}};s.Ha=function(){return s.marketingCloudVisitorID||s.analyticsVisitorID};
s.Q=!1;var n;try{n=JSON.parse('{"x":"y"}')}catch(r){n=null}n&&n.x=="y"?(s.Q=!0,s.P=function(s){return JSON.parse(s)}):w.$&&w.$.parseJSON?(s.P=function(s){return w.$.parseJSON(s)},s.Q=!0):s.P=function(){return null};s.jb=function(b){var a,c,e;if(s.Ha()&&b.length>2047&&(typeof XMLHttpRequest!="undefined"&&(a=new XMLHttpRequest,"withCredentials"in a?c=1:a=0),!a&&typeof XDomainRequest!="undefined"&&(a=new XDomainRequest,c=2),a&&s.AudienceManagement&&s.AudienceManagement.isReady()))s.Q?a.ja=!0:a=0;!a&&
s.ab&&(b=b.substring(0,2047));if(!a&&s.d.createElement&&s.AudienceManagement&&s.AudienceManagement.isReady()&&(a=s.d.createElement("SCRIPT"))&&"async"in a)(e=(e=s.d.getElementsByTagName("HEAD"))&&e[0]?e[0]:s.d.body)?(a.type="text/javascript",a.setAttribute("async","async"),c=3):a=0;if(!a)a=new Image,a.alt="";a.la=function(){try{if(s.ga)clearTimeout(s.ga),s.ga=0;if(a.timeout)clearTimeout(a.timeout),a.timeout=0}catch(b){}};a.onload=a.lb=function(){a.la();s.Ra();s.V();s.v=0;s.Y();if(a.ja){a.ja=!1;try{var b=
s.P(a.responseText);AudienceManagement.passData(b)}catch(c){}}};a.onabort=a.onerror=a.Ta=function(){a.la();(s.trackOffline||s.ea)&&s.v&&s.e.unshift(s.Qa);s.v=0;s.aa>s.G&&s.xa(s.e);s.V();s.ha(500)};a.onreadystatechange=function(){a.readyState==4&&(a.status==200?a.lb():a.Ta())};s.wa=s.r();if(c==1||c==2){var d=b.indexOf("?");e=b.substring(0,d);d=b.substring(d+1);d=d.replace(/&callback=[a-zA-Z0-9_.\[\]]+/,"");c==1?(a.open("POST",e,!0),a.send(d)):c==2&&(a.open("POST",e),a.send(d))}else if(a.src=b,c==3){if(s.ua)try{e.removeChild(s.ua)}catch(f){}e.firstChild?
e.insertBefore(a,e.firstChild):e.appendChild(a);s.ua=s.Pa}if(a.abort)s.ga=setTimeout(a.abort,5E3);s.Qa=b;s.Pa=w["s_i_"+s.replace(s.account,",","_")]=a;if(s.useForcedLinkTracking&&s.A||s.p){if(!s.forcedLinkTrackingTimeout)s.forcedLinkTrackingTimeout=250;s.W=setTimeout(s.V,s.forcedLinkTrackingTimeout)}};s.Ra=function(){if(s.fa()&&!(s.va>s.G))try{w.localStorage.removeItem(s.da()),s.va=s.r()}catch(b){}};s.xa=function(b){if(s.fa()){s.za();try{w.localStorage.setItem(s.da(),w.JSON.stringify(b)),s.G=s.r()}catch(a){}}};
s.za=function(){if(s.trackOffline){if(!s.offlineLimit||s.offlineLimit<=0)s.offlineLimit=10;for(;s.e.length>s.offlineLimit;)s.na()}};s.forceOffline=function(){s.ea=!0};s.forceOnline=function(){s.ea=!1};s.da=function(){return s.offlineFilename+"-"+s.visitorNamespace+s.account};s.r=function(){return(new Date).getTime()};s.ra=function(s){s=s.toLowerCase();if(s.indexOf("#")!=0&&s.indexOf("about:")!=0&&s.indexOf("opera:")!=0&&s.indexOf("javascript:")!=0)return!0;return!1};s.setTagContainer=function(b){var a,
c,e;s.mb=b;for(a=0;a<s._il.length;a++)if((c=s._il[a])&&c._c=="s_l"&&c.tagContainerName==b){s.K(c);if(c.lmq)for(a=0;a<c.lmq.length;a++)e=c.lmq[a],s.loadModule(e.n);if(c.ml)for(e in c.ml)if(s[e])for(a in b=s[e],e=c.ml[e],e)if(!Object.prototype[a]&&(typeof e[a]!="function"||(""+e[a]).indexOf("s_c_il")<0))b[a]=e[a];if(c.mmq)for(a=0;a<c.mmq.length;a++)e=c.mmq[a],s[e.m]&&(b=s[e.m],b[e.f]&&typeof b[e.f]=="function"&&(e.a?b[e.f].apply(b,e.a):b[e.f].apply(b)));if(c.tq)for(a=0;a<c.tq.length;a++)s.track(c.tq[a]);
c.s=s;break}};s.Util={urlEncode:s.escape,urlDecode:s.unescape,cookieRead:s.cookieRead,cookieWrite:s.cookieWrite,getQueryParam:function(b,a,c){var e;a||(a=s.pageURL?s.pageURL:w.location);c||(c="&");if(b&&a&&(a=""+a,e=a.indexOf("?"),e>=0&&(a=c+a.substring(e+1)+c,e=a.indexOf(c+b+"="),e>=0&&(a=a.substring(e+c.length+b.length+1),e=a.indexOf(c),e>=0&&(a=a.substring(0,e)),a.length>0))))return s.unescape(a);return""}};s.z=["supplementalDataID","timestamp","dynamicVariablePrefix","visitorID","marketingCloudVisitorID",
"analyticsVisitorID","audienceManagerLocationHint","authState","fid","vmk","visitorMigrationKey","visitorMigrationServer","visitorMigrationServerSecure","charSet","visitorNamespace","cookieDomainPeriods","fpCookieDomainPeriods","cookieLifetime","pageName","pageURL","referrer","contextData","currencyCode","lightProfileID","lightStoreForSeconds","lightIncrementBy","retrieveLightProfiles","deleteLightProfiles","retrieveLightData","pe","pev1","pev2","pev3","pageURLRest"];s.c=s.z.concat(["purchaseID",
"variableProvider","channel","server","pageType","transactionID","campaign","state","zip","events","events2","products","audienceManagerBlob","tnt"]);s.ba=["timestamp","charSet","visitorNamespace","cookieDomainPeriods","cookieLifetime","contextData","lightProfileID","lightStoreForSeconds","lightIncrementBy"];s.H=s.ba.slice(0);s.ia=["account","allAccounts","debugTracking","visitor","trackOffline","offlineLimit","offlineThrottleDelay","offlineFilename","usePlugins","doPlugins","configURL","visitorSampling",
"visitorSamplingGroup","linkObject","clickObject","linkURL","linkName","linkType","trackDownloadLinks","trackExternalLinks","trackClickMap","trackInlineStats","linkLeaveQueryString","linkTrackVars","linkTrackEvents","linkDownloadFileTypes","linkExternalFilters","linkInternalFilters","useForcedLinkTracking","forcedLinkTrackingTimeout","trackingServer","trackingServerSecure","ssl","abort","mobile","dc","lightTrackVars","maxDelay","expectSupplementalData","AudienceManagement"];for(i=0;i<=250;i++)i<76&&
(s.c.push("prop"+i),s.H.push("prop"+i)),s.c.push("eVar"+i),s.H.push("eVar"+i),i<6&&s.c.push("hier"+i),i<4&&s.c.push("list"+i);i=["latitude","longitude","resolution","colorDepth","javascriptVersion","javaEnabled","cookiesEnabled","browserWidth","browserHeight","connectionType","homepage"];s.c=s.c.concat(i);s.z=s.z.concat(i);s.ssl=w.location.protocol.toLowerCase().indexOf("https")>=0;s.charSet="UTF-8";s.contextData={};s.offlineThrottleDelay=0;s.offlineFilename="AppMeasurement.offline";s.wa=0;s.aa=0;
s.G=0;s.va=0;s.linkDownloadFileTypes="exe,zip,wav,mp3,mov,mpg,avi,wmv,pdf,doc,docx,xls,xlsx,ppt,pptx";s.w=w;s.d=w.document;try{s.ab=navigator.appName=="Microsoft Internet Explorer"}catch(t){}s.V=function(){if(s.W)w.clearTimeout(s.W),s.W=k;s.i&&s.A&&s.i.dispatchEvent(s.A);if(s.p)if(typeof s.p=="function")s.p();else if(s.i&&s.i.href)s.d.location=s.i.href;s.i=s.A=s.p=0};s.ya=function(){s.b=s.d.body;if(s.b)if(s.o=function(b){var a,c,e,d,f;if(!(s.d&&s.d.getElementById("cppXYctnr")||b&&b["s_fe_"+s._in])){if(s.ka)if(s.useForcedLinkTracking)s.b.removeEventListener("click",
s.o,!1);else{s.b.removeEventListener("click",s.o,!0);s.ka=s.useForcedLinkTracking=0;return}else s.useForcedLinkTracking=0;s.clickObject=b.srcElement?b.srcElement:b.target;try{if(s.clickObject&&(!s.F||s.F!=s.clickObject)&&(s.clickObject.tagName||s.clickObject.parentElement||s.clickObject.parentNode)){var g=s.F=s.clickObject;if(s.Z)clearTimeout(s.Z),s.Z=0;s.Z=setTimeout(function(){if(s.F==g)s.F=0},1E4);e=s.pa();s.track();if(e<s.pa()&&s.useForcedLinkTracking&&b.target){for(d=b.target;d&&d!=s.b&&d.tagName.toUpperCase()!=
"A"&&d.tagName.toUpperCase()!="AREA";)d=d.parentNode;if(d&&(f=d.href,s.ra(f)||(f=0),c=d.target,b.target.dispatchEvent&&f&&(!c||c=="_self"||c=="_top"||c=="_parent"||w.name&&c==w.name))){try{a=s.d.createEvent("MouseEvents")}catch(i){a=new w.MouseEvent}if(a){try{a.initMouseEvent("click",b.bubbles,b.cancelable,b.view,b.detail,b.screenX,b.screenY,b.clientX,b.clientY,b.ctrlKey,b.altKey,b.shiftKey,b.metaKey,b.button,b.relatedTarget)}catch(k){a=0}if(a)a["s_fe_"+s._in]=a.s_fe=1,b.stopPropagation(),b.kb&&b.kb(),
b.preventDefault(),s.i=b.target,s.A=a}}}}else s.clickObject=0}catch(m){s.clickObject=0}}},s.b&&s.b.attachEvent)s.b.attachEvent("onclick",s.o);else{if(s.b&&s.b.addEventListener){if(navigator&&(navigator.userAgent.indexOf("WebKit")>=0&&s.d.createEvent||navigator.userAgent.indexOf("Firefox/2")>=0&&w.MouseEvent))s.ka=1,s.useForcedLinkTracking=1,s.b.addEventListener("click",s.o,!0);s.b.addEventListener("click",s.o,!1)}}else setTimeout(s.ya,30)};s.ya()}
function s_gi(s){var w,k=window.s_c_il,m,i,o=s.split(","),p,n,r=0;if(k)for(m=0;!r&&m<k.length;){w=k[m];if(w._c=="s_c"&&(w.account||w.oun))if(w.account&&w.account==s)r=1;else{i=w.account?w.account:w.oun;i=w.allAccounts?w.allAccounts:i.split(",");for(p=0;p<o.length;p++)for(n=0;n<i.length;n++)o[p]==i[n]&&(r=1)}m++}r||(w=new AppMeasurement);w.setAccount?w.setAccount(s):w.sa&&w.sa(s);return w}AppMeasurement.getInstance=s_gi;window.s_objectID||(window.s_objectID=0);
function s_pgicq(){var s=window,w=s.s_giq,k,m,i;if(w)for(k=0;k<w.length;k++)m=w[k],i=s_gi(m.oun),i.setAccount(m.un),i.setTagContainer(m.tagContainerName);s.s_giq=0}s_pgicq();


window.AppMeasurement = AppMeasurement;




},{}],"/Users/youzi/dev/mtv-play/api/tracking/map.js":[function(require,module,exports){
/*  0 = sprop, 1 = evar */
exports.vars = {
  branch: [ 13, 13 ],
  title: [ 49, 49 ],
  version: [ 3, 3 ],
  role: [ 4, 4 ],
  device: [ 5, 5 ],
  region: [ 6, 6 ],
  lang: [ 7, 7 ],
  age: [ 19, 19 ],
  gender: [ 20, 20 ],
  weekDay: [ 8, 8 ],
  hour: [ 9, 9 ],
  native: [ 21, 21 ],
  userId: [ 10, 10 ],
  connected: [ 16, 16 ],
  network: [ 11, 11 ],
  networkOperator: [ 12, 12 ],
  secondscreen: [ 17, 17 ],
  devicesPresent: [ 18, 18 ],
  search: [ 14, 14 ],
  mtvMobileFailed: [ null, 22 ],
  loginStyle: [ 15, 15 ],
  teaserCollection: [ null, 23 ],
  teaserClicked: [ null, 24 ],
  videoName: [ null, 33 ],
  franchiseName: [ 49, 49 ],
  subscriptionFailure: [ null, 25 ]
}

/*

eVars:
eVar1: video name (example awkward > season 01 > episode 01
eVar2: franchise name (example awkward)
events (all counters):
event1: video started
event2: video reaches 25%
event3: video reaches 50%
event4: video reaches 75%
event5: video finished (at 90% because of the outro that may be skipped)
*/

exports.events = {
  appstart: 8,
  menu: 9,
  enable3g: 10,
  disable3g: 11,
  favoAdded: 12,
  favoRemoved: 13,
  sharingFacebookStart: 34,
  sharingFacebookSucces: 35,
  swipeUp: 32,
  swipeDown: 33,
  sharingEmailStart: 16,
  sharingEmailSucces: 17,
  search: 18,
  upgradeMonthFailed: 26,
  upgradeMonthSucces: 25,
  upgradeAnFailed: 28,
  upgradeAnSucces: 27,
  upgradeMtvFailed: 30,
  upgradeMtvSucces: 29,
  loginSucces: 23,
  loginFailed: 24,
  signupSucces: 21,
  signupFailed: 22,
  introSkipped: 20,
  introCompleted: 19,
  teaserClick: 31,
  videofinished: 76,
  videoPlay: 6,
  videoPause: 7,
  videostart: 15,
  video25: 2,
  video50: 3,
  video75: 4,
  purchaseFailed: 35,
  receiptFailed: 36
}

exports.weekDays = [ 'sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday' ]
  /*

  Video name: eVar1 -> eVar33
  Franchise Name: eVar2 -> eVar49
  Franchise Name: sProp2 -> sProp49

  Video Started: event1 -> event15

  fb sharing start: event14 -> event34
  fb sharing success: event15 -> event35
  video finished: event5 -> event76

  */

},{}],"/Users/youzi/dev/mtv-play/api/tracking/nuggad.js":[function(require,module,exports){
exports.initialize = function () {
  var script = document.createElement('script')
  script.onerror = function(err) {
    console.error(err)
  }

  script.src = 'https://mtv.nuggad.net/javascripts/nuggad-ls.js'
  script.type = "text/javascript"

  document.getElementsByTagName('head')[0].appendChild(script)
}

exports.sendData = function () {
  var n_pbt="";
  var nuggtg=encodeURIComponent("");
  var nuggn=187535816;
  var nuggsid=1864594024;
  var nugghost = window.nugghost = "https://mtv.nuggad.net";

  window.nuggad.init({"rptn-url": "https://mtv.nuggad.net"}, function(api) {
    api.rc({"nuggn": nuggn, "nuggsid": nuggsid, "nuggtg": nuggtg })
  });



  // var nugghost="//mtv.nuggad.net";
  // window.nuggad.init({
  //   'rptn-url': nugghost
  // }, function(api) {
  //   api.rc({
  //     'nuggn': 187535816,
  //     'nuggsid': 1864594024,
  //     'nuggtg': encodeURIComponent("")
  //   })
  // })
}

},{}],"/Users/youzi/dev/mtv-play/api/tracking/omniture.js":[function(require,module,exports){
var omni = require('./lib/AppMeasurement.js')
var map = require('./map')

module.exports = new AppMeasurement()

},{"./lib/AppMeasurement.js":"/Users/youzi/dev/mtv-play/api/tracking/lib/AppMeasurement.js","./map":"/Users/youzi/dev/mtv-play/api/tracking/map.js"}],"/Users/youzi/dev/mtv-play/api/tracking/pagename.js":[function(require,module,exports){
var omniture = require('./omniture')
var postpone = require('old-vigour-js/browser/events/util').postpone
var ua = require('old-vigour-js/browser/ua')
var config = require('old-vigour-js/util/config')
var url = require('old-vigour-js/browser/network/url')
var util = require('old-vigour-js/util')
var map = require('./map')
var config = require('old-vigour-js/util/config')
var context = require('./context')
var apiTrack

module.exports = function pagename(current) {

  if (typeof current !== 'string') current = ''

  var user = omniture.user
  var cloud = user.cloud

  var arr = current.split('.')
    // var platform = ua.device === 'desktop' ? 'web' : ua.platform
  var pageName = ''
  var title
  var titlefallback
  var match
  var piv

  if (arr.length > 1) {
    titlefallback = arr[4]

    if (~current.indexOf('shows')) {
      title = cloud.data.get(current)
        .checkParent('_parent._name', 'shows')
        .get('title', '')
        .val

      arr[4] = title
      if (arr[6]){
        arr[6]++
      }
      if (arr[8]){
        arr[8]++
      }
    } else {
      title = cloud.data.get(current + '.title', '').val
      arr[4] = title
    }
    if (!arr[4]) {
      match = url.val && url.val.match(/\-(.*?)$/)
      if (match && match[1]) {
        piv = match[1].indexOf('/')
        title = arr[4] = piv !== -1 ? match[1].slice(0, piv) : match[1]
      } else {
        arr[4] = titlefallback
      }
    }

    if (~current.indexOf('.channels.')) {
      pageName += 'tv > ' + arr.slice(4).join(' > ')
    } else {
      pageName += (arr.slice(3).join(' > '))
    }
  } else {
    pageName += current
  }

  return {
    current: current,
    name: pageName,
    title: title
  }
}

},{"./context":"/Users/youzi/dev/mtv-play/api/tracking/context.js","./map":"/Users/youzi/dev/mtv-play/api/tracking/map.js","./omniture":"/Users/youzi/dev/mtv-play/api/tracking/omniture.js","old-vigour-js/browser/events/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js","old-vigour-js/browser/network/url":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/url.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/api/url.js":[function(require,module,exports){
var Value = require('old-vigour-js/value')
var cases = require('old-vigour-js/browser/cases')

module.exports = exports = new Value({
  apiDefer: function (update, args) {
    this.clearCache()
    console.log('???')
    if (typeof this.val !== 'string') {
      update(true)
    } else {
      if (cases.native) {
        if (navigator.app && navigator.app.loadUrl) {
          navigator.app.loadUrl(this.val, {
            openExternal: true
          })
          update('success')
        } else if (cases.windowsMobile) {
          window.open(this.val, '_system') // returns an InAppBrowser (see https://git-wip-us.apache.org/repos/asf?p=cordova-plugin-inappbrowser.git;a=blob_plain;f=www/inappbrowser.js;hb=HEAD)
          update('success')
        } else if (cases.ios) {
          window.open(this.val, '_system')
          update('success')
        } else {
          this.type = 'can not find navigator.app.loadUrl'
          update('error')
        }
      } else {
        console.log(this.val)
        var ref = window.open(this.val, this.val)
        if (ref) {
          ref.focus()
          update('success')
        } else {
          update('error')
        }
      }
    }
  }
})

exports._name = '_urlApi'

},{"old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/user.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value') // all process flags
var url = config.api.url

module.exports = exports = new Value({
  newsletter: {
    ajax: {
      url: function (ajax, val) {
        if (this._parent.token && this._parent.token.val) {
          return url + 'api/v1/users/' + this._parent.token.val + '.json'
        }
      },
      method: 'PUT',
      encode: 'json',
      data: function (ajax, val) {
        this.clearCache()
        return (this.val === true || this.val === false) && {
          user: {
            accept_newsletter: this.val,
            app_version: window.package.version
          }
        }
      }
    }
  },
  role: {
    poll: false,
    ajax: {
      url: function (ajax, val) {
        return (this._parent.token && this._parent.token.val) && url + 'api/v1/users/' + this._parent.token.val + '.json'
      },
      defer: function (update, args, err, data) {
        if (data.user) {
          this.val = args[0] = data.user.role
          // poll
          update()
        } else {
          update(true)
        }
      }
    }
  }
})

exports.role.poll.on(function (val) {
  if (val === true) val = 1e3
  if (val > 0) {
    if (this._d) clearInterval(this._id)
    this._id = setInterval(function () {
      exports.role._update()
    }, val)
  } else {
    clearInterval(this._id)
    this._d = null
  }
})

exports._name = 'userApi'

},{"old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/api/util.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var errors = {
  emailExists: 'Email has already been taken',
  invalid: 'Username or password is invalid',
  expired: 'Your confirmation link expired. Please sign up again using the app.',
  mobileTimeout: 'Timeout error',
  terms: 'MTV country terms and conditions must be accepted',
  email: 'Email can\'t be blank',
  password: 'Password can\'t be blank',
  privacy: 'Data protection terms and conditions must be accepted',
  numberExists: 'Mobile number has already been taken',
  subscription: 'Subscription is not verified',
  resetTokenExpired: 'Outdated password reset token.',
  invalidPasswordToken: 'Invalid password reset token.',
  invalidEmail: 'Email is invalid'
}

//[ exists, invalid ]
exports.findError = function (data) {
  if (!data) return
  var errs = data && data.errors

  if (data.error_message) {
    for (var key in errors) {
      if (data.error_message === errors[key]) return key
    }
  }

  if (errs instanceof Array) {
    for (var i = errs.length, err; err = errs[--i];) {
      for (var key in errors) {
        if (err.description === errors[key]) return key
      }
    }
  }
  return 'invalid'
}

},{"old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/api/verify.js":[function(require,module,exports){
var config = require('old-vigour-js/util/config')
var Value = require('old-vigour-js/value') // all process flags
var util = require('./util')
var cases = require('old-vigour-js/browser/cases')
var url = config.api.url

module.exports = exports = new Value({
  email: {
    ajax: {
      url: function (ajax, val) {
        return typeof val === 'string' && url + 'api/v2/confirmations/' + val + '.json'
      },
      method: 'GET',
      defer: function (update, args, err, data) {
        if (!data.success) {
          this.type = err ? err.message : util.findError(data)
          update('error')
        } else {
          this.set('token', data.authentication_token)
          update('success')
        }
      }
    }
  }
})

exports._name = 'verify'

},{"./util":"/Users/youzi/dev/mtv-play/api/util.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/app/config.js":[function(require,module,exports){
module.exports = exports = require('old-vigour-js/util/config')

var util = require('old-vigour-js/util')

var ua = require('old-vigour-js/browser/ua')
var cases = require('old-vigour-js/browser/cases')
var Value = require('old-vigour-js/value')

exports.language = new Value()
exports.region = new Value()

if ( exports.dictionary === 'webtranslateit') {
  exports.dictionary = function ( val ) {
    return 'https://webtranslateit.com/api/projects/' + exports.webtranslateit.token + '/files/' + exports.webtranslateit.files[ val ] + '/locales/' + val
  }
} else {
  var dict = exports.dictionary
  exports.dictionary = function ( val ) {
    return dict.replace('$language', val)
  }
}

var protocol, port

if (exports.cloud === 'production') // this used to have === 'demo' as well
{
  protocol = cases.tv ? 'http://' : 'https://'
  port = protocol === 'https://' ? 443 : 80

  if (exports.cloud === 'production') {
    exports.cloud = new Value({
      val: exports.region,
      transform: function (c, cv) {
        if (cv === 'PL') {
          cv = 'po'
        }
        return cv ? protocol + cv.toLowerCase() + '-hubs.mtvplay.tv:' + port : false
      }
    })
  } else {
    // this else will never happen?
    var regionOverride = exports.regionOverride
    if (regionOverride === 'url') {
      var regions = [ 'CH', 'BE', 'DE', 'NO', 'NL', 'PL', 'RO' ]
      var href = window.location.href
      var regionat = href.indexOf('r=')
      regionOverride = href.slice(regionat + 2, regionat + 4)
      if (regions.indexOf(regionOverride) === -1) {
        regionOverride = 'DE'
      }
      exports.regionOverride = regionOverride
    }
    exports.cloud = protocol + (exports.regionOverride || 'nl').toLowerCase() + '-hubs.mtvplay.tv:' + port
  }
}

if (!cases.native) {
  exports.hashUrl = false
}

},{"old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/app/index.js":[function(require,module,exports){
var app = module.exports = require('old-vigour-js/app')
  .inject(
    require('old-vigour-js/app/content'),
    require('old-vigour-js/app/user')
  )
var config = app.config = require('./config')
var Value = require('old-vigour-js/value')
var Obj = require('old-vigour-js/object')
var cases = app.cases
var user = require('./user')
var util = require('old-vigour-js/util')
var api

/* ------------ setup , cases and values ------------ */

app.cloud = {
  api: {
    auth: config.api.url + 'api/v1/users/'
  },
  url: config.cloud
}

app.state.val = {
  default: 'first'
}

app.frame = require('old-vigour-js/browser/animation/frame')
app.ua = require('old-vigour-js/browser/ua')
app.util = require('./util')

app.versionData.on(function () {
  app.notification.val = 'appUpgrade'
})

app.telCode = new Value({
  default: {
    val: app.region,
    transform: function (v, cv) {
      return cv && cv.toLowerCase()
    }
  }
})

// TODO: put this in a module
var referrer = document.referrer

if (referrer) {
  var arr = [
    'mtv.de',
    'at.mtv.de',
    'mtv.ch',
    'mtv.nl',
    'mtv.be',
    'fr.mtv.be',
    'nl.mtv.be',
    'mtv.dk',
    'mtv.no',
    'mtv.se',
    'musictelevision.fi',
    'mtv.pl'
  ]
  for (var i = arr.length - 1; i >= 0; i--) {
    var url = arr[i]
    if (referrer.indexOf(url) !== -1) {
      app.fromMtvSite = referrer
      break
    }
  }
}

app.cloud.subscribe({
  mtvData: {
    operators: {
      $: {
        $: true
      }
    }
  }
})

cases.$allowPlayback = new Value({
  val: true,
  transform: function (v, cv) {
    return cases.native ? true : cv
  }
})

if(!cases.native){
  cases.$allowPlayback.on(function () {
    if (!this.val) {
      app.popup.val = 'comingSoon'
    }
  })
}

cases.$hasOperator = new Value(false)
app.operators = new Obj({})

app.region.on(function () {
  var region = app.region.val
  if (typeof region === 'string') {
    var country = app.country || app.region.val
    if (!country || !~config.availableRegions.indexOf(country.toUpperCase())) {
      cases.$allowPlayback.val = false
    } else {
      cases.$allowPlayback.val = true
    }

    var operators = app.cloud.data.get(['mtvData', 'operators'])
    var fn = function () {
      var hasOperator = false
      if (this.$length.val) {
        this.each(function (key) {
          if (this.region.val.toLowerCase() === region.toLowerCase()) {
            hasOperator = true
            app.operators.set(key, this)
          }
        })
      }
      cases.$hasOperator.val = hasOperator
    }
    if (operators.$length.val) {
      fn.call(operators)
    } else {
      operators.once(fn)
    }
  }
})

cases.$fromMtvSite = new Value(!!app.fromMtvSite)

cases.$storeAvailable = new Value(
  cases.native && (cases.ios || cases.android || cases.windowsMobile) // && window.Store
)

// TODO: replace /w $$hasMobile
cases.$hasMobile = new Value({
  val: function () {
    return util.checkArray(
      config.mtvmobile, app.region.val.toLowerCase()
    ) !== false ? true : false
  },
  listen: app.region
})

/* ------------ intro ------------ */
require('./intro')

/* ------------ localisation ------------ */
require('./localisation')

/* ------------  api ------------  */
api = app.api = require('../api')

/* ------------  newsletter ------------  */
api.user.val = {
  token: user.token,
  newsletter: user.accept_newsletter
}

/* ------------  single purchase ------------  */
cases.$hasEpisodePass = new Value({
  val: api.info.episode_pass_available
})

api.info.val = app.region

/* ------------  login ------------  */
require('./login')

/* ------------  share ------------  */
require('./share')

/* ------------  register ------------  */
require('./register')

/* ------------  upgrade ------------  */
require('./upgrade')

/* ------------  playback ------------  */
require('./playback')

/* ------------  popup ------------  */
require('./popup')

/* ------------ TRACK ------------ */
require('./tracking')

/* ------------ app init ------------ */
require('./init')

},{"../api":"/Users/youzi/dev/mtv-play/api/index.js","./config":"/Users/youzi/dev/mtv-play/app/config.js","./init":"/Users/youzi/dev/mtv-play/app/init.js","./intro":"/Users/youzi/dev/mtv-play/app/intro.js","./localisation":"/Users/youzi/dev/mtv-play/app/localisation.js","./login":"/Users/youzi/dev/mtv-play/app/login.js","./playback":"/Users/youzi/dev/mtv-play/app/playback.js","./popup":"/Users/youzi/dev/mtv-play/app/popup.js","./register":"/Users/youzi/dev/mtv-play/app/register.js","./share":"/Users/youzi/dev/mtv-play/app/share.js","./tracking":"/Users/youzi/dev/mtv-play/app/tracking.js","./upgrade":"/Users/youzi/dev/mtv-play/app/upgrade.js","./user":"/Users/youzi/dev/mtv-play/app/user.js","./util":"/Users/youzi/dev/mtv-play/app/util.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/content":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/content.js","old-vigour-js/app/user":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/index.js","old-vigour-js/browser/animation/frame":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/frame.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/app/init.js":[function(require,module,exports){
var app = require('old-vigour-js/app')
var user = app.user
var cases = app.cases
var Promise = require('promise')
var config = require('./config')
var PasswordInput = require('../components/password')

app.css = {
  addClass: 'preload'
}

if ((cases.chromecast || cases.tv) && !user.token.val) {
  user.token = true
}

app.region
  .is(function () {
    return typeof this.val === 'string'
  })
  .then(function () {
    var passwordProtected = config.protected && ~config.protected.indexOf(app.region.val.toLowerCase())

    return !passwordProtected || new Promise(function(resolve) {
      window.requestAnimationFrame(function() {
        if (window.clearPackerLoader) {
          window.clearPackerLoader()
        }

        var pw = new PasswordInput({
          container: {
            field: {
              events: {
                change: function(e) {
                  if (this.node.value === 'viacomnorth') {
                    this.remove()
                    resolve()
                  } else {
                    window.alert('Incorrect password. Please try again.')
                  }
                }
              }
            }
          }
        })

        window.requestAnimationFrame(function () {
          pw.container.opacity = 1
        })
        app.set({
          passwordInput: pw
        })
      })
    })
  })
  .then(function () {
    return app.cloud.connected.is(true)
  })
  .then(function () {
    if (user.token.val === true) {
      //TODO: replace this with hashedSubscription true
      return new Promise(function (resolve) {
        var loaded = user.data.is('loaded')
        var timeout = setTimeout(function() {
          Promise.reject(loaded)
          resolve()
        }, 500)
        loaded.done(function() {
          clearTimeout(timeout)
          resolve()
        })
      })
    } else if (user.token.val) {
      return user.data.is('loaded')
    }
  })
  .then(function () {
    app.ready.val = true
    if (!cases.chromecast) user.$execUrl('discover')
    app.css = {
      removeClass: 'preload'
    }
    if (window.clearPackerLoader) window.clearPackerLoader()
    if (cases.touch) app.node.style.backgroundColor = 'black'
    return app.content.is('loaded')
  })
  .done(function () {
    app.css = {
      removeClass: 'preload'
    }
    if (window.clearPackerLoader) window.clearPackerLoader()
    if (cases.touch) app.node.style.backgroundColor = 'black'
  })

},{"../components/password":"/Users/youzi/dev/mtv-play/components/password/index.js","./config":"/Users/youzi/dev/mtv-play/app/config.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","promise":"/Users/youzi/dev/mtv-play/node_modules/promise/index.js"}],"/Users/youzi/dev/mtv-play/app/intro.js":[function(require,module,exports){
var app = module.exports = require( 'old-vigour-js/app' )
var cases = app.cases

/* ------------ intro ------------ */

if( cases.native && !localStorage.getItem( 'haveSeenIntro' ) ) {
  app.ready.on( true, function() {
    setTimeout( function() {
      app.popup.val = 'intro'
    }, 1000 )
    localStorage.setItem( 'haveSeenIntro', true )
  } )
}

},{"old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js"}],"/Users/youzi/dev/mtv-play/app/localisation.js":[function(require,module,exports){
var app = require('old-vigour-js/app')
var config = app.config = require('./config')
var dictionary = require('old-vigour-js/app/dictionary')
var util = require('old-vigour-js/util')
var ua = require('old-vigour-js/browser/ua')
var Value = require('old-vigour-js/value')

app.dictionary = dictionary

// TODO: handle false in ajax
var regionOverride = config.regionOverride
if (regionOverride) {
  if (regionOverride === 'url') {
    var regions = config.availableRegions
    var href = window.location.href
    var regionat = href.indexOf('r=')
    regionOverride = href.slice(regionat + 2, regionat + 4)
    if (regions.indexOf(regionOverride) === -1) {
      regionOverride = 'DE'
    }
    config.regionOverride = regionOverride
  }
  app.region.val = {
    ajax: config.geo,
    transform: function (c, cv) {
      return config.regionOverride || 0
    }
  }
} else {
  app.region.val = {
    responseData: function (c, cv) {
      var country = this.country_code && this.country_code.val
      app.country = country
      return util.checkArray(config.availableRegions, country) !== false && country
    },
    ajax: config.geo,
    transform: function (c, cv) {
      if (!cv || typeof cv !== 'string' || cv === 'error' || util.checkArray(config.availableRegions, cv) === false) {
        return config.defaultRegion || (ua.platform === 'lg' && ua.device === 'tv' ? 'DE' : 0) || (cv && 'DE')
      }
      if (cv === 'AT') {
        cv = 'DE'
      }
      return cv
    }
  }
}

config.language.val = app.language
config.region.val = app.region

/* ------------ dictionary ------------ */
// TODO:make dictionary init after ready
app.dictionary.val = {
  ajax: function (ajax, val) {
    var value = this.val
    if (value) {
      if (this._cached === value) return
      this._cached = value
      return value && config.dictionary(value)
    }
  },
  val: app.language
}

app.localDictionary = new Value({
  ajax: function (ajax, val) {
    var region = app.region.val
    var country = app.country
    if (country && region !== country) {
      region = 'en'
    }
    if (region === 'CH' || region === 'AT') {
      region = 'de'
    }
    if (region) {
      if (region === 'BE') {
        region = 'NL'
      }
      var v = region.toLowerCase()
      if (this._cached === v) return
      this._cached = v
      return config.dictionary(v)
    }
  },
  val: app.region
})

},{"./config":"/Users/youzi/dev/mtv-play/app/config.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/app/login.js":[function(require,module,exports){
var config = require('./config')
var cases = require('old-vigour-js/browser/cases')
var app = require('old-vigour-js/app/')
var user = app.user
var api = require('../api')

/* ------------ login ------------ */
api.user.role.val = {
  token: app.user.token
}

api.login.val = {
  region: config.region
}

api.user.role
  .on(function () {
    if (user.role.$userOrigin.cloud) {
      user.role.$userOrigin = api.user.role.val
    }
  })

user.token
  .on(function () {
    if (!user.token.val) {
      api.login.$empty(['loading', 'region'])
      app.state.val = 'empty'
      app.state.val = 'first'
    }
  })
  .on(function () {
    api.user.role.poll.val = user.token.val ? 6e5 : false
  })

api.login
  .on('error', function () {
    if (!api.timeout) {
      app.notification.type = this.type
      app.notification.val = 'loginError'
    }
  })
  .on('success', function () {
    app.notification.val = 'loginSuccess'

    if (this.facebook && this.facebook.token && this.facebook.token.val) {
      var facebookToken = this.facebook.token.val
      var facebookId = this.facebook.id.val

      user.token.once(function (val) {
        if (this.val) {
          user.FB_token.$userOrigin = facebookToken
          user.facebook_id.$userOrigin = facebookId
        }
      })
    }

    user.token = this.token.val
    var registerOperator = window.localStorage.getItem('registerOperator')
    if (registerOperator) {
      var check = registerOperator.toLowerCase()
      if (check === 'get') {
        registerOperator = '__$ESCAPED_' + check
      }
      app.popup.data = app.cloud.data.get(['mtvData', 'operators', registerOperator])
      app.popup.val = 'operatorAuthUpgrade'
      window.localStorage.removeItem('registerOperator')
    } else if (cases.$hasMobile.val && this.new_record) {
      app.popup.val = 'getStarted'
    } else if (app.popup.val === 'login' || app.popup.val === 'loginEmail' || app.popup.val === 'register') {
      app.popup.val = false
    }
  })
  .loading.on(function (val) {
    if (val === true && !api.timeout) {
      app.loading.val = 'login'
    } else if (app.loading.val === 'login') {
      app.loading.val = false
    }
  })

api.operator.login
  .on('error', function () {
    if (!api.timeout) {
      app.notification.type = this.type
      app.notification.val = 'loginError'
    }
  })
  .on('success', function () {
    app.notification.val = 'loginSuccess'
    user.token = this.token.val
    app.popup.val = false
  })
  .loading.on(function (val) {
    if (val === true && !api.timeout) {
      app.loading.val = 'login'
    } else if (app.loading.val === 'login') {
      app.loading.val = false
    }
  })

api.facebook.login
  .on('success', function (val) {
    api.login.val = {
      facebook: {
        token: this.token.val,
        id: this.id.val
      }
    }
  })
  .on('error', function () {
    app.notification.val = 'facebookError'
  })
  .loading.on(app.loading)

},{"../api":"/Users/youzi/dev/mtv-play/api/index.js","./config":"/Users/youzi/dev/mtv-play/app/config.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/app/playback.js":[function(require,module,exports){
var app = require('old-vigour-js/app')
var config = app.config = require('./config')
var Value = require('old-vigour-js/value')
var cases = app.cases
var user = app.user

cases.$playing = app.playing

cases.$isFullscreen = new Value({
  val: function () {
    return app.state.val === 'player'
  },
  listen: app.state
})

cases.$isPlayingAd = new Value()

cases.$isLoadingVideo = new Value({
  val: false,
  defer: function (update) {
    var _this = this
    if (this._timer) {
      clearTimeout(this._timer)
      this._timer = null
    }
    if (this._val) {
      this._timer = setTimeout(function () {
        _this.val = false
        _this._timer = null
      }, 2000)
    }
    update()
  }
})

cases.$isOnChannel = new Value()

app.wifiOnly = new Value({
  val: localStorage.getItem('wifiOnly') || false,
  defer: function (update) {
    if (this._val) localStorage.setItem('wifiOnly', true)
    else localStorage.removeItem('wifiOnly')
    update()
  }
})

app.restrictPlayback.val = {
  val: app.wifiOnly,
  transform: function (v, cv) {
    return (cv && cases.native && api.network.val !== 'wifi') ? true : false
  }
}

app.playing.on(function (val) {
  if (cases.$isLoggedIn.val) {
    if (val === true) {
      var media = app.user.navigation.media.from
      if (media._parent._name !== 'channels') {
        var epi = app.user.usage.from.get(media._contentPath)
        var show = epi._parent._parent._parent._parent

        if (show) {
          show.set('media', media)
        }
      }
    }
  }
})

app.playing.val = {
  defer: function checkAccess(update, args) {
    var media = user.navigation.media.from
    var access = media && media.access && media.access.val
    var id = media && media.id && media.id.val
    var trial = user.role.val === 3

    if (this.val && !cases.$allowPlayback.val) {
      app.notification.val = 'Oops! Playback is not allowed in your region...'
    } else if (args[0] === true && (app.wifiOnly.val && app.api.network.val)) {
      this.val = args[0] = false
      app.notification.from.val = 'enable4g' //real noticication
    } else if (!cases.$accessForEveryone.val && args[0] === true && access && this.val) {
      if (!cases.$isLoggedIn.val) {
        this.val = args[0] = false
        app.popup.from.val = 'roadblock'
      } else if (media._parent._name === 'channels' && (trial || !cases.$isUpgraded.val)) {
        this.val = args[0] = false
        app.popup.from.val = 'upgrade'
      } else if (!cases.$isUpgraded.val && !user.purchases.$userOrigin[id] // not purchased by the user
        || (media._parent._name === 'channels' && trial) || (trial && access === 2)
      ) {
        this.val = args[0] = false
        app.popup.from.data = media
        app.popup.from.val = 'roadblockMedia'
      }
    }

    update()
  }
}


if (config.player && config.player.settings.ads.viralSID === 'production') {
  var ads = config.player.settings.ads
  if (cases.tv) {
    ads.viralSID = 'mtvplaytv/smarttv/de/free'
    app.user.role.on(function () {
      var role = this.val
      var arr = ads.viralSID.split('/')
      if (!role || role === 3) {
        role = 'free'
      } else if (role === 2) {
        role = 'b2b'
      } else {
        role = 'b2c'
      }
      arr[3] = role
      ads.viralSID = arr.join('/')
    })

    app.region.on(function () {
      var region = this.val
      if (region) {
        var arr = ads.viralSID.split('/')
        arr[2] = region.toLowerCase()
        ads.viralSID = arr.join('/')
      }
    })
  } else {
    ads.viralSID = 'mtvplaytv/de/free'
    app.user.role.on(function () {
      var role = this.val
      var arr = ads.viralSID.split('/')
      if (!role || role === 3) {
        role = 'free'
      } else if (role === 2) {
        role = 'b2b'
      } else {
        role = 'b2c'
      }
      arr[2] = role
      ads.viralSID = arr.join('/')
    })

    app.region.on(function () {
      var region = this.val
      if (region) {
        var arr = ads.viralSID.split('/')
        arr[1] = region.toLowerCase()
        ads.viralSID = arr.join('/')
      }
    })
  }
}

},{"./config":"/Users/youzi/dev/mtv-play/app/config.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/app/popup.js":[function(require,module,exports){
var app = require( 'old-vigour-js/app' )
var cases = app.cases

app.popup.val = {
  defer: function( update, args ) {
    var val = args[ 0 ]
    if( cases.windows && cases.native && args[ 0 ] === 'share' ) {
      app.api.facebook.share.val = {
        val: true,
        url: true
      }
      this._val = args[ 0 ] = false
    } else if( val === 'upgrade' && !cases.$hasMobile.val && !cases.$storeAvailable.val ) {
      this._val = args[ 0 ] = 'roadblockUpgrade'
    } else if( val === 'devices' && !cases.$isLoggedIn.val ) {
      this._val = args[ 0 ] = 'roadblock'
    }
    update()
  }
}

},{"old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js"}],"/Users/youzi/dev/mtv-play/app/register.js":[function(require,module,exports){
var config = require('./config')
var app = require('old-vigour-js/app/')
var user = app.user
var api = require('../api')
var cases = require('old-vigour-js/browser/cases')

/* ------------  register ------------  */

api.register.val = {
  age: {
    defer: function (update, args) {
      var val = args[0]

      if (!val || val.defer) {
        update(true)
      } else {
        if (val == 1) {
          this.val = {
            min_age: 1,
            max_age: 20
          }
        } else if (val == 2) {
          this.val = {
            min_age: 20,
            max_age: 30
          }
        } else if (val == 3) {
          this.val = {
            min_age: 30,
            max_age: 40
          }
        }

        update()
      }

    }
  },
  region: config.region
}

api.register
  .on('error', function () {
    app.notification.type = this.type
    app.notification.val = 'registerError'
  })
  .on('success', function () {
    app.notification.val = 'registerSuccess'
    app.popup.val = false
    if (this.email && this.email.val) {
      var email = this.email.val
      var password = this.password.val
    }

    if (api.timeout) clearInterval(api.timeout)

    if (cases.native) {
      api.timeout = setInterval(function () {
        api.login.val = {
          email: email,
          password: password
        }
      }, 500)
      api.login.once('success', function () {
        clearInterval(api.timeout)
        api.timeout = false
      })
    }

  })
  .loading.on(app.loading)

api.verify.email
  .on('success', function (val) {
    var registerOperator = window.localStorage.getItem('registerOperator')
    if (registerOperator) {
      var check = registerOperator.toLowerCase()
      if (check === 'get') {
        registerOperator = '__$ESCAPED_' + check
      }
      app.popup.data = app.cloud.data.get(['mtvData', 'operators', registerOperator])
      app.popup.val = 'operatorAuthUpgrade'
      window.localStorage.removeItem('registerOperator')
    } else if (cases.phone || cases.tablet) {
      app.popup.val = 'getApp'
    }
    user.token.val = this.token.val
    app.notification.val = 'verifyEmailSuccess'
  })
  .on('error', function (val) {
    app.notification.type = this.type
    app.notification.val = 'verifyEmailError'
  })
  .loading.on(app.loading)

app.url.params
  .on(function (val) {
    if (this.e) {
      api.verify.email.val = this.e.val
      this.val = ''
    }
  })

/* ------------  forgot password ------------  */

api.password.forgot
  .on('success', function () {
    app.notification.val = 'passwordForgot'
    app.popup.val = false
  })
  .on('error', function () {
    app.notification.type = this.type
    app.notification.val = 'passwordForgotError'
  })
  .loading.on(app.loading)

api.password.reset
  .on('success', function () {
    app.notification.val = 'passwordResetSuccess'
    app.popup.val = false
    user.token.val = this.token.val
  })
  .on('error', function () {
    app.notification.type = this.type
    app.notification.val = 'passwordResetError'
  })
  .loading.on(app.loading)

app.url.params
  .on(function (val) {
    if (this.reset) {
      api.password.reset.val = {
        token: this.reset.val
      }
      app.popup.from.val = 'passwordReset'
      this.val = ''
    }
  })

},{"../api":"/Users/youzi/dev/mtv-play/api/index.js","./config":"/Users/youzi/dev/mtv-play/app/config.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/app/share.js":[function(require,module,exports){
var config = require('./config')
var dictionary = require('old-vigour-js/app/dictionary')
var app = require('old-vigour-js/app/')
var vObject = require('old-vigour-js/object')
var user = app.user
var api = require('../api')

/* ------------ facebook ------------ */
api.facebook.share.val = {
  url: {
    transform: function parseFacebook (val, cv) {
      if (!cv) return false
      var obj = cv instanceof vObject ? cv.from : user.navigation.media.from
      var parsed = user.$parse(obj)
      var url = config.fburl + parsed.url
      var data = obj
      var query = ''
      var number
      var title
      var img
      var description

      if (data && parsed.title) {
        if (parsed.episode < 10) parsed.episode = '0' + parsed.episode

        number = parsed.season + parsed.episode

        title = parsed.title ? 'og:title=' + encodeURIComponent(
          (parsed.show.title.val ? parsed.show.title.val + (number ? '#' + number : '') + ' | ' : '') + parsed.title + ' - MTV Play'
        ) + '&' : ''
        img = data.img ? 'og:image=' + encodeURIComponent(data.img.val) + '&' : ''
        description = data.description ? 'og:description=' + encodeURIComponent(data.description.val) : ''

        query = '?' + title + img + description
      }
      return url + query
    },
    init: app.ready
  }
}

api.facebook.share
  .on('success', function () {
    // app.notification.val = 'shareSuccess'
  })
  .on('error', function () {
    app.notification.type = this.type
    app.notification.val = 'shareError'
    api.facebook.share.url.val = false
    api.facebook.share.$empty(['url', 'loading'])
  })
  .loading.on(app.loading)

/* ------------ email ------------ */
api.email.share.val = {
  address: '',
  subject: dictionary.get('text.mailShare.title'),
  body: function (val, cv) {
    var url = user.$parse(user.navigation.media).url
    var val = url && url.replace(/&/g, 'and')
    return val ? 'http://mtvplay.tv/#/' + val : false
  }
}

},{"../api":"/Users/youzi/dev/mtv-play/api/index.js","./config":"/Users/youzi/dev/mtv-play/app/config.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js"}],"/Users/youzi/dev/mtv-play/app/spotlight.js":[function(require,module,exports){
var config = require( 'old-vigour-js/util/config' )
var app = require( 'old-vigour-js/app/' )
var Value = require( 'old-vigour-js/value' )
var user = app.user
var Data = require( 'old-vigour-js/data' )

//make defer wrapper for subscriptions and 'real gets'
module.exports = exports = user.spotlight = new Value( {
  transform: function( c, cv ) {
    return this._parent.map && this._parent.map[ cv ]
  },
  defer: function( update, args ) {

    this.clearCache()

    if( this.val || this.val === 0 && app.cases.$isLoggedIn.val ) {

      var data = user.data.from.get( 'spotlight_sub.list.0' )
      var _this = this

      if( this.selected && this.selected.from !== data ) {
        this.selected.remove()
        this.selected = null
      }

      if( !this.selected ) {

        this.set( 'selected',
          new Data( data, {
            subscription: {
              time: true,
              title: true,
              text: true,
              img: true,
              mtvid: true
            }
          } )
        )

        this.selected
          .on( function( val ) {
            var notification_stamp, title = this.from.title && this.from.title.val
            var mtvid = this.from.mtvid && this.from.mtvid.val

            if( title && app.cases.$isLoggedIn.val && this.from.mtvid ) {
              hashed = this.from.mtvid.val
              notification_stamp = user.notification_stamp.from
              if( !notification_stamp.val || notification_stamp.val !== hashed ) {
                notification_stamp.val = hashed
                _this._update( 'success' )
              }
            }
          } )

        this.selected._update.apply( this.selected, args )
      }
    }

    //-------------
    if( args[ 0 ] === 'success' ) {
      update()
    } else {
      update( true )
    }

  }
} )

//hasmtvmobile
exports.map = {
  '0': 'spotlight_sub',
  '1': 'spotlight_sub',
  '2': 'spotlight_mbl'
}

exports.val = user.role

},{"old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/app/tracking.js":[function(require,module,exports){
/*
  TODO: still missing events
  , enable3g:10
  , disable3g:11
  , introSkipped:20
  , introCompleted:19
  , teaserClick:31

subcriptionFailure
video  end
franchise name
*/

var app = require('./index')
var tracking = require('../api/tracking')
var api = require('../api')
var cases = require('old-vigour-js/browser/cases')
var sendEvent = require('../api/tracking/dataform').sendEvent
var setDimension = require('../api/tracking/dataform').setDimension
var Value = require('old-vigour-js/value')

app.mediaTime = new Value()

tracking.omniture.user = app.user

app.popup.on(function () {
  tracking.popup(this.val)
})

app.user.navigation.page.on(function () {
  tracking.pageView(this.val)
})

app.user.navigation.show.on(function () {
  tracking.pageView(this.val)
})

app.user.navigation.media.on(function () {
  tracking.pageView(this.val)
})

app.user.navigation.season.on(function () {
  tracking.pageView(this.val)
})

app.popup.on('intro', function () {
  app.popup.once(function ( val ) {
    tracking.event(val === false ? 'introSkipped' : 'introCompleted', true)
  })
})

api.login
  .on('success', function () {
    if ( this.new_record) {
      tracking.event('signupSucces', true)
      sendEvent('event', 'login', 'signup')
    } else {
      tracking.event('loginSucces', true)
      sendEvent('event', 'login', 'login')
    }

  })
  .on('error', function () {
    tracking.event('loginFailed', true)
  })

api.register
  .on('success', function () {
    tracking.event('signupSucces', true)
    sendEvent('event', 'login', 'signup')
  })
  .on('error', function () {
    tracking.event('signupFailed', true)
  })

api.facebook.share
  .on(function () {
    tracking.event('sharingFacebookStart', true)
  })
  .on('success', function () {
    tracking.event('sharingFacebookSucces', true)
  })

api.email.share
  .on(function () {
    tracking.event('sharingEmailStart', true)
  })
  .on('success', function () {
    tracking.event('sharingEmailSucces', true)
    sendEvent('event', 'sharing', 'email')
  })

var first = true
app.user.search.on(function () {
  var query = app.user.search.val
  if ( query && typeof query === 'string') {
    tracking.event('search', query)
    if ( first ) {
      first = false
      sendEvent('event', 'search', 'query')
      app.user.navigation.page.on(function () {
        first = true
      })
    }
  }
})

api.mobile.verify
  .on('error', function () {
    tracking.event('upgradeMtvFailed')
  // mtvMobileFailed do this
  })

app.menu.on(function () {
  if ( this.val) tracking.event('menu', this.val)
})

// TODO: app.ready should only fire once
app.ready.once(true, function () {
  tracking.event('appstart', true)
})

app.notification
  .on('favourite', function () {
    tracking.event('favoAdded', true)
    sendEvent('event', 'favourite', 'added')
  })
  .on('unFavourite', function () {
    tracking.event('favoRemoved', true)
    sendEvent('event', 'favourite', 'removed')
  })

app.user.receiver.media
  .on(function ( val ) {
    if ( !( this.from && this.from._name === 'media')) {
      tracking.event(val ? 'swipeUp' : 'swipeDown', this.from && this.from._cachedPath)
    }
  })

cases.$hasReceiver.on(function () {
  if ( this.val) {
    var client = app.user.receiverClient.val
    var device = client.device && client.device.val
    if (device) {
      setDimension(device)
    }
  }
})

api.purchase
  .on('success', function () {
    tracking.event(
      this.subscription.val === 'monthly' ? 'upgradeMonthSucces' : 'upgradeAnSucces', true
    )
    sendEvent('event', 'purchase', 'month')
  })
  .on('error', function () {
    tracking.event(
      this.subscription.val === 'monthly' ? 'upgradeMonthError' : 'upgradeAnError', true
    )
  })

api.mobile.sms
  .on('success', function ( val ) {
    tracking.event('upgradeMtvSucces', true)
  })
  .on('error', function ( val ) {
    tracking.event('upgradeMtvFailed', true)
  })

function getMedia () {
  var media
  if ( app.state.val === 'player' && app.state.video) {
    media = app.state.video.val
  } else {
    media = app.user.navigation.media.from
  }
  if ( media && media.val === false) return
  return media
}

app.mediaTime.on(function ( val ) {
  var media = getMedia()
  if ( val && val > 0) {
    return
  }
  if ( media ) {
    tracking.video(val, media)
  }
})

app.playing.on(function ( val ) {
  var media = getMedia()
  if ( media ) {
    tracking.video(val ? 'videoPlay' : 'videoPause', media)
  }
})

/*
  , videoPlay:6
  , videoPause:7

*/

// popup

},{"../api":"/Users/youzi/dev/mtv-play/api/index.js","../api/tracking":"/Users/youzi/dev/mtv-play/api/tracking/index.js","../api/tracking/dataform":"/Users/youzi/dev/mtv-play/api/tracking/dataform.js","./index":"/Users/youzi/dev/mtv-play/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/app/upgrade.js":[function(require,module,exports){
var config = require('./config')
var app = require('old-vigour-js/app/')
var user = app.user
var api = require('../api')
var ua = require('old-vigour-js/browser/ua')

/* ------------ mobile ------------ */

api.mobile.verify.val = {
  token: user.token
}

api.mobile.verify
  .on('success', function (val) {
    if (user.role.val !== 2) {
      api.user.role.poll.val = 500
      app.loading.val = true

      user.role.once(function () {
        app.notification.val = 'mobileUpgradeSuccess'
        api.user.role.poll.val = false
        app.loading.val = false
      })
    } else {
      api.user.role.poll.val = false
    }

    app.popup.val = false
    app.notification.val = 'mobileVerifySuccess'
  })
  .on('error', function (val) {
    app.notification.val = 'mobileVerifyError'
  })
  .loading.on(app.loading)

api.mobile.sms
  .on('success', function (val) {
    user.token.val = this.token.val
    app.notification.val = 'mobileUpgraded'
  })
  .on('error', function (val) {
    app.notification.val = 'mobileUpgradeError'
  })
  .loading.on(app.loading)

app.url.params
  .on(function (val) {
    if (this.m) {
      api.mobile.sms.val = this.m.val
      this.val = ''
    }
  })

/* ------------ purchase ------------ */

function product (val, cv) {
  if (cv) {
    var platform = ua.platform
    if (platform === 'android' && window.AmazonIapV2) {
      platform = 'amazon'
    }
    var store = config.store[platform]

    var productId = store && store[cv]
    console.log('[pay] lalawhat productId', productId)
    if (productId) {
      console.log('[pay] lalawhat productId', productId, productId.replace('$region', (app.region.val || '').toLowerCase()))
      return productId.replace('$region', (app.region.val || '').toLowerCase())
    }
  }
  return 0
}

api.purchase.val = {
  // subscription type goes in here <<<< eg yearly
  subscription: {
    transform: product
  },
  // episode data goes here <<<< (in the from)
  product: {
    transform: function (v, cv) {
      var transform = !cv ? 0 : product(v, 'single')
      return transform
    }
  }
}

api.purchase
  .on('success', function () {
    var obj = {
      receipt: this.token.val
    }

    if (window.AmazonIapV2) {
      obj.userId = this.amazonUserData.userId.val
      obj.receiptId = this.purchaseReceipt.receiptId.val
    }

    if (this.packageName) {
      obj.packageName = this.packageName.val
    }
    if (this.subscriptionId) {
      obj.subscriptionId = this.subscriptionId.val
    }
    if (this.orderId) {
      obj.orderId = this.orderId.val
    }
    if (this.purchaseTime) {
      obj.purchaseTime = this.purchaseTime.val
    }
    if (this.purchaseState) {
      obj.purchaseState = this.purchaseState.val
    }
    if (this.developerPayload) {
      obj.developerPayload = this.developerPayload.val
    }
    if (this.signature) {
      obj.signature = this.signature.val
    }
    // for michael
    if (this.product.val) {
      if (!this.product.from.cloud) {
        throw new Error('trying to buy something else then an episode')
      }
      this.product.from.get('id').is('loaded', function () {
        console.log('ok set some nice stuffs >> episodeId + receipt.val')
        obj.episodeId = this.val
        api.receipt.val = obj
      })
    } else {
      obj.episodeId = false
      api.receipt.val = obj
    }
  })
  .on('error', function () {
    app.notification.type = this.type
    app.notification.val = 'purchaseError'
  })
  .loading.on(app.loading)

api.receipt.val = {
  token: user.token
}

api.receipt
  .on('success', function () {
    var id = this.episodeId && this.episodeId.val
    if (id) {
      user.purchases.$userOrigin.set(id, true)
      app.popup.val = false
      app.notification.val = 'singleEpisodePurchased'
    } else {
      app.notification.val = 'upgraded'
      app.user.role.$userOrigin = 1
      app.popup.val = 'profile'
    }
  })
  .on('error', function () {
    app.notification.type = this.type
    app.notification.val = 'purchaseError'
  })
  .loading.on(app.loading)

api.operator.upgrade.on('success', function () {
  app.notification.val = 'upgraded'
  app.user.role.$userOrigin = 2
  app.user.operator_name.val = api.operator.upgrade.operator.val
  app.popup.val = 'profile'
})
  .on('error', function () {
    app.notification.type = this.type
    app.notification.val = 'purchaseError'
  })
  .loading.on(app.loading)

},{"../api":"/Users/youzi/dev/mtv-play/api/index.js","./config":"/Users/youzi/dev/mtv-play/app/config.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js"}],"/Users/youzi/dev/mtv-play/app/user.js":[function(require,module,exports){
var app = require('old-vigour-js/app')
var cases = app.cases
var Value = require('old-vigour-js/value')
var config = app.config

var user = module.exports = app.user.inject(
  require('old-vigour-js/app/user/token'),
  require('old-vigour-js/app/user/usage'),
  require('old-vigour-js/app/user/navigation'),
  require('old-vigour-js/app/user/multiscreen'),
  require('old-vigour-js/app/user/multiscreen/cast'),
  require('old-vigour-js/app/user/url')
)

user.set({
  profilepic: false,
  first_name: false,
  email: false,
  language: false,
  role: false,
  highlight: false,
  carousel: false,
  search: false,
  accept_newsletter: false,
  FB_token: false,
  scroll: false,
  facebook_id: false,
  url: require('old-vigour-js/browser/network/url'),
  localStorageToken: config.api.type + 'userToken'
})

user.extend({
  name: 'purchases',
  mock: {
    purchases: {}
  },
  subscription: {
    purchases: {
      $: true
    }
  },
  on: {
    mock: function () {
      this.purchases = this.mockdata.purchases
    },
    user: function () {
      this.purchases = this.data.from.get('purchases', {})
    }
  }
})

user.extend({
  name: 'operator_name',
  mock: {
    operator_name: false
  },
  subscription: {
    operator_name: true
  },
  on: {
    mock: function () {
      this.operator_name = this.mockdata.operator_name
    },
    user: function () {
      this.operator_name = this.data.from.get('operator_name', false)
    }
  }
})

cases.$isActive.on(function () {
  if (app.state.val !== 'player') {
    app.state.val = this.val ? 'first' : 'second'
  }
})

app.language.val = app.user.language

app.content.on('self', function switchContent (val, stamp) { // niet smooth
  var old = app.state.val
  app.state.val = 'empty'
  app.state.val = old
})

user.spotlight = require('./spotlight')

user.spotlight.on(function (val) {
  app.popup.from.data = user.spotlight.selected.from
  app.popup.from.val = 'article'
})

user.role.set('text', {
  val: user.role,
  transform: function (c, cv) {
    if (app.user.operator_name.val) {
      return 'operatorPremium'
    }
    return config.roles[cv] || ''
  },
  listen: app.user.operator_name
})

cases.$isUpgraded = new Value({
  val: user.role,
  transform: function (val, cv) {
    return cv > 0 ? true : 0
  }
})

// app.cloud.subscribe({
//   mtvData: {
//     notrial: {
//       $: true
//     }
//   }
// })

cases.$accessForEveryone = new Value(false)

// user.role = {
//   transform: function (v, cv) {
//     return cases.$accessForEveryone.val && cv === 3 ? 0 : cv
//   },
//   listen: cases.$accessForEveryone
// }

user.receiver.media.on(function () {
  if (cases.$isReceiver.val) {
    if (this.val) {
      app.state.clearCache()
      app.state._ignoreValue = true
      app.state.val = {
        val: 'player',
        video: this.from
      }
      app.state._ignoreValue = null
    } else {
      app.state.val = cases.$isActive.val ? 'first' : 'second'
    }
  }
})

cases.$isReceiver.on(function () {
  if (this.val) {
    app.volume.val = user.receiver.volume
    app.playing.val = user.receiver.playing
    user.receiver.media.clearCache()
    user.receiver.media._update()
  } else {
    app.volume.val = app.volume.from.val || 1
    app.playing.val = app.playing.from.val
    app.state.val = cases.$isActive.val ? 'first' : 'second'
  }
})

cases.$isReceiver.on(function () {
  if (this.val) {
    app.css.val = {
      addClass: 'isReceiver'
    }
  } else {
    app.css.val = {
      removeClass: 'isReceiver'
    }
  }
})

},{"./spotlight":"/Users/youzi/dev/mtv-play/app/spotlight.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/user/multiscreen":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/multiscreen/index.js","old-vigour-js/app/user/multiscreen/cast":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/multiscreen/cast/index.js","old-vigour-js/app/user/navigation":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/navigation.js","old-vigour-js/app/user/token":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/token.js","old-vigour-js/app/user/url":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/url.js","old-vigour-js/app/user/usage":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/usage.js","old-vigour-js/browser/network/url":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/url.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/app/util.js":[function(require,module,exports){
var app = require('old-vigour-js/app/'),
  cases = require('old-vigour-js/browser/cases'),
  playIcon = cases.phone ? 'play' : 'playAlt'

// TODO: LOCK ICONS NEEDS TOTAL REFACTOR -- make one module for it
exports.access = function (access, media) {
  if (!media) return

  var trial = app.user.role.val === 3
  var id = media.id && media.id.val // for purchases
  var accesAllowed = media && !(media._parent && media._parent._name === 'channels' && app.user.role.val === 3) && (!access || cases.$isUpgraded.val && (!trial || (trial && access < 2)))

  if (id && app.user.purchases.$userOrigin[id]) {
    accesAllowed = true
  }

  if (!cases.$allowPlayback.val) {
    return 'lockedContent'
  }

  return accesAllowed ? playIcon : 'lockedContent'
}

},{"old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/common.less":[function(require,module,exports){

},{}],"/Users/youzi/dev/mtv-play/components/ad/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')

// <div id='div-gpt-ad-1445622141110-0'>
// <script type='text/javascript'>
// googletag.cmd.push(function() { googletag.display('div-gpt-ad-1445622141110-0'); });
// </script>
// </div>
// var cnt = 0

exports.Billboard = new Element({
  css: 'ad-billboard',
    attr: {
      id: 'leaderboard'
    }
  }).Class

// <!-- /7869/intl_mtvplay.tv 300x250-300x600-->
// <div id='div-gpt-ad-1445622141110-2'>
// <script type='text/javascript'>
// googletag.cmd.push(function() { googletag.display('div-gpt-ad-1445622141110-2'); });
// </script>
// </div>

exports.Medium = new Element({
  css:'ad-medium',
  attr: {
    id: 'div-gpt-ad-1445622141110-2'
  }
}).Class

// <!-- /7869/intl_mtvplay.tv 1x2 -->
// <div id='div-gpt-ad-1445622141110-3' style='height:2px; width:1px;'>
// <script type='text/javascript'>
// googletag.cmd.push(function() { googletag.display('div-gpt-ad-1445622141110-3'); });
// </script>
// </div>

exports.Interstitial = new Element({
  css:'ad-interstitial',
  h:2,
  w:1,
  attr: {
    id: 'div-gpt-ad-1445622141110-3'
  }
}).Class

},{"./style.less":"/Users/youzi/dev/mtv-play/components/ad/style.less","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/ad/style.less":[function(require,module,exports){
require('../../common.less');

},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/button/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var Icon = require( '../icon' )
var util = require( 'old-vigour-js/util' )
var switcher

module.exports = exports = new Element( {
  node: 'button',
  css: 'ui-button',
  text: 'this is a button',
  righticon: new Icon( {
    icon: 'arrowright'
  } )
} ).Class

switcher = new Element( {
  css: function() {
    return 'ui-switch' + ( !this.switchOn || this.switchOn.val !== true ? '' : ' ui-switch-on' )
  },
  btn: {}
} )

switcher.extend( {
  switchOn: function( val ) {
    this.css = 'ui-switch' + ( !val.val || val.val !== true ? '' : ' ui-switch-on' )
  }
} )

exports.Switcher = switcher.Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/button/style.less","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/components/button/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/cookiebar/index.js":[function(require,module,exports){
require('./style.less')

var app = require('old-vigour-js/app')
var cases = require('old-vigour-js/browser/cases')
var Element = require('old-vigour-js/app/ui/element')
var Icon = require('../icon')

var button = new Element({
  css: 'cookie-button',
  text: {
    val: app.localDictionary,
    transform: function (v, cv) {
      var res = app.localDictionary.responseData
      if (res && res.text.cookieBar) {
        return res.text.cookieBar.close.val
      }
    }
  },
  events: {
    down: function (e) {
      e.prevent = true
      var cookie = app.cookiewall || this.parent.parent.parent
      cookie.remove()
    }
  }
})

var info = new Element({
  moreinfo: {
    text: {
      val: app.localDictionary,
      transform: function (v, cv) {
        var res = app.localDictionary.responseData
        if (res && res.text.cookieBar) {
          return '> ' + res.text.cookieBar.link.val
        }
      }
    },
    'events.click': function () {
      var popup = app.popup
      var region = app.region.val
      if (
        region === 'DE' ||
        region === 'BE' ||
        region === 'NO'
      ) {
        popup.data = app.content.get(['privacy', 'list', '0'])
        popup.val = 'article'
      } else {
        popup.data = app.content.get(['legal_cookies', 'list', '0'])
        popup.val = 'articleCookie'
      }
    }
  }
})

var message = new Element({
  title: {
    text: {
      val: app.localDictionary,
      transform: function (v, cv) {
        var res = app.localDictionary.responseData
        if (res && res.text.cookieBar) {
          return res.text.cookieBar.text.val
        }
      }
    }
  }
})

var legal = new Element({
  text: {
    val: app.localDictionary,
    transform: function (v, cv) {
      var res = app.localDictionary.responseData
      if (res && res.text.privacy) {
        return '> ' + res.text.privacy.val
      }
    }
  },
  'events.click': function () {
    var popup = app.popup
    popup.data = app.content.get(['privacy', 'list', '0'])
    popup.val = 'article'
  }
})

module.exports = new Element({
  on: {
    $new: {
      defer: function (update) {
        var cookiebar = this._parent._caller
        var regionNL = app.region.val === 'NL'

        if (regionNL) {
          info.set({
            legal: legal
          })
          if (cases.phone) {
            info.add(button, 'moreinfo')
            cookiebar.set({
              css: 'cookie-bar-nl',
              container: {
                message: message,
                info: info
              }
            })
          } else {
            info.add(button, 'moreinfo')
            cookiebar.set({
              css: 'cookie-bar-nl',
              container: {
                logo: {},
                message: message.set({
                  body: {
                    text: {
                      val: app.localDictionary,
                      transform: function (v, cv) {
                        var res = app.localDictionary.responseData
                        if (res && res.text.cookieBar) {
                          return res.text.cookieBar.nl.text.val
                        }
                      }
                    }
                  }
                }),
                info: info
              }
            })
          }
        } else {
          button.set({
            exit: new Icon({
              icon: 'close'
            })
          })
          cookiebar.set({
            css: 'cookie-bar',
            container: {
              message: message,
              info: info,
              button: button
            }
          })
        }

        app.set({
          h: {
            sub: {
              val: app.w,
              transform: function () {
                return cookiebar.node.offsetHeight
              }
            }
          },
          position: 'relative'
        })

        window.requestAnimationFrame(function(){
          app.h._update()
          window.requestAnimationFrame(function(){
            app.h._update()
          })
        })

        update()
      }
    },
    $remove: {
      defer: function (update) {
        app.h = {
          sub: null
        }

        app.menu._update()
        window.localStorage.setItem('cookieApproved', true)
        update()
      }
    }
  }
}).Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/cookiebar/style.less","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/cookiebar/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/epg_temp.js":[function(require,module,exports){
var Data = require('old-vigour-js/data')
var app = require('old-vigour-js/app/')
var config = require('old-vigour-js/util/config')
var ajax = require('old-vigour-js/browser/network/ajax')
var epgData = new Data()
var blacklist = []

module.exports = exports = function (id, fallback) {
  if (~blacklist.indexOf(id)) {
    if (fallback) fallback()
    return
  }
  var date = exports.getDate()
  var specific = app.region.val.toLowerCase() + '/channels/' + id + '/' + date
  if (!epgData[date]) {
    epgData.empty
    epgData.set(date, {})
  }
  if (!epgData[date][specific] || !epgData[date][specific].val) {
    epgData[date].set(specific, false)

    ajax({
      url: 'https://api.mtvnn.com/v2/airings.json/?channel_id=' + id + '&filter=today&bust=' + ~~(Math.random() * 1000000),
      headers: {
        Accept: '*/*'
      },
      iframe: config.epg,
      method: 'GET',
      complete: function (result) {
        if (result instanceof Array) {
          var airings = []
          result.forEach(function (self, i) {
            var airing = self.airing
            var next = result[i + 1]
            airing.duration = (next ? next.airing.minutes_since_midnight : result[0].airing.minutes_since_midnight) - airing.minutes_since_midnight || 1440
            airing.endtime = airing.minutes_since_midnight + airing.duration
            airings.push(airing)
          })
          epgData[date].set(specific, airings)
        } else {
          blacklist.push(id)
          epgData[date][specific].removeListener() // remove all possible listeners
          if (fallback) fallback()
        }
      },
      error: function (err) {
        blacklist.push(id)
        if (fallback) fallback()
      }
    })
  }
  return epgData[date][specific]
}

exports.now = function (id, data) {
  var timeNow = exports.minutesSinceMidnight()
  var nowplaying, epgdata = exports(id)
  var checker
  if (!epgdata) return
  if (!epgdata.val) {
    var nowplaying = new Data()
    checker = function checker() {
      this.each(findNowPlaying)
      epgdata.removeListener(checker)
    }
    epgdata.addListener(checker)
  } else {
    epgdata.each(findNowPlaying)
  }

  return nowplaying

  function findNowPlaying() {
    if (this.minutes_since_midnight) {
      var startTime = this.minutes_since_midnight.val
      var endTime = startTime + this.duration.val

      if (startTime <= timeNow && endTime > timeNow) {
        if (nowplaying) nowplaying.val = this
        else nowplaying = this
        if (checker) epgdata.removeListener(checker)
        return
      }
    }
  }
}

exports.anyNow = function (data) {
  if (data._name === 'channels') {
    var keys = data.keys
    var i = keys.length
    var self = this
    if (!i) return
    this._findNow = new Data()
    for (i--; i >= 0; i--) {
      var epgid = data[keys[i]].epgid
      if (epgid !== void 0) {
        this.model = false
        var epgNow = exports.now(epgid.val)
        if (epgNow) {
          if (epgNow.title) {
            this.data = epgNow
            this._link = returnLink(keys[i])
          } else {
            this._findNow[i] = epgNow
            this._findNow[i]._index = keys[i]
            this._findNow[i].addListener(function () {
              if (this._index !== void 0) {
                self.model = false
                self.data = this.from.val
                self._link = returnLink(this._index)
                setTimeout(function () {
                  self._findNow && self._findNow.remove()
                })
              }
            })
          }
        }
      }
    }
  }
}

exports.getDate = function (sep) {
  if (!sep) sep = '-'
  var today = new Date()
  var dd = today.getDate()
  var mm = today.getMonth() + 1
  var yyyy = today.getFullYear()
  if (dd < 10) dd = '0' + dd
  if (mm < 10) mm = '0' + mm
  return yyyy + sep + mm + sep + dd
}

exports.minutesSinceMidnight = function () {
  var d = new Date()
  var e = new Date(d)
  var msSinceMidnight = e - d.setHours(0, 0, 0, 0)
  return msSinceMidnight / 60000
}

exports.clockTime = function (v, minutes) {
  var h = ~~(minutes / 60),
    m = ~~(minutes % 60)
  if (h > 23) h -= 24
  else if (h < 10) h = '0' + h
  if (m < 10) m = '0' + m
  return h + ':' + m
}

function returnLink(i) {
  return ['mtvData', app.region.val, app.language.val, 'channels', i].join('.')
}

},{"old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/network/ajax":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/ajax.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/first/channels/index.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var Overview = require( '../overview' )
var Icon = require( '../../icon' )
var app = require( 'old-vigour-js/app/' )

var channelItems = new Overview.Items( {
  pageheader: {
    'text.dictionary': 'text.nav.channels'
  },
  collection: {
    data: 'channels',
    element: Overview.Item.Tv ? new Overview.Item.Tv : new Overview.Item( {
      righticon: new Icon( {
        on: {
          data: 'id'
        },
        icon: {
          data: 'access',
          transform: function( val, cv ) {
            var icon = app.util.access( cv, this.data )
            return icon === 'lockedContent' ? 'lockedContentAlt' : 'arrowright'
          },
          listen: app.user.role
        }
      } ),
      events: {
        click: function() {
          this.checkParent( 'on.media', true ).$userOrigin = this.data.from
        }
      }
    } )
  },
  model: {
    complete: function() {
      if( !this.parent.node.scrollTop ) {
        this.parent.node.scrollTop = 1
      }
      this.model = false
    }
  }
} )

module.exports = new Overview( {
  items: channelItems
} ).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../overview":"/Users/youzi/dev/mtv-play/components/first/overview/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/first/discover/carousel.js":[function(require,module,exports){
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var dictionary = require('old-vigour-js/app/dictionary')
var Img = require('../../img')
var Icon = require('../../icon')
var Title = require('../../text').Title
var app = require('old-vigour-js/app/')
var cases = require('old-vigour-js/browser/cases')
var config = require('old-vigour-js/util/config')
var animationFrame = require('old-vigour-js/browser/animation/frame')
var timer
var cancelAutoRoll

var slide = new Element({
  img: new Img.Carousel({
    teaser: {
      title: new Title()
    },
    background: {
      range: 100
    },
    events: {
      active: 'clicked',
      click: function () {
        var data = this.data
        var type = data.type && data.type.val
        var link = data.link && data.link.val
        var url = data.url && data.url.val

        if (url) {
          app.api.url.val = url
        } else if (type === 'Article') {
          app.popup.from.data = data.from
          app.popup.from.val = 'article'
        } else if (link) {
          link = link.split('.')
          type = link[link.length - 2]
          if (type === 'episodes' || type === 'extras' || type === 'channels') {
            app.user.navigation.media.$userOrigin = app.content.from.get(link.slice(3))
          } else if (type === 'shows') {
            app.user.navigation.show.$userOrigin = app.content.from.get(link.slice(3))
          } else if (type === 'seasons') {
            app.user.navigation.season.$userOrigin.val = app.content.from.get(link.slice(3))
            app.user.navigation.show.$userOrigin = app.content.from.get(link.slice(3,5))
          }
        } else {
          console.warn('There is no behaviour defined for this slide.')
        }
      }
    }
  }),
  model: {
    subscription: {
      url: true,
      link: true,
      type: true
    }
  }
})

var roll = new Element({
  css: 'ui-roll',
  x: {
    data: 'carousel',
    transform: function (v, cv) {
      if (isNaN(cv)) {
        cv = cv._val || 0
      }
      this._pos = cv
      return cv * this.node.offsetWidth || 0
    },
    animation: {
      time: {
        val: 36,
        phone: 18
      },
      easing: 'outCubic'
    },
    listen: app.w
  },
  collection: {
    data: 'marquee',
    element: slide
  },
  touch: {
    events: {
      grab: {
        x: true,
        pass: function (e, d) {
          if (Math.abs(d.x) > Math.abs(d.y)) {
            cancelAutoRoll = true
            return true
          }
        },
        up: setPosition
      }
    }
  },
  model: {
    complete: function () {
      var _this = this
      _this.x._p = true
      window.requestAnimationFrame(function () {
        if (_this.x) {
          _this.x.update()
          _this.x._p = null
        }
      })
      this.model = {
        complete: null
      }
    }
  }
})

var buttons = new Element({
  css: 'ui-car-buttons',
  prevBtn: new Icon({
    icon: 'leftnav',
    events: {
      click: function () {
        var rll = this.parent.parent.roll,
          ps = rll._pos

        if (ps < 0) setPos(rll, ps + 1)
      }
    }
  }),
  nextBtn: new Icon({
    icon: 'rightnav',
    events: {
      click: function () {
        var rll = this.parent.parent.roll,
          ps = rll._pos | 0
        if (ps - 1 > -rll.children.length) setPos(rll, ps - 1)
      }
    }
  })
})

var dots = new Element({
  css: 'ui-dots',
  collection: {
    data: 'marquee',
    element: new Element({
      events: {
        click: function () {
          setPos(this.checkParent('roll', true), -index(this))
        }
      }
    })
  }
})

dots.extend({
  dotFocus: function (val) {
    var pos = -val.val || 0,
      dts = this.children

    for (var i = dts.length - 1; i >= 0; i--) {
      var dot = dts[i]
      if (i === pos) dot.css = 'dot-focus'
      else dot.css = false
    }
  }
})

var carousel = new Element({
  on: {
    $remove: {
      defer: function (update) {
        clearTimeout(timer)
      }
    }
  },
  tablet: {
    bgTeaser: {}
  },
  roll: roll,
  'desktop.buttons': buttons,
  dotholder: {
    dots: new dots.Class({
      dotFocus: {
        data: 'carousel'
      }
    })
  }
})

if (cases.tablet) {
  carousel.h = {
    val: app.w,
    multiply: 9 / 16,
    max: {
      val: app.h,
      multiply: 1 / 2
    }
  }
}

module.exports = exports = carousel
exports.Dots = dots.Class
exports.Buttons = buttons.Class
exports.Roll = roll.Class

function autoRoll(roll) {
  clearTimeout(timer)
  timer = setTimeout(function () {
    var newPos = roll._pos !== -roll.children.length + 1 ? roll._pos - 1 : 0
    autoRoll(roll)
  }, 5000)
}

function index(me) {
  if (!me._i) {
    var siblings = me.parent.children,
      i = siblings.length - 1

    for (; i >= 0;) siblings[i]._i = i--
  }
  return me._i
}

// TODO: unify with switcher
function setPosition(e, d, ld) {
  var treshold = 120,
    flick = 10,
    l = this.children.length,
    oldPos = this._pos || (this._pos = 0),
    newPos = oldPos,
    unfocus

  if (Math.abs(ld.x) > flick) {
    if (ld.x < 0 && !(d.x > treshold)) newPos = Math.max(oldPos - 1, -l + 1)
    if (ld.x > 0 && !(d.x < -treshold)) newPos = Math.min(oldPos + 1, 0)
  } else {
    if (d.x < -treshold) newPos = Math.max(oldPos - 1, -l + 1)
    if (d.x > treshold) newPos = Math.min(oldPos + 1, 0)
  }

  if (this.x._e) this.x = {
    _esub: this.x._e._val
  }

  cancelAutoRoll = false

  setPos(this, newPos)
}

function setPos(roll, newPos) {
  var oldPos = roll._pos || (roll._pos = 0),
    discoverdots = roll.parent.dotholder.dots,
    dts = (discoverdots || roll.parent.parent.parent.parent.topbar.txt.dotholder.dots).children

  if (newPos !== oldPos) {
    roll.data.carousel.from = newPos
    roll._pos = newPos
  }

  if (discoverdots && timer) autoRoll(roll)
}

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../../text":"/Users/youzi/dev/mtv-play/components/text/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/discover/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/animation/frame":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/frame.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/first/discover/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var carousel = require('./carousel')
var cases = require('old-vigour-js/browser/cases')
var lists = require('./lists')
var BillboardAd = require('../../ad').Billboard

var base = new Element({
  css: 'first-discover',
  x: {
    translate: true
  },
  '!phone.ad':new BillboardAd(),
  carousel: new carousel.Class(),
  touch: {
    scrollbar: 'y',
    on: {
      $render: {
        defer: function (update) {
          var caller = this._parent._caller
          if (exports.scrollTop){
            window.requestAnimationFrame(
            function () {
              if (caller._node) caller.node.scrollTop = exports.scrollTop || cases.touch && 1
            })
          }
          update()
        }
      }
    },
    model: {
      complete: function () {
        this.node.scrollTop = exports.scrollTop || cases.touch && 1
        this.model = {
          complete: null
        }
      }
    }
  },
  lists: lists,
  'events.scroll': function () {
    var node = this.node
    var scrollTop = exports.scrollTop = node.scrollTop
    if (cases.$hasReceiver.val) {
      var rect = node.getBoundingClientRect()
      this.data.scroll.$userOrigin = scrollTop / (node.scrollHeight - rect.height)
    }
  }
})

module.exports = base.Class

},{"../../ad":"/Users/youzi/dev/mtv-play/components/ad/index.js","./carousel":"/Users/youzi/dev/mtv-play/components/first/discover/carousel.js","./lists":"/Users/youzi/dev/mtv-play/components/first/discover/lists.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/discover/style.less","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/discover/lists.js":[function(require,module,exports){
var app = require('old-vigour-js/app/'),
  cases = require('old-vigour-js/browser/cases'),
  dictionary = require('old-vigour-js/app/dictionary'),
  Element = require('old-vigour-js/app/ui/element'),
  Icon = require('../../icon'),
  Img = require('../../img'),
  Item = require('../../item'),
  Text = require('../../text'),
  epgData = require('../../epg_temp'),
  Title = Text.Title,
  TitleSubtitle = Item.TitleSubtitle

var imgWidth = cases.phone ? 150 : 220

var item = new Element({
  x: {
    translate: true
  },
  img: new Img({
    h: {
      val: 152,
      phone: 100
    },
    w: {
      val: 220,
      phone: 150
    }
  }),
  txt: new TitleSubtitle()
})

var linkitem = new item.Class({
  model: {
    subscription: {
      link: true
    }
  },
  txt: {
    subtitle: {
      text: {
        data: 'subtitle'
      }
    }
  },
  events: {
    active: 'ui-item-clicked',
    click: linkClick
  }
})

var List = new Element({
  css: 'list',
  on: {
    $render: {
      defer: function (update) {
        var caller = this._parent._caller
        var length = caller.scroller.children.length
        caller.display = !length ? 'none' : 'block'
        update()
      }
    }
  },
  header: {},
  scroller: {
    css: 'preload',
    scrollbar: 'x',
    x: {
      translate: true
    },
    y: {
      translate: true
    },
    collection: {
      data: true, // 'list'
      element: linkitem
    },
    touch: {
      events: {
        scroll: function () {
          this.css = ''
        }
      }
    }
  },
  'model.complete': function () {
    if (this.scroller) {
      var length = this.scroller.children.length
      this.display = !length ? 'none' : 'block'
    }
  }
}).Class

module.exports = new Element({
  action: new Item({
    ontv: {
      text: 'on tv'
    },
    program: {
      text: {
        data: 'title'
      }
    },
    arrow: new Icon({
      icon: 'arrowright'
    }),
    events: {
      active: 'action-clicked',
      click: function () {
        if (this._link) {
          this._stayActive = true
          this.checkParent('on.media', true).$userOrigin = app.cloud.data.get(this._link)
        }
      }
    },
    model: {
      subscription: {
        $: {
          epgid: true
        }
      },
      val: function (data) {
        if (data.channels) epgData.anyNow.call(this, data.channels)
      }
    }
  }),
  allshows: {
    'text.dictionary': 'text.nav.allShows',
    events: {
      active: 'ui-item-clicked',
      click: function () {
        this._stayActive = true
        this.checkParent('on.page', true).$userOrigin = 'shows'
      }
    }
  },
  watched: new List({
    css: 'list watched',
    header: {
      text: {
        dictionary: 'text.showsYouWatch'
      }
    },
    scroller: {
      collection: {
        data: 'watched',
        element: new linkitem.Class({
          events: {
            active: 'ui-item-clicked',
            click: function () {
              app.user.navigation.media.$userOrigin = this.data.media.from
            }
          },
          model: function (data) {
            var path = data.media && data.media.from._contentPath
            if (path) {
              this.img.cover.data = app.user.usage.from.get(path)
              this.txt.subtitle.data = data.media.from
              this.model = false
            }
          },
          img: {
            background: {
              data: 'show.img'
            },
            cover: {
              model: {
                inherit: false
              },
              desktop: {
                percentage: {
                  text: {
                    data: 'time',
                    transform: function (v, cv) {
                      var p = Math.floor(cv * 100)
                      return p ? Math.abs(p) + '%' : ''
                    }
                  }
                }
              },
              bar: {
                y: {
                  tablet: 147,
                  phone: 95
                },
                w: {
                  data: 'time',
                  transform: function (v, cv) {
                    return !isNaN(cv) ? Math.abs(cv) * imgWidth : 0
                  }
                }
              }
            }
          },
          txt: {
            title: {
              text: {
                data: 'show.title'
              }
            },
            subtitle: new Text.Subtitle({
              model: {
                inherit: false
              }
            })
          }
        })
      }
    }
  }),
  releases: new List({
    header: {
      text: {
        dictionary: function(){
          var region = app.region.val
          if(region){
            var role = app.user.role.val
            role = !role || role === 3 ? 'free' : 'premium'
            return region && 'text.discover.' + region.toLowerCase() + '.row1.' + role
          }
        },
        listen:app.user.role
      }
    },
    scroller: {
      collection: {
        data: 'releases',
        desktop: {
          element: new Item.Large({
            info: {
              txt: {
                title: {
                  text: {
                    data: 'title'
                  }
                },
                subtitle: {
                  text: {
                    data: 'subtitle'
                  }
                }
              }
            },
            events: {
              active: 'ui-item-clicked',
              click: linkClick
            },
            crawler: {
              href: {
                // still very dirty, needs some cleaning
                data: 'link',
                transform: function (v, cv) {
                  if (!cv) {
                    return
                  }
                  var link = cv.split('.')
                  var length = link.length
                  var type = link[length - 2]
                  var showid
                  var seasonnr
                  var episodenr
                  if (type === 'episodes' || type === 'extras') {
                    showid = link[4]
                    seasonnr = link[6] + 1
                    episodenr = link[8] + 1
                    return 'shows/' + showid + '/' + seasonnr + '/' + episodenr || ''
                  } else if (type === 'seasons') {
                    showid = link[4]
                    seasonnr = link[6] + 1
                    return 'shows/' + showid + '/' + seasonnr
                  } else if (type === 'shows') {
                    showid = link[4]
                    return 'shows/' + showid
                  } else if (type === 'channels') {
                    showid = link[4]
                    return 'channels/' + showid
                  }
                }
              },
              attr: {
                onclick: 'return false'
              }
            }
          })
        }
      }
    }
  }),
  recommended: new List({
    header: {
      text: {
        dictionary: function(){
          var region = app.region.val
          if(region){
            var role = app.user.role.val
            role = !role || role === 3 ? 'free' : 'premium'
            return region && 'text.discover.' + region.toLowerCase() + '.row2.' + role
          }
        },
        listen:app.user.role
      }
    },
    scroller: {
      collection: {
        data: 'recommended'
      }
    }
  }),
  free: new List({
    header: {
      text: {
        dictionary: function(){
          var region = app.region.val
          if(region){
            var role = app.user.role.val
            role = !role || role === 3 ? 'free' : 'premium'
            return region && 'text.discover.' + region.toLowerCase() + '.row3.' + role
          }
        },
        listen:app.user.role
      }
    },
    scroller: {
      collection: {
        data: 'free'
      }
    }
  })
})

function linkClick() {
  var type
  var link = this.data.link.val
  var header = (this.parent.header && this.parent.header.text.val) || (this.parent.parent.header && this.parent.parent.header.text.val)
  if (header) {
    // set hier ff title op het echte object
    // setTimeout(function() { track.generalEvent('teaserClick', header, link) },500)
  }
  if (link) {
    this._stayActive = true
    link = link.split('.')
    type = link[link.length - 2]
    if (type === 'episodes' || type === 'extras' || type === 'channels') {
      app.user.navigation.media.$userOrigin = app.content.from.get(link.slice(3))
    } else if (type === 'shows') {
      app.user.navigation.show.$userOrigin = app.content.from.get(link.slice(3))
    } else if (type === 'seasons') {
      app.user.navigation.season.$userOrigin.val = app.content.from.get(link.slice(3))
      app.user.navigation.show.$userOrigin = app.content.from.get(link.slice(3,5))
    }
  }
  // appData.current.from.val = link
}

},{"../../epg_temp":"/Users/youzi/dev/mtv-play/components/epg_temp.js","../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../../text":"/Users/youzi/dev/mtv-play/components/text/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/discover/style.less":[function(require,module,exports){
require('../../../common.less');

},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/epg/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var Data = require( 'old-vigour-js/data' )
var app = require( 'old-vigour-js/app/' )
var Icon = require( '../../icon' )
var Item = require( '../../item' )
var Seekbar = require( '../../player/seekbar' )
var epgData = require( '../../epg_temp' )
var cases = require( 'old-vigour-js/browser/cases' )
var Value = require( 'old-vigour-js/value' )
var clockTime = epgData.clockTime
var minutesSinceMidnight = epgData.minutesSinceMidnight

var fixValue = new Value( {
  val: 360,
  phone: app.w,
  sub: 30
} )

var EpgItem = new Element( {
  holder: {
    txt: new Item.TitleSubtitle( {
      subcontainer: {
        subtitle: {
          text: {
            data: 'minutes_since_midnight',
            transform: clockTime
          }
        },
        seekbar: {
          text: ' - ',
          css: 'subtitle'
        },
        endtime: {
          css: 'subtitle',
          text: {
            data: 'endtime',
            transform: clockTime
          }
        }
      }
    } )
  },
  border: {}
} ).Class

module.exports = exports = new Element({
    message: {
      icon: new Icon( {
        icon: 'empty'
      } )
    },
    container: {
      list: {
        touch: {
          scrollbar: 'y',
          h: {
            val: app.h,
            sub: {
              val: 40,
              iosFull: 60,
              add: {
                phone: {
                  val: app.w,
                  divide: 16 / 9
                }
              }
            }
          }
        },
        collection: {
          data: true,
          element: new EpgItem(),
          filter: {
            condition: {
              endtime: {
                $gt: minutesSinceMidnight
              }
            }
          }
        },
        model: {
          complete: function() {
            var self = this,
              currentShow = this.children[ 0 ],
              message = this.parent.parent.message
            if( !currentShow ) {
              message.icon.icon = 'warning'
              message.text = {
                dictionary: 'text.noEPG'
              }
              return
            }

            message.icon.icon = ''
            message.text = ''

            var currentStarts = currentShow.data.minutes_since_midnight.val,
              currentEnds = currentShow.data.endtime.val,
              duration = currentShow.data.duration.val,
              timeLeft = ~~( ( currentEnds - minutesSinceMidnight() ) * 60000 ) + 3000,
              seekbar = currentShow.holder.txt.subcontainer.seekbar

            if( !seekbar.seek && duration ) {
              currentShow.set( {
                'holder.txt.subcontainer.seekbar': new Seekbar( {
                  seek: {
                    w: {
                      data: 'time'
                    }
                  },
                  button: false,
                  data: new Data( {
                    time: ( minutesSinceMidnight() - currentStarts ) / duration
                  } )
                } )
              } )

              if( this._interval ) clearInterval( this._interval )

              var self = this
              this._interval = setInterval( function() {
                if( currentShow && currentShow.holder && currentShow.holder.txt ) {
                  var progress = minutesSinceMidnight() - currentStarts
                  currentShow.holder.txt.subcontainer.seekbar.data.time.val = progress / duration
                } else {
                  clearInterval( self._interval )
                  self._interval = null
                }

              }, 1000 )
            }

            if( timeLeft > 0 ) {
              if( this._timer ) clearTimeout( this._timer )
              this._timer = setTimeout( function() {
                self.updateData()
                self._timer = null
              }, timeLeft + 2000 )
            }

          }
        }
      },
      model: {
        inherit: false
      }
    },
    phone: {
      position: 'absolute'
    },
    model: {
      field: 'media',
      subscription: {
        epgid: true
      },
      val: function( data ) {
        var epgid = data.epgid && data.epgid.val,
          self = this,
          epgdata
        if( epgid !== void 0 ) {
          epgdata = epgData( epgid )
          this.container.data = epgdata
          this.model = false
        }
      }
    }
  } ).Class

exports.base.container.list.setSetting( {
  name: 'remove',
  remove: function() {
    if( this._timer ) clearTimeout( this._timer )
    if( this._interval ) clearInterval( this._interval )
  }
} )

},{"../../epg_temp":"/Users/youzi/dev/mtv-play/components/epg_temp.js","../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../../player/seekbar":"/Users/youzi/dev/mtv-play/components/player/seekbar/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/epg/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/components/first/epg/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/favourite/index.js":[function(require,module,exports){
require( './style.less' )

var Icon = require( '../../icon' )
var cases = require( 'old-vigour-js/browser/cases' )
var app = require( 'old-vigour-js/app/' )

module.exports = new Icon( {
  icon: {
    data: 'showusage.favourite',
    transform: function( v, favourite ) {
      if( favourite && ( favourite === 'true' || favourite === true ) ) {
        this.css = 'ui-icon favorited'
        return 'favorite'
      } else {
        this.css = 'ui-icon'
        return 'favoriteadd'
      }
    }
  },
  'events.click': function() {
    if( cases.$isLoggedIn.val ) {
      var thisUsage = this.data.showusage.$userOrigin
      if( !thisUsage.favourite || !thisUsage.favourite.val ) {
        thisUsage.val = {
          favourite: true
        }
      } else {
        thisUsage.val = {
          favourite: false
        }
      }
    } else {
      app.popup.from.val = 'roadblock'
    }
  }
} ).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/favourite/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/favourite/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var app = require('old-vigour-js/app/')
var cases = require('old-vigour-js/browser/cases')
var Menu = require('./menu')
var Icon = require('../icon')
var ad = require('../ad')
var InterstitialAd = ad.Interstitial
var BillboardAd = ad.Billboard
var Switcher

// ----overlay-----
if (cases.tv) {
  Switcher = require('./tv')

  module.exports = exports = new Element({
    css: 'first-state',
    sidemenu: new Menu.Sidemenu(),
    w: {
      parent: 'w'
    },
    h: {
      parent: 'h'
    },
    switcher: new Switcher({
      position: 'absolute',
      h: {
        parent: 'h'
      }
    })
  }).Class

} else {
  var Notification = require('./notification')
  Switcher = require('./switcher')
  var Miniplayer = require('./miniplayer')
  var Player = require('../player')
  var Popup
  var watch = require('./watch')
  var Loader = require('../loader')
  var postpone = require('old-vigour-js/browser/events/util').postpone
  var updateWidth = postpone(function (t, smallscreen) {
    if (t.topbar) {
      t.topbar.display = smallscreen ? 'block' : 'none'
      t.switcher.y = smallscreen ? 40 : 0
      t._block = true
      t.w.update()
    }
  }, 100)

  function msMediaInit (update) {
    var parent = this._parent,
      caller = parent._caller,
      msMedia = this.$userOrigin

    if (msMedia.val) {
      if (!caller.miniplayer) {
        caller.miniplayer = new Miniplayer({
          on: {
            usage: parent.usage.from,
            msmedia: msMedia,
            volume: parent.volume.from
          },
          data: {
            media: msMedia,
            mediausage: parent.usage.from.get(msMedia.from._contentPath),
            volume: parent.volume.from
          },
          play: {
            icon: parent.play
          },
          y: (cases.phone && msMedia.from._parent._name === 'channels') ? 24 : 0
        })
        caller.add(caller.miniplayer, cases.phone && 'topmenu')
      }
      update()
    } else {
      return true
    }
  }

  function onPopup (update, args) {
    var caller = this._parent._caller
    if (this.val && !caller.popupWindow) {
      if (!Popup) Popup = require('../popup')

      var popupElem = new Popup({
        name: 'popupWindow',
        on: {
          user: app.user,
          language: app.user.language,
          token: app.user.token,
          newsletter: app.user.newsletter,
          overlay: app.overlay,
          loading: app.loading,
          popup: app.popup
        }
      })

      caller.add(popupElem, caller.notification)

      caller.popupWindow.on.popup._update()
    }
    update()
  }

  function onNotification (update, args) {
    var caller = this._parent._caller
    if (this.val && !caller.notification) {
      caller.set({
        notification: new Notification({
          on: {
            notification: app.notification
          }
        })
      })
      caller.notification.on.notification._update()
    }
    update()
  }

  function onLoading (update, args) {
    var caller = this._parent._caller,
      loader = caller.loader,
      cancel = caller.cancel,
      overlay = caller.checkParent('on.overlay', true),
      _this = this

    this.clearCache()
    if (caller._cancelTimer) {
      clearTimeout(caller._cancelTimer)
      caller._cancelTimer = null
    }

    if (this.val) {
      if (!overlay.val) overlay.from.val = 'loading'
      if (!loader) {
        caller.set({
          loader: new Loader()
        })
        caller._cancelTimer = setTimeout(function () {
          caller.set({
            cancel: {
              btn: {
                text: 'cancel'
              },
              events: {
                click: function () {
                  _this.from.val = false
                }
              }
            }
          })
          caller._cancelTimer = null
        }, 8000)
      }
    } else if (!this.val) {
      if (cancel) cancel.remove()
      if (loader) loader.remove()
      if (overlay.val === 'loading') overlay.from.val = false
    }
    update()
  }

  function onRemove (update) {
    var caller = this._parent._caller
    if (caller._cancelTimer) clearTimeout(caller._cancelTimer)
    update()
  }

  if (cases.phone) {
    module.exports = exports = new Element({
      css: 'first-state',
      // ad:new InterstitialAd(),
      on: {
        popup: {
          defer: onPopup
        },
        notification: {
          defer: onNotification
        },
        loading: {
          defer: onLoading
        },
        $remove: {
          defer: onRemove
        },
        $render: {
          defer: function (update) {
            var caller = this._parent._caller,
              section = caller.section

            section.on.msmedia._update()
            caller.on.popup._update(caller.on.popup.val)

            update()
          }
        }
      },
      w: {
        parent: 'w'
      },
      h: {
        parent: 'h'
      },
      section: {
        on: {
          msmedia: {
            init: msMediaInit
          }
        },
        w: {
          parent: 'w'
        },
        h: {
          parent: 'h'
        },
        switcher: new Switcher({
          position: 'absolute',
          y: {
            translate: true,
            val: Menu.Topbar.base.h,
            add: {
              val: 0,
              $fromMtvSite: 30
            }
          },
          h: {
            parent: 'h',
            sub: {
              val: Menu.Topbar.base.h,
              add: {
                val: 0,
                $fromMtvSite: 30
              }
            }
          }
        }),
        linkback: {
          position: 'absolute',
          y: {
            translate: true,
            val: Menu.Topbar.base.h,
            sub: {
              val: 30,
              $fromMtvSite: 0
            }
          },
          title: {
            text: {
              dictionary: 'text.backlink'
            }
          },
          close: new Icon({
            icon: 'close',
            'events.click': function (e) {
              e.prevent = true
              e.preventDefault()
              cases.$fromMtvSite.val = false
            }
          }),
          'events.click': function () {
            document.location.href = app.fromMtvSite
          }
        },
        topmenu: new Menu.Topmenu({
          on: {
            menu: app.menu
          }
        }),
        topbar: new Menu.Topbar({
          display: {
            desktop: 'none'
          }
        })
      }
    }).Class

  } else {
    module.exports = exports = new Element({
      css: 'first-state',
      on: {
        state: {
          defer: function (update) {
            var state = this.from.val,
              _this = this,
              caller = this._parent._caller,
              section = caller.section

            if (state === 'first' && !caller.w) // just add this to element maybe?
            {
              caller.set({
                on: {
                  popup: {
                    defer: onPopup
                  },
                  notification: {
                    defer: onNotification
                  },
                  loading: {
                    defer: onLoading
                  },
                  $remove: {
                    defer: onRemove
                  },
                  fullscreen: {
                    val: cases.$isFullscreen,
                    defer: function (update) {
                      var section = this._parent._caller.section
                      section.x._p = true
                      window.requestAnimationFrame(function () {
                        if (section && section.x) section.x._p = null
                      })
                      update()
                    }
                  }
                },
                w: {
                  parent: 'w'
                },
                h: {
                  parent: 'h'
                },
                sidemenu: new Menu.Sidemenu({
                  data: app.user.navigation
                }),
                section: {
                  on: {
                    msmedia: {
                      init: msMediaInit
                    }
                  },
                  x: {
                    val: cases.tablet ? {
                      val: 0,
                      $isFullscreen: 0
                    } : {
                      val: 200,
                      $isFullscreen: 0
                    },
                    animation: {
                      time: 18,
                      easing: 'outCubic'
                    }
                  },
                  w: {
                    parent: 'w',
                    desktop: {
                      sub: {
                        self: 'x'
                      }
                    }
                  },
                  h: {
                    parent: 'h'
                  },
                  switcher: {
                    position: 'absolute',
                    h: {
                      parent: 'h'
                    },
                    touch: {
                      y: {
                        translate: true,
                        val: Menu.Topbar.base.h,
                        add: {
                          val: 0,
                          $fromMtvSite: 30,
                          $isFullscreen: 0
                        },
                        $isFullscreen: 0
                      },
                      h: {
                        sub: {
                          val: Menu.Topbar.base.h,
                          add: {
                            val: 0,
                            $fromMtvSite: 30
                          }
                        }
                      }
                    }
                  }
                }
              })

              section.on.msmedia._update()
              caller.on.popup._update(caller.on.popup.val)

              if (cases.desktop) {
                section.x._p = true
                section.x = {
                  val: app.w,
                  defer: function (update, args) {
                    if (args[0]) {
                      this._p = true
                      update()
                      this._p = null
                    } else {
                      update()
                    }
                  },
                  transform: function (v, cv) {
                    if (cases.$isFullscreen.val) return 0
                    var smallscreen = app.w.val < 1300
                    if (!this._block) updateWidth(this, smallscreen)
                    else this._block = null
                    return smallscreen && !app.menu.val ? 0 : 200
                  }
                }
                section.x._p = null
              }

            }

            section.x._p = true
            window.requestAnimationFrame(function () {
              if (section.x) section.x._p = null
            })

            update()
          }
        },
        $parent: {
          defer: function (update) {
            this._parent.state._update()
            update()
          }
        }
      },
      sidemenu: {},
      section: {
        x: {
          translate: true
        },
        switcher: new Switcher(),
        tablet: {
          linkback: {
            position: 'absolute',
            y: {
              translate: true,
              val: Menu.Topbar.base.h,
              sub: {
                val: 30,
                $fromMtvSite: 0
              }
            },
            title: {
              text: {
                dictionary: 'text.backlink'
              }
            },
            close: new Icon({
              icon: 'close',
              'events.click': function (e) {
                e.prevent = true
                e.preventDefault()
                cases.$fromMtvSite.val = false
              }
            }),
            'events.click': function () {
              document.location.href = app.fromMtvSite
            }
          }
        },
        topbar: new Menu.Topbar({
          display: {
            desktop: 'none'
          }
        })
      }
    }).Class
  }

  exports.base.set({
    overlay: {
      display: 'none',
      'events.click': function () {
        var loading = this.parent.on.loading,
          popup = this.parent.on.popup
        if (!loading.val) {
          popup.from = false
        }
      }
    },
    on: {
      overlay: {
        defer: function (update, args) {
          var overlay = this.from
          if (!overlay) return true
          if (overlay.val) {
            this._parent._caller.overlay.display.val = 'block'
          } else if (!overlay.val) {
            this._parent._caller.overlay.display.val = 'none'
          }
          update()
        }
      }
    }
  })

}

},{"../ad":"/Users/youzi/dev/mtv-play/components/ad/index.js","../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../loader":"/Users/youzi/dev/mtv-play/components/loader/index.js","../player":"/Users/youzi/dev/mtv-play/components/player/index.js","../popup":"/Users/youzi/dev/mtv-play/components/popup/index.js","./menu":"/Users/youzi/dev/mtv-play/components/first/menu/index.js","./miniplayer":"/Users/youzi/dev/mtv-play/components/first/miniplayer/index.js","./notification":"/Users/youzi/dev/mtv-play/components/first/notification/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/style.less","./switcher":"/Users/youzi/dev/mtv-play/components/first/switcher/index.js","./tv":"/Users/youzi/dev/mtv-play/components/first/tv/index.js","./watch":"/Users/youzi/dev/mtv-play/components/first/watch/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/events/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js"}],"/Users/youzi/dev/mtv-play/components/first/menu/casticon.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var Item = require( '../../item' )
var Img = require( '../../img' )
var Icon = require( '../../icon' )
var text = require( '../../text' )
var app = require( 'old-vigour-js/app/' )
var Loader = require( '../../loader' )

var DeviceNumber = new Element( {
  css: 'relative-size',
  text: app.user.devices.$length,
  display: 'relative',
  opacity: {
    val: 0,
    $isLoggedIn: 1
  }
} ).Class

module.exports = exports = new Element( {
  content: new Icon( {
    icon: 'cast',
    scale: {
      val: 1,
      animation: {
        start: 1,
        time: 18,
        easing: 'outCubic',
        done: function() {
          this.scale.val = 1
        }
      }
    },
    display: 'block',
    number: new DeviceNumber(),
    css: {
      $hasReceiver: 'ui-icon hasReceiver'
    },
    opacity: {
      val: 0.5,
      $hasDevices: {
        val: 0.5,
        $isLoggedIn: 1
      }
    },
    'events.click': function( e ) {
      e.prevent = true
      var popup = this.checkParent( 'on.popup', true )
      popup.from = 'devices'
    }
  } ),
  css: 'ui-icon cast',
  '!$connected': {
    content: {
      display: 'none'
    },
    loader: new Loader.Simple()
  }
} ).Class
},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../../loader":"/Users/youzi/dev/mtv-play/components/loader/index.js","../../text":"/Users/youzi/dev/mtv-play/components/text/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/first/menu/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var Icon = require('../../icon')
var text = require('../../text')
var cases = require('old-vigour-js/browser/cases')
var app = require('old-vigour-js/app/')
var CastIcon = require('./casticon')
var dictionary = require('old-vigour-js/app/dictionary')
var channelsText = dictionary.get('text.nav.television')
var showsText = dictionary.get('text.nav.shows')

function setPageFactory (page) {
  if (cases.phone) {
    return function () {
      this.checkParent('topmenu', true).hide()
      app.user.navigation.page.$userOrigin = page
    }
  } else if (cases.tablet) {
    return function () {
      this.checkParent('section', true).x = 0
      app.user.navigation.page.$userOrigin = page
    }
  } else {
    return function () {
      app.user.navigation.page.$userOrigin = page
    }
  }
}

// user.activeDevices
var Term = new text.Title({
  'events.click': function () {
    var popup = this.checkParent('on.popup', true).from
    popup.data = app.content.get([this._name, 'list', '0'])
    popup.val = 'article'
  },
  css: 'term'
}).Class

var MenuItems = new Element({
  append: [new Element({
    tv: {
      text: {
        data: 'page',
        transform: function (c, cv) {
          if (cv === this.name && app.focusState.val === 'menu') this.$focus()
          if (app.focusState.val !== 'menu' && this._$focused) this.$focus(false, true)
          return ''
        },
        listen: app.focusState
      },
      css: 'menu-item'
    },
    events: {
      arrowUp: function () {
        if (this.$prev.val) {
          this.$prev.val.events.click._val.call(this.$prev.val)
        }
      },
      arrowRight: function () {
        if (this.name !== 'settings') app.focusState.from.val = 'grid'
      },
      $focus: function (e) {
        if (e) {
          var menuitems = this.parent && this.parent.children,
            menuitem
          if (menuitems) {
            for (var i = menuitems.length - 1; i >= 0; i--) {
              menuitem = menuitems[i]
              if (menuitem !== this) {
                menuitem.css.val = 'menu-item'
              }
            }
            this.css.val = 'menu-item current'
          }
        }
      },
      arrowDown: function () {
        if (this.$next.val) {
          this.$next.val.events.click._val.call(this.$next.val)
        }
      }
    },
    '!tv': {
      css: {
        data: 'page',
        transform: function (v, cv) {
          // only if !focus or if focus is other menu item...doe later
          // if(cv === this.name &&  this.$focus) this.$focus()
          var unselected = 'menu-item',
            selected = unselected + ' current'
          if (typeof cv === 'string') return cv === this.name ? selected : unselected
          else if (this.name === 'shows') return selected
          else return unselected
        }
      },
      lefticon: new Icon()
    },
    title: {
      crawler: {
        node: 'a',
        attr: {
          onclick: 'return false'
        }
      }
    },
  // hier ff die dingen
  }).Class, {
    name: 'discover',
    '!tv.lefticon.icon': 'discover',
    'title.text.dictionary': 'text.nav.discover',
    'events.click': setPageFactory('discover'),
    'title.href': 'discover'
  }, {
    name: 'shows',
    '!tv.lefticon.icon': 'shows',
    'title.text.dictionary': 'text.nav.shows',
    'events.click': setPageFactory('shows'),
    'title.href': 'shows'
  }, {
    name: 'channels',
    '!tv.lefticon.icon': 'tv',
    'title.text.dictionary': 'text.nav.television',
    'events.click': setPageFactory('channels'),
    'title.href': 'channels'
  }, {
    name: 'settings',
    '!tv.lefticon.icon': 'settings',
    'title.text.dictionary': cases.tv ? 'text.account.signin.title' : 'text.nav.settings',
    'tv.display': {
      val: 'table',
      $isLoggedIn: 'none'
    },
    'events.click': function () {
      if (cases.tv) {
        this.$focus(true)
        var switcher = this.checkParent('switcher', true)
        if (switcher) switcher.on.signin.update()
      } else {
        this.checkParent('on.popup', true).from.val = 'settings'
      }
    }
  }]
}).Class

exports.Sidemenu = new Element({
  css: cases.tv ? {
    val: app.focusState,
    transform: function (v, cv) {
      var unfocus = cv !== 'menu' ? ' unfocus' : ''
      return 'first-menu first-sidemenu' + unfocus
    }
  } : 'first-menu first-sidemenu',
  'desktop.$fromMtvSite.linkback': {
    arrow: new Icon({
      icon: 'leftnav'
    }),
    title: {
      text: {
        dictionary: 'text.backlink'
      }
    },
    'events.click': function () {
      document.location.href = app.fromMtvSite
    }
  },
  '!tv.logo': new Icon({
    icon: 'logo'
  }),
  items: new MenuItems({
    y: {
      tv: app.h.val / 5 - 28
    }
  }),
  '!tv.bottom': {
    button: {
      display: {
        val: 'block',
        tv: 'none',
        $isUpgraded: 'none'
      },
      css: 'register',
      text: {
        dictionary: {
          val: 'text.account.signup.title',
          $isLoggedIn: 'text.upgrade'
        }
      },
      'events.click': function () {
        var popup = this.checkParent('on.popup', true)
        popup.from = !cases.$isLoggedIn.val ? 'register' : !cases.$isUpgraded.val && 'upgrade'
      }
    },
    login: {
      css: 'button',
      display: {
        val: 'block',
        $isLoggedIn: 'none'
      },
      text: {
        dictionary: 'text.account.signin.title'
      },
      'events.click': function () {
        var popup = this.checkParent('on.popup', true)
        popup.from = 'login'
      }
    },
    profile: {
      '!tv.icon': new Icon({
        y: -34,
        icon: {
          val: 'profile',
          transform: {
            val: function (c, cv) {
              if (app.user.profilepic.val) {
                return 'empty'
              }
            },
            listen: app.user.profilepic
          }
        }
      }),
      img: {
        background: {
          val: app.user.profilepic,
          display: {
            val: function () {
              return app.user.profilepic.val ? 'block' : 'none'
            },
            listen: app.user.profilepic
          }
        }
      },
      'events.click': function () {
        this.checkParent('on.popup', true).from.val = 'profile'
      }
    },
    '!tv.cast': new CastIcon({
      opacity: {
        '!phone': {
          '!$isLoggedIn': 0
        }
      }
    })
  },
  '!tv.terms': {
    display: {
      val: function () {
        if (app.h.val <= 600) return 'none'
        return 'block'
      },
      listen: app.h
    },
    imprint: new Term({
      'text.dictionary': 'text.imprint'
    }),
    privacy: new Term({
      'text.dictionary': 'text.privacy'
    }),
    terms: new Term({
      'text.dictionary': 'text.terms'
    })
  }
}).Class

function toggleMenu (e) {
  e.prevent = true
  if (cases.touch) {
    var data = this._d,
      onMenuLevel = data === void 0 || data && !data.__t

    if (onMenuLevel) {
      if (cases.phone) {
        var topMenu = this.checkParent('topmenu', true)
        topMenu.toggle()
      } else {
        var section = this.checkParent('section', true),
          expanded = section.x.val,
          caret = this.parent.caret,
          id = 'closeMenu'
        if (expanded) {
          section.x = 0
          caret.rotate = -90
        } else {
          section.x = 200
          caret.rotate = 90
          section.node.style.pointerEvents = 'none'
          app.addEvent('click', function (e) {
            section.x = 0
            caret.rotate = -90
            app.removeEvent(false, id)
            section.node.style.pointerEvents = 'auto'
          }, id)
        }
      }
    } else {
      this.checkParent('switcher', true).back()
    }
  } else {
    var section = this.checkParent('section', true),
      expanded = section.x.val,
      caret = this.parent.caret,
      id = 'closeMenu'

    if (expanded) {
      app.menu.val = false
      section.x.update()
      caret.rotate = -90
    } else {
      app.menu.val = true
      caret.rotate = 90
      section.x.update()
      section.node.style.pointerEvents = 'none'
      app.addEvent('click', function (e) {
        app.menu.val = false
        section.x.update()
        caret.rotate = -90
        app.removeEvent(false, id)
        section.node.style.pointerEvents = 'auto'
      }, id)
    }
  }
}

exports.Topbar = new Element({
  css: 'first-menu first-topbar',
  on: {
    page: {
      defer: function (update, args) {
        var topbar = this._parent._caller,
          title = this.from.val,
          css = 'first-menu first-topbar toplevel'

        if (title === 'discover') {
          topbar.css = css + ' logo'
          topbar.holder.title.text.val = {
            transform: '\ue61b'
          }
        } else {
          topbar.css = css
          topbar.holder.title.text.val = {
            transform: title === 'channels' ? channelsText : showsText
          }
        }

        topbar.data = {
          title: title,
          icon: title
        }

        update()
      }
    },
    show: {
      defer: function (update, args) {
        var topbar = this._parent._caller,
          topmenu = topbar.parent.topmenu

        topbar.holder.title.text.val = {
          transform: false
        }
        topbar.data = this.from.val
        topbar.css = 'first-menu first-topbar'
        update()
      }
    },
    media: {
      defer: function (update, args) {
        var topbar = this._parent._caller
        var topmenu = topbar.parent.topmenu

        topbar.holder.title.text.val = {
          transform: false
        }

        topbar.data = this.from.val
        topbar.css = 'first-menu first-topbar'
        update()
      }
    },
    $parent: function (update, args) {
      update()
    }
  },
  h: {
    val: 40,
    iosFull: 60
  },
  holder: {
    lefticon: new Icon({
      icon: cases.desktop ? 'menu' : {
        data: 'title',
        transform: cases.phone ? function (v, cv) {
          var data = this._d,
            onMenuLevel = data && !data.__t
          if (data === void 0) return 'menu'
          if (onMenuLevel) return cv === 'channels' ? 'tv' : cv
          else return 'arrowleft'
        } : function (v, cv) {
          var data = this._d,
            onMenuLevel = data && !data.__t
          if (onMenuLevel) return 'menu'
          else return 'arrowleft'
        }
      },
      'events.click': toggleMenu
    }),
    caret: new Icon({
      icon: 'dropdown',
      '!phone': {
        rotate: -90
      },
      'events.click': toggleMenu
    }),
    title: {
      text: {
        data: 'title',
        default: ''
      }
    },
    righticon: new CastIcon()
  },
  'events.click': function (e) {
    e.prevent = true

    var data = this._d,
      onMenuLevel = data === void 0 || data && !data.__t

    if (onMenuLevel && cases.touch) {
      var lefticon = this.holder.lefticon
      lefticon.events.click._val.call(lefticon, e)
    }
  }
}).Class

exports.Topmenu = new Element({
  css: 'first-menu first-topmenu',
  position: 'absolute',
  h: {
    parent: 'h',
    sub: exports.Topbar.base.h
  },
  on: {
    menu: {
      defer: function (update, args) {
        var caller = this._parent._caller
        this.clearCache()
        if (this.val) {
          caller.show()
        } else {
          caller.hide()
        }
        update()
      }
    },
    $render: {
      defer: function (update) {
        this._parent.menu._update()
        update()
      }
    }
  },
  y: {
    translate: true,
    val: -app.h.val,
    add: exports.Topbar.base.h
  },
  bottom: {
    position: 'absolute',
    y: 256,
    h: {
      parent: 'h',
      sub: 256
    },
    terms: {
      imprint: new Term({
        'text.dictionary': 'text.imprint'
      }),
      privacy: new Term({
        'text.dictionary': 'text.privacy'
      }),
      terms: new Term({
        'text.dictionary': 'text.terms'
      })
    }
  },
  top: {
    items: new MenuItems(),
    account: {
      css: 'menu-item',
      left: {
        css: {
          val: 'profile', // change on cases!
          $isUpgraded: '$isUpgraded'
        },
        picture: {
          display: {
            val: 'none',
            $isLoggedIn: 'block'
          },
          icon: new Icon({
            icon: {
              val: 'profile',
              transform: {
                val: function (c, cv) {
                  if (app.user.profilepic.val) {
                    return 'empty'
                  }
                },
                listen: app.user.profilepic
              }
            }
          }),
          img: {
            background: {
              val: app.user.profilepic,
              display: {
                val: function () {
                  return app.user.profilepic.val ? 'block' : 'none'
                },
                listen: app.user.profilepic
              }
            }
          }
        },
        text: {
          dictionary: {
            val: 'text.account.signin.title',
            $isLoggedIn: 'text.profile'
          }
        },
        'events.click': function () {
          var popup = this.checkParent('on.popup', true)
          popup.from = cases.$isLoggedIn.val ? 'profile' : 'login'
        }
      },
      right: {
        css: {
          val: 'register',
          $isLoggedIn: 'upgrade'
        },
        display: {
          val: 'table-cell',
          $isUpgraded: 'none'
        },
        text: {
          dictionary: {
            val: 'text.account.signup.title',
            $isLoggedIn: 'text.upgrade'
          }
        },
        'events.click': function () {
          var popup = this.checkParent('on.popup', true)
          popup.from = cases.$isLoggedIn.val ? 'upgrade' : 'register'
        }
      }
    }
  }
}).Class

exports.Topmenu.base.define({
  hide: function () {
    this.y = -this.h.val
    if (this.parent.topbar.holder) {
      this.parent.topbar.holder.caret.rotate = 0
    } else {
      console.error('!ERROR this.parent.topbar.holder.caret', this)
    }
  },
  show: function () {
    this.y = 0
    this.parent.topbar.holder.caret.rotate = 180
  },
  toggle: function () {
    var menuDown = this.y.val < 0
    if (menuDown) this.show()
    else this.hide()
  }
})

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../text":"/Users/youzi/dev/mtv-play/components/text/index.js","./casticon":"/Users/youzi/dev/mtv-play/components/first/menu/casticon.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/menu/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/menu/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/miniplayer/index.js":[function(require,module,exports){
require( './style.less' )

var Icon = require( '../../icon' )
var Img = require( '../../img' )
var app = require( 'old-vigour-js/app/' )
var Element = require( 'old-vigour-js/app/ui/element' )
var Controls = require( '../../player/controls' )
var Volume = require( '../../player/volume' )
var cases = require( 'old-vigour-js/browser/cases' )

function setVol( e ) {
  var rect = this.node.getBoundingClientRect()
  var x = rect.left
  var nr = ( e.x - x ) / ( rect.right - x )

  app.user.receiver.volume.from.val = nr > 1 ? 1 : nr < 0 ? 0 : nr
}

var play = new Icon( {
  icon: {
    val: false,
    transform: function( v, cv ) {
      return cv ? 'pause' : 'play'
    }
  },
  'events.click': function( e ) {
    e.prevent = true
    var play = this.checkParent( 'on.play', true ).from
    play.val = play.val ? false : true
  }
} )

module.exports = new Element( {
  css: 'mini-player',
  position: 'absolute',
  on: {
    msmedia: {
      defer: function( update ) {
        var parent = this._parent
        var caller = parent._caller
        var msMedia = this.$userOrigin
        var isChannel = msMedia.val && msMedia.from._parent._name === 'channels'

        if( msMedia.val ) {
          caller.data = {
            media: msMedia,
            mediausage: parent.usage.from.get( msMedia.from._contentPath ),
            volume: parent.volume.from
          }

        }

        caller.y = msMedia.val ? ( cases.phone && isChannel ) ? 24 : 0 : cases.phone ? 58 + 24 : 58


        if( !cases.phone ) {
          var controlsStyle = caller.controls.node.style
          if( isChannel ) {
            controlsStyle.visibility = 'hidden';
            controlsStyle.pointerEvents = 'none';
          } else {
            controlsStyle.visibility = 'visible';
            controlsStyle.pointerEvents = 'auto ';
          }
        }

        update()
      }
    }
  },
  y: {
    translate: true,
    val: cases.phone ? 58 + 24 : 58,
    animation: {
      time: 18,
      easing: 'outCubic'
    },
    transform: function( v, cv ) {
      return !cases.$hasReceiver.val ? cases.phone ? 58 + 24 : 58 : cv
    },
    listen: cases.$hasReceiver
  },
  clickable: {
    img: new Img( {
      background: {
        data: 'media.img'
      },
      h: 58,
      w: {
        val: 115,
        phone: 58
      }
    } ),
    info: {
      title: {
        text: {
          data: 'media.show.title',
          default: {
            dictionary: 'text.nowOnTv'
          }
        }
      },
      subtitle: {
        text: {
          data: 'media.title'
        }
      }
    },
    events: {
      click: function() {
        var msMedia = this.parent.data.media.from,
          navigation = this.checkParent( 'on.navigation._val', true )
        navigation.media.$userOrigin = msMedia
      }
    }
  },
  'phone': {
    slider: new Icon( {
      icon: 'volume',
      'events.click': function( e ) {
        e.prevent = true
        var firstScreen = this.checkParent( 'section', true )
        if( !firstScreen.volumepopup ) {
          firstScreen.set( {
            volumepopup: {
              h: app.h,
              modal: {
                css: 'move-in',
                title: {
                  text: 'volume'
                },
                bar: {
                  css: 'ui-seekbar',
                  bg: {},
                  seek: {
                    w: {
                      data: 'volume',
                      transform: function( v, cv ) {
                        cv = isNaN( cv ) || ( !cv && cv !== 0 ) ? 1 : cv
                        return Math.abs( cv ) * 100 + '%'
                      }
                    },
                    data: app.user.receiver
                  },
                  button: {},
                  events: {
                    down: setVol,
                    drag: setVol,
                    up: setVol
                  }
                },
                done: {
                  text: 'done',
                  events: {
                    click: function() {
                      firstScreen.volumepopup.remove()
                    }
                  }
                },
                events: {
                  click: function( e ) {
                    e.prevent = true
                  }
                }
              },
              events: {
                click: function() {
                  firstScreen.volumepopup.remove()
                }
              }
            }
          } )

        } else {
          firstScreen.volumepopup.remove()
        }
      }
    } )
  },
  play: play,
  controls: new Controls(),
  '!phone': {
    volume: new Volume( {
      bars: {
        data: 'volume'
      }
    } )
  },
  model: {
    subscription: {
      epgid: true
    }
  }
} ).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../../player/controls":"/Users/youzi/dev/mtv-play/components/player/controls/index.js","../../player/volume":"/Users/youzi/dev/mtv-play/components/player/volume/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/miniplayer/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/miniplayer/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/notification/config.js":[function(require,module,exports){
module.exports = {
  timeout: 10000,
  map:

  //FAVORITE

  {
    favourite: {
      lefticon: {
        icon: 'favoriteadd',
        css: {
          addClass: 'favorite'
        }
      },
      css: {
        addClass: 'success'
      },
      txt: {
        title: {
          text: {
            dictionary: 'text.favoriteAdded'
          }
        }
      }
    },
    unfavourite: {
      lefticon: {
        icon: 'favoriteremove',
        css: {
          addClass: 'unfavorite'
        }
      },
      css: {
        addClass: 'error'
      },
      txt: {
        title: {
          text: {
            dictionary: 'text.favoriteRemoved'
          }
        }
      }
    }

    //LOGIN

    , loginSuccess: {
      lefticon: {
        icon: 'right'
      },
      css: {
        addClass: 'success'
      },
      txt: {
        title: {
          text: {
            dictionary: 'text.account.signin.success'
          }
        }
      }
    },
    loginError: {
      lefticon: {
        icon: 'wrong'
      },
      css: {
        addClass: 'error'
      },
      txt: {
        title: {
          text: {
            dictionary: 'text.account.signin.wrong'
          }
        }
      }
    },
    facebookError: {
      lefticon: {
        icon: 'facebook'
      },
      css: {
        addClass: 'error'
      },
      txt: {
        title: {
          text: {
            dictionary: 'text.account.signin.facebookError'
          }
        }
      }
    }

    //REGISTER

    ,
    registerSuccess: {
      lefticon: {
        icon: 'email'
      },
      css: {
        addClass: ''
      },
      duration: 50e4,
      txt: {
        title: {
          text: {
            dictionary: 'text.verifyEmail.title'
          }
        },
        subtitle: {
          text: {
            dictionary: 'text.verifyEmail.subtitle'
          }
        }
      }
    },
    email: {
      'txt.title.text.dictionary': 'text.account.invalid.email'
    },
    emailExists: {
      'txt.title.text.dictionary': 'text.account.signup.already'
    },
    registerError: {
      'txt.title.text.dictionary': 'text.account.signin.wrong'
    },
    registerErrorExists: {
      'txt.title.text.dictionary': 'text.account.signup.already'
    },
    registerErrorInvalid: {
      'txt.title.text.dictionary': 'text.account.signin.wrong'
    },
    blankEmail: {
      'txt.title.text.dictionary': 'text.account.signin.wrong'
    },
    password: {
      'txt.title.text.dictionary': 'text.account.passwordResetError'
    },
    passwordShort: {
      'txt.title.text.dictionary': 'text.account.invalid.password'
    },
    noMatchPassword: {
      'txt.title.text.dictionary': 'text.noMatchPassword'
    }

    //VERIFY EMAIL

    ,
    verifyEmailSuccess: {
      lefticon: {
        icon: 'email'
      },
      css: {
        addClass: 'success'
      },
      duration: 50e4,
      txt: {
        title: {
          text: {
            dictionary: 'text.account.verifyEmailSuccess.title'
          }
        },
        subtitle: {
          text: {
            dictionary: 'text.account.verifyEmailSuccess.subtitle'
          }
        }
      }
    }

    ,
    verifyEmailError: {
      lefticon: {
        icon: 'wrong'
      },
      css: {
        addClass: 'error'
      },
      txt: {
        title: {
          text: {
            dictionary: 'text.account.verifyEmailError'
          }
        }
      }
    }

    //VERIFY OPERATOR ERRORS

    ,
    operatorUpgradeError: {
      lefticon: {
        icon: 'wrong'
      },
      css: {
        addClass: 'error'
      },
      txt: {
        title: {
          text: {
            dictionary:  'text.operator.credentials.wrong'
          }
        }
      }
    }


    //NEW VERSION AVAILABLE

    ,
    appUpgrade: {
      lefticon: {
        icon: 'warning'
      },
      duration: 50e7,
      txt: {
        title: {
          text: {
            dictionary: 'text.versionAvailable'
          }
        },
        'events.click': function( e ) {
          window.location.reload();
        }
      }
    }

    //CONNECTIVITY

    ,
    enable4g: {
      txt: {
        title: {
          text: {
            dictionary: 'modal.warning.cellular.title'
          }
        },
        subtitle: {
          text: {
            dictionary: 'modal.warning.cellular.subtitle'
          }
        }
      }
    }

    //PASSWORD RESET

    ,
    passwordForgot: {
      'txt.title.text.dictionary': 'text.account.forgot.success'
    },
    passwordForgotError: {
      'txt.title.text.dictionary': 'text.account.forgot.wrong'
    },
    passwordReset: {
      'txt.title.text.dictionary': 'text.account.passwordReset'
    },
    passwordResetError: {
      'txt.title.text.dictionary': 'text.account.passwordResetError'
    },
    invalidPasswordToken: {
      'txt.title.text.dictionary': 'text.account.passwordResetError'
    },
    resetTokenExpired: {
      'txt.title.text.dictionary': 'text.account.passwordResetError'
    }

    //SHARE

    ,
    shareSuccess: {
      'txt.title.text.dictionary': 'share.success'
    },
    shareError: {
      'txt.title.text.dictionary': 'share.failed'
    }

    //MTV MOBILE NUMBER VERIFICATION

    ,
    mobileUpgradeSuccess: {
      'txt.title.text.dictionary': 'text.hoorayMobileTitle'
    },
    mobileUpgradeError: {
      'txt.title.text.dictionary': 'modal.warning.unabletoverify'
    },
    mobileVerifySuccess: {
      'txt.title.text.dictionary': 'text.verifysuccess'
    },
    mobileVerifyError: {
      'txt.title.text.dictionary': 'text.verifyfail'
    },
    invalidNumber: {
      'txt.title.text.dictionary': 'text.verifyfail'
    },
    numberExists: {
      'txt.title.text.dictionary': 'text.verifytaken'
    }

    //UPGRADE

    ,
    purchaseError: {
      'txt.title.text.dictionary': 'text.account.purchaseError'
    },
    upgraded: {
      'txt.title.text.dictionary': 'text.upgradedMessage'
    },
    subscription: {
      'txt.title.text.dictionary': 'text.account.purchaseError'
    },
    singleEpisodePurchased: {
      'txt.title.text.dictionary': 'singleEpisodePurchased'
    }

    //MISC

    ,
    invalid: {
      lefticon: {
        icon: 'wrong'
      },
      css: {
        addClass: 'error'
      },
      txt: {
        title: {
          text: {
            dictionary: 'text.invalidEntry'
          }
        }
      }
    }

    ,
    expired: {
      'txt.title.text.dictionary': 'text.invalidEntry'
    },
    terms: {
      'txt.title.text.dictionary': 'text.invalidEntry'
    },
    privacy: {
      'txt.title.text.dictionary': 'text.invalidEntry'
    },
    invalidEmail: {
      'txt.title.text.dictionary': 'text.account.forgot.wrong'
    },
    mobileTimeout: {
      'txt.title.text.dictionary': 'text.mobileTimeout'
    }

  }
}

},{}],"/Users/youzi/dev/mtv-play/components/first/notification/index.js":[function(require,module,exports){
require('./style.less')

var Icon = require('../../icon')
var Item = require('../../item')
var Switcher = require('old-vigour-js/app/ui/switcher')
var config = require('./config')
var cases = require('old-vigour-js/browser/cases')

var map = config.map

var Notification = new Item({
  on: {
    $remove: {
      defer: function (update) {
        var caller = this._parent._caller
        if (caller._timer) clearTimeout(caller._timer)
        update()
      }
    }
  },
  position: 'absolute',
  y: {
    val: 40,
    iosFull: 64,
    animation: {
      start: 0,
      time: 18,
      easing: 'outCubic',
      complete: function () {
        var duration = this.duration
        if (duration) {
          var _this = this
          if (this._timer) clearTimeout(this._timer)
          this._timer = setTimeout(function () {
            // clear deze timeout
            if (_this && _this.parent) {
              _this.parent.remove()
              _this.css = {
                addClass: 'fade-out'
              }
            }
            this._timer = null

          }, duration)
        }
      }
    }
  },
  lefticon: new Icon({
    icon: 'warning'
  }),
  txt: {
    title: {
      text: ''
    },
    subtitle: {
      text: {
        val: '',
        defer: function (update) {
          this._caller.display = this._val ? 'block' : 'none'
          update()
        }
      }
    }
  },
  'events.click': function () {
    var notification = this.checkParent('on.notification', true).from
    notification.val = false
  },
  righticon: new Icon({
    icon: 'close',
    events: {
      click: function (e) {
        e.prevent = true
        var notification = this.checkParent('on.notification', true).from
        notification.val = false
      }
    }
  })
}).Class

module.exports = new Switcher({
  css: 'first-notification',
  y: {
    val: -40,
    iosFull: -64
  },
  iosFull: {},
  on: {
    notification: {
      defer: function (update, args) {
        var caller = this._parent._caller,
          from = this.from,
          val = from.val,
          type

        if (val === 'appUpgrade' && !cases.native) {
          update()
          return
        }

        if (args[0] === false) {
          var child = caller.node.childNodes[caller.node.childNodes.length - 1].base
          child.css = {
            addClass: 'fade-out'
          }
          child._timer = setTimeout(function () {
            caller.remove()
          }, 500)
        } else {
          type = from.type

          if (type && type !== 'api') {
            val = type
            from.type = null
          }

          var duration = (map[val] && map[val].duration) || config.timeout

          caller.transition = {
            element: Notification,
            $params: map[val] || {
                txt: {
                  title: {
                    text: val
                  }
                }
            },
            $options: {
              force: true,
              duration: duration
            }
          }

          if(this._timer){
            clearTimeout(this._timer)
            this._timer = null
          }
          setTimeout(function(){
            if(from.val === val){
              from.val = false
            }
            this._timer = null
          },duration)

        }
        update()
      }
    }
  },
  onTransition: function (current, last, direction, options) {
    this.add(current)
    current.duration = options.duration
    if (last) last.css = {
        addClass: 'fade-out'
      }
  }
}).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../item":"/Users/youzi/dev/mtv-play/components/item/index.js","./config":"/Users/youzi/dev/mtv-play/components/first/notification/config.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/notification/style.less","old-vigour-js/app/ui/switcher":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/notification/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/overview/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var Item = require('./item')
var BillboardAd = require('../../ad').Billboard

module.exports = exports = new Element({
  css: 'first-overview',
  'touch.scrollbar': 'y',
  x: {
    translate: true
  },
  '!phone.ad': new BillboardAd({
    attr: {
      id: 'leaderboard'
    }
  })
}).Class

exports.Items = new Element({
  pageheader: {}
}).Class

exports.Item = Item

},{"../../ad":"/Users/youzi/dev/mtv-play/components/ad/index.js","./item":"/Users/youzi/dev/mtv-play/components/first/overview/item.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/overview/style.less","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/first/overview/item.js":[function(require,module,exports){
require( './style.less' )

var app = require( 'old-vigour-js/app/' )
var Element = require( 'old-vigour-js/app/ui/element' )
var Icon = require( '../../icon' )
var Img = require( '../../img' )
var cases = require( 'old-vigour-js/browser/cases' )
var epgData = require( '../../epg_temp' )
var itm = require( '../../item' )
var Seekbar = require( '../../player/seekbar' )
var TitleSubtitle = itm.TitleSubtitle
var clockTime = epgData.clockTime
var dictionary = require( 'old-vigour-js/app/dictionary' )
  //--------------- elements -----------------

var item =
  cases.touch ? new itm.Thumb( {
    display: 'table'
  } ) : new itm.Large( {
    display: 'inline-block'
  } )

if( !cases.slow ) {;
  ( cases.touch ? item.thumb.img : item.thumb ).background = {
    load: function( t ) {
      t.opacity = 1
    }
  }
}

module.exports = exports = item.set( {
  events: {
    active: 'ui-item-clicked'
  }
} ).Class

if( !cases.touch ) {

  var noEPG = dictionary.get( 'text.noEPG' )

  exports.Tv = new Element( {
    css: 'ui-item-large tv',
    display: 'inline-block',
    thumb: new Img.Overlay( {
      w: 310,
      h: 221,
      access: new Icon( {
        on: {
          data: 'id'
        },
        icon: {
          data: 'access',
          transform: function( val, cv ) {
            var access = app.util.access( cv, this.data )
            return access === 'playAlt' ? 'empty' : access
          },
          listen: app.user.role
        }
      } )
    } ),
    info: {
      title: {
        css: 'ui-item-text',
        text: {
          data: 'title'
        }
      },
      'now.text.dictionary': 'text.now',
      epg: {
        showtitle: {
          text: {
            data: 'title'
          }
        },
        time: {
          text: {
            val: {
              data: 'minutes_since_midnight',
              transform: clockTime,
              add: [ ' - ', {
                data: 'endtime',
                transform: clockTime
              } ]
            },
            transform: function( v, cv ) {
              var data = this.data
              return data && data.val ? cv : noEPG.val
            },
            listen: dictionary
          }
        },
        bar: new Seekbar( {
          w: {
            val: 221,
            clear: true
          },
          seek: {
            w: {
              val: 221,
              multiply: {
                val: epgData.minutesSinceMidnight,
                sub: {
                  data: 'minutes_since_midnight'
                },
                divide: {
                  data: 'duration'
                }
              },
              clear: true
            }
          },
          button: false
        } ),
        model: {
          inherit: false
        }
      }
    },
    model: {
      subscription: {
        epgid: true
      },
      val: function( data ) {
        var epgid = data.epgid && data.epgid.val
        if( epgid !== void 0 ) {
          this.info.epg.data = epgData.now( epgid )
          this.model = false
        }
      }
    },
    events: {
      click: function() {
        this.checkParent( 'on.media', true ).$userOrigin = this.data.from
      }
    }
  } ).Class
}

},{"../../epg_temp":"/Users/youzi/dev/mtv-play/components/epg_temp.js","../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../../player/seekbar":"/Users/youzi/dev/mtv-play/components/player/seekbar/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/overview/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/overview/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/seasons/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var Icon = require( '../../icon' )
var Img = require( '../../img' )
var text = require( '../../text' )
var Favourite = require( '../favourite' )
var app = require( 'old-vigour-js/app/' )
var cases = require( 'old-vigour-js/browser/cases' )
var _dropDownEventId = 'dropDownEventId'
var dictionary = require( 'old-vigour-js/app/dictionary' )

var seasonText = dictionary.get( 'text.season' )
var episodeText = dictionary.get( 'text.episode' )
var minText = dictionary.get( 'text.min' )
var specialsText = dictionary.get( 'text.specials' )

var EpisodeList = new Element( {
  collection: {
    data: 'season.episodes',
    filter: true,
    element: new Element( {
      model: function( data ) {
        var path = data._contentPath
        if( path && !~path.indexOf( 'channels' ) ) {
          this.holder.thumb.cover.data = app.user.usage.from.get( path )
          this.model = false
        }
      },
      holder: {
        crawler: {
          node: 'a',
          href: {
            data: function( data ) {
              return app.user.$parse(data).url || ''
            }
          },
          attr: {
            onclick: 'return false'
          }
        },
        thumb: {
          w: 100,
          img: new Img( {
            w: 100,
            h: 100 * 3 / 4
          } ),
          cover: {
            y: cases.desktop ? -100 * 3 / 4 : -5,
            h: cases.desktop ? 100 * 3 / 4 : 5,
            model: {
              inherit: false
            },
            desktop: {
              percentage: {
                text: {
                  data: 'time',
                  transform: function( v, cv ) {
                    var p = Math.floor( cv * 100 )
                    return p ? Math.abs( p ) + '%' : ''
                  }
                }
              }
            },
            bar: {
              w: {
                data: 'time',
                transform: function( v, cv ) {
                  return !isNaN( cv ) ? Math.abs( cv ) * 100 : 0
                }
              }
            }
          }
        },
        txt: {
          title: new text.Title(),
          subtitle: {
            text: {
              data: 'number',
              transform: function( v, cv ) {
                return cv > 9000 ? '' : episodeText.val + ' ' + cv + ' - '
              },
              add: {
                data: 'duration',
                transform: function( v, cv ) {
                  return cv ? ~~( cv / 60 ) + ' ' + minText.val : ''
                },
                listen: dictionary
              }
            }
          }
        },
        righticon: new Icon( {
          on: {
            data: 'id'
          },
          icon: {
            data: 'access',
            transform: function( val, cv ) {
              var access = app.util.access( cv, this.data )
              var icon = access === 'playAlt' ? cases.desktop ? 'empty' : 'arrowright' : access
              return icon === 'lockedContent' ? 'lockedContentAlt' : icon
            },
            listen: [ app.user.role, app.user.purchases ]
          }
        } )
      },
      border: {},
      'events.click': function() {
        app.user.navigation.media.$userOrigin = this.data.from
      }
    } )
  }
} ).Class

module.exports = new Element( {
  on: {
    media: {
      defer: function( update, args ) {
        var data = app.user.navigation.media.from.val
        if( data ) {
          var caller = this._parent._caller,
            current = caller.list.find( 'data', data )
          if( current && !current.css.val ) {
            if( caller.prev ) caller.prev.css = false
            current.css = 'current'
            caller.prev = current
          }
        }
        update()
      }
    }
  },
  title: {
    text: {
      val: {
        dictionary: 'text.episodes'
      },
      tablet: {
        data: 'show.title'
      }
    }
  },
  tablet: {
    favourite: new Favourite()
  },
  list: {
    tablet: {
      scrollbar: 'y',
      h: {
        val: app.h,
        sub: {
          val: 99,
          iosFull: 119
        }
      }
    },
    eps: new EpisodeList( {
      display:{
        val:true,
        transform:function( v,cv ){
          return cv === false ? 'none' : 'block'
        }
      },
      model: {
        complete: function( data ) {
          this.parent && this.parent.parent.on.media._update()
        }
      }
    } ),
    extrasHeader: {
      display: {
        data: 'season.extras',
        transform: function( v, cv ) {
          return cv && cv[ 0 ] ? 'block' : 'none'
        }
      },
      text: {
        dictionary: 'text.extras'
      }
    },
    extras: new EpisodeList( {
      collection: {
        data: 'season.extras'
      }
    } )
  },
  dropdown: {
    h: 30,
    on: {
      $remove: {
        defer: function( update ) {
          app.removeEvent( false, _dropDownEventId )
          update()
        }
      }
    },
    current: {
      text: {
        data: 'season.number',
        transform: function( v, cv ) {
          return cv !== 9000 ? seasonText.val + ' ' + cv : specialsText.val
        },
        listen: dictionary
      },
      caret: new Icon( {
        icon: 'dropdown'
      } )
    },
    collection: {
      data: 'show.seasons',
      filter: true,
      element: new Element( {
        crawler: {
          node: 'a',
          attr: {
            onclick: 'return false'
          },
          href: {
            data: function( data ) {
              return 'shows/' + data._parent._parent._name + '/' + data.number + '/1' || ''
            }
          },
          attr: {
            onclick: 'return false'
          }
        },
        text: {
          data: 'number',
          transform: function( v, cv ) {
            return cv !== 9000 ? seasonText.val + ' ' + cv : specialsText.val
          },
          listen: dictionary
        },
        'events.click': function() {
          var seasondata = this.data.from
          app.user.navigation.season.$userOrigin = seasondata
          seasondata.get('episodes')
        }
      } )
    },
    'events.click': function() {
      var length = this.children.length,
        _this = this
      if( this.h.val === 30 && length > 2 ) {
        this.h = length * 30 + 4
        app.addEvent( 'click', function() {
          if( _this.h ) _this.h = 30
          app.removeEvent( false, _dropDownEventId )
        }, _dropDownEventId )
      } else {
        this.h = 30
      }
    },
    'model.complete': function() {
      if( this.children.length <= 2 ) {
        this.css = {
          addClass: 'inactive'
        }
      } else {
        this.css = {
          removeClass: 'inactive'
        }
      }
    }
  },
  model: function( data ) {
    if( data.media ) this.model = false
  }
} ).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../../text":"/Users/youzi/dev/mtv-play/components/text/index.js","../favourite":"/Users/youzi/dev/mtv-play/components/first/favourite/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/seasons/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/seasons/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/show/cover.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
require( './style.less' )
var Img = require( '../../img' )
var TitleSubtitle = require( '../../text' ).TitleSubtitle
var Element = require( 'old-vigour-js/app/ui/element' )
var cases = require( 'old-vigour-js/browser/cases' )
var switcher = require( './switcher' )
var Favourite = require( '../favourite' )
var app = require( 'old-vigour-js/app/' )

var cover = new Img( {
  background: {
    data: 'show.img'
  },
  h: {
    val: 220,
    ios: {
      animation: {
        time: 24,
        easing: 'outCubic'
      }
    }
  },
  w: {
    parent: 'w'
  },
  info: {
    position: 'absolute',
    y: {
      translate: true
    },
    opacity: {
      parent: 'h',
      transform: function( v, cv ) {
        return 440 / cv - 1
      }
    },
    box: {
      star: new Favourite(),
      description: {
        model: {
          subscription: {
            description: true
          }
        },
        text: {
          data: 'show.description',
          transform: function( v, cv ) {
            if( !cv.length ) return cv
            var str = cv.slice( 0, 300 ),
              lastDot = Math.max( Math.max( str.lastIndexOf( '.' ), str.lastIndexOf( '!' ) ), str.lastIndexOf( '?' ) )

            return ~lastDot ? str.slice( 0, lastDot + 1 ) : str + '..'
          }
        }
      }
    }
  }
} ).Class

module.exports = exports = cover

},{"../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../../text":"/Users/youzi/dev/mtv-play/components/text/index.js","../favourite":"/Users/youzi/dev/mtv-play/components/first/favourite/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/show/style.less","./switcher":"/Users/youzi/dev/mtv-play/components/first/show/switcher.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/show/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require( './style.less' )

var cases = require( 'old-vigour-js/browser/cases' )

if( cases.phone ) {
  var Element = require( 'old-vigour-js/app/ui/element' )
  var Switcher = require( './switcher' )
  var List = require( './list' )
  var Cover = require( './cover' )
  var events = require( 'old-vigour-js/browser/events' )
  var cases = require( 'old-vigour-js/browser/cases' )
  var app = require( 'old-vigour-js/app/' )
  var doc = events.document
  var scroll
  var overviewItem = require( '../overview/item' )
  var favourite = require( '../favourite' )
  var Mtvplayer = require( '../../player' )

  var show = new Element( {
    css: 'show',
    x: {
      translate: true
    },
    model: function( data ) {
      if( data.show ) {
        var path = data.show._cachedPath
        if( path ) {
          if( exports.state && exports.state.path === path ) {
            this.set( exports.state.params )
          }
          this.model = false
        }
      }
    },
    on: {
      $remove: {
        defer: function( update ) { //TODO do this on the children >>> this is not reliable
          var caller = this._parent._caller
          exports.state = {
            path: caller.data.show && caller.data.show._cachedPath,
            params: {
              cover: {
                h: caller.cover.h.val
              },
              switcher: {
                y: caller.switcher.y.val
              }
            }
          }
          update()
        }
      },
      season: {
        defer: function( update ) {
          var caller = this._parent._caller
          var seasondata = this._val.from

          Switcher.set( caller.switcher, seasondata._parent, seasondata._name )
          update()
        }
      }
    },
    phone: {
      cover: new Cover()
    },
    desktop: {
      header: {
        css: 'ui-header',
        append: new Element( {
          text: {
            data: 'title'
          },
          display: 'inline'
        } ),
        star: favourite
      }
    },
    switcher: new Switcher( {
      w: app.w
    } ),
    events: {
      down: cases.ios ? function( e ) {
        var _this = this,
          _cover = _this.cover,
          id = 'seasonmove',
          coverHeight = _cover.h.val,
          currentList = this.switcher._currentList,
          inScroll = currentList.node.scrollTop > 1

        _this._y = e.y
        _cover.h._p = true

        _this.addEvent( 'move', function( e ) {
          var y = e.y
          var x = e.x
          var yDiff = _this._y - y
          var scrolling = !coverHeight && yDiff > 0 || inScroll

          if( !Switcher.block && !inScroll && Math.abs( _this._x - x ) < Math.abs( yDiff ) ) //if y move is bigger than x move
          {
            events.click.block = true
            _cover.h = _cover.h.val - yDiff
          }

          if( !scrolling ) {
            e.preventDefault()
          }

          _this._y = y
          _this._x = x
        }, id )

        _this.addEvent( 'up', function() {
          events.click.block = false
          _cover.h._p = false
          _cover.h = _cover.h.val > 220 / 2 ? 220 : 0
          _this._y = null
          _this._x = null
          _this.removeEvent( false, id )

        }, id )
      } : cases.slow ? function( e ) {
        var _this = this
        var _cover = _this.cover
        var id = 'seasonmove'
        var _switcher = this.switcher
        var downPosition = _switcher.y.val !== -220
        var currentList = _switcher._currentList
        var style = currentList.node.style
        var inScroll = currentList.node.scrollTop > 1

        _this._y = e.y
        _switcher.y._p = true

        _this.addEvent( 'move', function( e ) {
          var y = e.y,
            x = e.x,
            yDiff = _this._y - y,
            scrolling = !downPosition && yDiff > 0 || inScroll

          if( !Switcher.block && !inScroll && Math.abs( _this._x - x ) < Math.abs( yDiff ) ) //if y move is bigger than x move
          {
            events.click.block = true
            if( yDiff > 0 ) _switcher.y.val = -220
            else _switcher.y = 0
            clearEvent()
          }

          if( !scrolling ) {
            style.overflow = 'hidden'
            e.preventDefault()
          } else {
            style.overflow = 'scroll'
          }

          _this._y = y
          _this._x = x
        }, id )

        _this.addEvent( 'up', clearEvent, id )

        function clearEvent() {
          events.click.block = false
          _switcher.y._p = false
          _this._y = null
          _this._x = null
          _this.removeEvent( false, id )
        }
      } : function( e ) {
        var _this = this
        var _cover = _this.cover
        var id = 'seasonmove'
        var _switcher = this.switcher
        var downPosition = _switcher.y.val !== -220
        var currentList = _switcher._currentList
        var inScroll = currentList.node.scrollTop > 1
        var switcherY

        _this._y = e.y
        _switcher.y._p = true

        _this.addEvent( 'move', function( e ) {
          var y = e.y
          var x = e.x
          var yDiff = _this._y - y
          var scrolling = !downPosition && yDiff > 0 || inScroll

          if( !Switcher.block && !inScroll && Math.abs( _this._x - x ) < Math.abs( yDiff ) ) //if y move is bigger than x move
          {
            events.click.block = true
            switcherY = _switcher.y.val - yDiff
            _switcher.y = Math.min( Math.max( switcherY, -220 ), 0 )
          }

          if( !scrolling ) {
            e.preventDefault()
          }

          _this._y = y
          _this._x = x
        }, id )

        _this.addEvent( 'up', function() {
          events.click.block = false
          _switcher.y._p = false
          _switcher.y = _switcher.y.val < -220 / 2 ? -220 : 0
          _this._y = null
          _this._x = null
          _this.removeEvent( false, id )
        }, id )
      }
    }
  } )

  module.exports = exports = show.Class
} else {
  module.exports = require( '../watch' )
}

},{"../../player":"/Users/youzi/dev/mtv-play/components/player/index.js","../favourite":"/Users/youzi/dev/mtv-play/components/first/favourite/index.js","../overview/item":"/Users/youzi/dev/mtv-play/components/first/overview/item.js","../watch":"/Users/youzi/dev/mtv-play/components/first/watch/index.js","./cover":"/Users/youzi/dev/mtv-play/components/first/show/cover.js","./list":"/Users/youzi/dev/mtv-play/components/first/show/list.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/show/style.less","./switcher":"/Users/youzi/dev/mtv-play/components/first/show/switcher.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js"}],"/Users/youzi/dev/mtv-play/components/first/show/list.js":[function(require,module,exports){
var cases = require('old-vigour-js/browser/cases')
var Element = require('old-vigour-js/app/ui/element')
var app = require('old-vigour-js/app/')
var Img = require('../../img').Basic
var Item = require('../../item').Indicator
var dictionary = require('old-vigour-js/app/dictionary')

var EpisodeList = new Element({
  collection: {
    data: 'episodes',
    filter: true,
    element: new Item({
      model: function (data) {
        var path = data._contentPath
        if (path) {
          this.thumb.bar.w = app.user.usage.from.get(path.concat(['time']))
          this.model = false
        }
      },
      thumb: {
        img: new Img({
          w: 70,
          h: 45
        }),
        bar: {
          w: {
            transform: function (v, cv) {
              if (!isNaN(cv)) return Math.abs(cv) * 70
              return 0
            }
          }
        }
      },
      txt: {
        'subtitle.text.data': {
          val: function (data) {
            var str = ''
            var nr
            if ((nr = data.number && data.number.val) && nr <= 9000) {
              str += dictionary.get('text.episode').val + ' ' + nr
            }
            if (data.duration) {
              if (str) {
                str += ' - '
              }
              str += Math.round(data.duration.val / 60) + ' ' + dictionary.get('text.min').val
              return str
            }
          },
          listen: ['number', 'duration']
        }
      },
      events: {
        active: !cases.desktop && 'ui-item-clicked',
        click: function () {
          if (!exports.block) {
            this.checkParent('on.media', true).$userOrigin = this.data.from
          }
        }
      }
    })
  },
  model: {
    complete: function () {
      var list = this.parent
      if (exports.state) {
        var path = this.data && this.data._cachedPath
        if (path) {
          if (exports.state.path === path) {
            list._scrollTop = exports.state.scrollTop
            list.node.scrollTop = exports.state.scrollTop || 1
          }
          exports.state = null
        }
      } else if (list && cases.touch) {
        list.node.scrollTop = 1
      }

      this.model = false
    }
  }
}).Class

var items = new Element({
  eps: new EpisodeList(),
  extrasHeader: {
    display: {
      data: 'extras',
      transform: function (v, cv) {
        return cv && cv[0] ? 'block' : 'none'
      }
    },
    text: {
      dictionary: 'text.extras'
    }
  },
  extras: new EpisodeList({
    collection: {
      data: 'extras'
    }
  })
})

var list = new Element({
  css: 'list',
  scroller: items,
  on: {
    $render: {
      defer: function (update) {
        var caller = this._parent._caller
        caller.node.scrollTop = caller._scrollTop || cases.touch && 1
        update()
      }
    }
  },
  h: {
    val: app.h,
    sub: {
      val: 89,
      iosFull: 109
    }
  },
  scrollbar: 'y',
  model: {
    inherit: false
  }
})

module.exports = exports = list.Class

},{"../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../../item":"/Users/youzi/dev/mtv-play/components/item/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/show/seasons.js":[function(require,module,exports){
var cases = require( 'old-vigour-js/browser/cases' )
var events = require( 'old-vigour-js/browser/events' )
var Element = require( 'old-vigour-js/app/ui/element' )
var Icon = require( '../../icon' )
var app = require( 'old-vigour-js/app/' )
var dictionary = require( 'old-vigour-js/app/dictionary' )
var seasonText = dictionary.get( 'text.season' )
var specialsText = dictionary.get( 'text.specials' )

var Season = new Element( {
  text: {
    data: 'number',
    transform: function( v, cv ) {
      return cv !== 9000 ? seasonText.val + ' ' + cv : specialsText.val
    },
    listen: dictionary
  }
} ).Class

module.exports = new Element( {
  items: {
    collection: {
      data: 'show.seasons',
      filter: true,
      element: new Season( {
        node: 'a',
        'events.click': function() {
          this.checkParent( 'on.season', true ).$userOrigin = this.data.from
        }
      } )
    }
  },
  x: {
    translate: true,
    parent: 'w',
    multiply: 0,
    '!slow': {
      animation: {
        time: Math.min( app.w.val / 14, 32 ),
        easing: 'outCubic'
      }
    }
  },
  highlight: {
    x: {
      translate: true
    }
  }
} )

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js"}],"/Users/youzi/dev/mtv-play/components/first/show/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/show/switcher.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var app = require('old-vigour-js/app/')
var cases = require('old-vigour-js/browser/cases')
var events = require('old-vigour-js/browser/events')
var doc = events.document
var List = require('./list')
var seasons = require('./seasons')

function prepareSwipe () {
  exports.block = false
  var sw = this.parent
  var data = sw.parent.data.show.seasons
  var index = this._current || (this._current = 0)
  var keys = this._keys || (this._keys = data.keys)

  if (!keys || !data) return

  var datalength = this._l || (this._l = keys.length)
  var children = this.children
  var prevchild = children[index - 1]
  var nextchild = children[index + 1]

  if (index < datalength && !nextchild) {
    nextchild = new List()
    this.add(nextchild)
  }
  if (prevchild && !prevchild.data) {
    prevchild.data = data[index - 1]
  }
  if (nextchild && !nextchild.data) {
    nextchild.data = data[index + 1]
  }
}

function passSwipe (e, d) {
  var pass = Math.abs(d.x) > Math.abs(d.y)
  if (pass) {
    exports.block = true
  }
  return pass
}

function swipeMove (e, d) {
  var sw = this.parent
  var seasons = sw.seasons
  var l = this._l || this._keys.length
  var dx = d.x
  var eVal = dx / (l - 1) / (3 / (l - 3)) + this._start
  var x = this.x.val
  var pos = this._current
  var oldPos = this._focus || 0
  var treshold = 120

  if (l > 3 && x < 0 && x > this._max) {
    seasons.x = {
      _e: eVal
    }
  }

  if (dx < -treshold && pos !== l - 1) pos += 1
  else if (dx > treshold && pos !== 0) pos -= 1

  if (oldPos !== pos) {
    var s = seasons.items.children
    var highlightw = sw.w.val / 3
    seasons.highlight.x = highlightw * pos
    s[oldPos].css = ''
    s[pos].css = 'focus'
    this._focus = pos
  }
}

function swipeEnd (e, d, ld) {
  var seasons = this.parent.seasons
  var treshold = 120
  var flick = 3
  var oldPos = -this._current
  var newPos
  var l = this._keys.length
  var dx = d.x || d
  var ldx = ld.x || ld

  if (Math.abs(ldx) > flick) {
    if (ldx < 0 && !(dx > treshold)) {
      newPos = Math.max(oldPos - 1, -l + 1)
    }
    if (ldx > 0 && !(dx < -treshold)) {
      newPos = Math.min(oldPos + 1, 0)
    }
  } else {
    if (dx < -treshold) newPos = Math.max(oldPos - 1, -l + 1)
    if (dx > treshold) newPos = Math.min(oldPos + 1, 0)
  }

  if (this.x._e !== void 0) {
    this.x = {
      _esub: this.x._e.val
    }
  } else if (seasons.x._e !== void 0) {
    seasons.x = {
      _esub: seasons.x._e.val
    }
  }
  if (newPos !== void 0) {
    this.checkParent('switcher.on.season', true).$userOrigin = seasons.items.children[-newPos].data.from
  }
}

var switcher = new Element({
  on: {
    $remove: {
      defer: function (update) {
        var caller = this._parent._caller
        var currentlist = caller._currentList
        List.state = {
          path: currentlist.data._cachedPath,
          scrollTop: currentlist.node.scrollTop
        }
        exports.block = false
        update()
      }
    }
  },
  y: {
    translate: true,
    '!ios': {
      '!slow': {
        animation: {
          time: 24,
          easing: 'outCubic'
        }
      }
    }
  },
  touch: {
    line: {}
  },
  seasons: seasons,
  roll: {
    w: {
      parent: 'w'
    },
    x: {
      translate: true,
      parent: 'w',
      multiply: 0,
      '!slow': {
        animation: {
          time: Math.min(app.w.val / 14, 32),
          easing: 'outCubic',
          init: function () {
            exports.block = true
          },
          complete: prepareSwipe
        }
      }
    },
    events: cases.touch && cases.slow && {
        down: function (e) {
          var ex = e.x
          var prevX = ex
          var startX = ex
          var startY = e.y
          var ldx
          var id = 'swipe'
          var t = this

          doc.addEvent('move', function (e) {
            ex = e.x
            ldx = ex - prevX
            prevX = ex
            if (ldx) {
              events.click.block = true
            }
          }, id)

          doc.addEvent('up', function (e) {
            var dx = e.x - startX
            events.click.block = false
            if (Math.abs(dx) > Math.abs(startY - e.y)) {
              swipeEnd.call(t, e, dx, ldx)
            }
            doc.removeEvent(false, id)
          }, id)
        }
    }
  },
  model: function (data) {
    data = data.show && data.show.seasons
    if (data) {
      var keys = data.keys
      var keylength = keys.length

      if (keylength && keylength !== this._l) {
        this._keys = keys
        this._l = keylength
        exports.set(this, data)
      }
    }
  },
  events: cases.touch && !cases.slow && {
      grab: {
        x: true,
        bind: function () {
          return this.roll
        },
        down: function () {
          if (!this._keys) return
          var sE = this.parent.seasons.x._e
          var datalength = this._keys.length

          this._start = sE ? sE.val : 0
          this._max = -app.w.val * (datalength - 1)
        },
        pass: passSwipe,
        move: swipeMove,
        up: swipeEnd
      }
  }
})

module.exports = exports = switcher.Class

exports.set = function (switcher, data, index) {
  var current = index | 0
  var roll = switcher.roll
  var cl = roll.children.length - 1
  var keys = switcher._keys || (switcher._keys = data.keys)
  var l = switcher._l || (switcher._l = keys.length)
  var old = roll._current
  var pos = -current
  var seasons = switcher.seasons
  var seasonitems = seasons.items
  var highlightseason = seasonitems.children[cases.desktop ? current + 1 : current]

  while (current > cl++) roll.add(new List())

  var currentlist = roll.children[current]

  if (old !== void 0) {
    var oldseason = seasonitems.children[cases.desktop ? old + 1 : old]
    seasons.x._p = false // extra for now bug in android

    if (l > 3) {
      seasons.x = {
        multiply: pos / (l - 1) / (3 / (l - 3))
      }
    }
    if (oldseason) oldseason.css = ''

    if (switcher.parent.x.val) {
      roll.x.preventSet({
        multiply: pos
      })
    } else {
      roll.x = {
        multiply: pos
      }
    }
  } else {
    if (l > 3) {
      seasons.x._p = true
      seasons.x = {
        multiply: pos / (l - 1) / (3 / (l - 3))
      }
      seasons.x._p = false
    }
    roll.x.preventSet({
      multiply: pos
    })
  }

  switcher._current = roll._current = current
  switcher._currentList = currentlist
  switcher._keys = roll._keys = keys

  if (cases.touch) seasons.highlight.x = roll.w.val / 3 * current
  if (!currentlist.data) currentlist.data = data[current]
  prepareSwipe.call(roll)
  if (highlightseason) {
    highlightseason.css = 'focus'
    if (cases.desktop) seasonitems.current.data = highlightseason.data
  }
}

},{"./list":"/Users/youzi/dev/mtv-play/components/first/show/list.js","./seasons":"/Users/youzi/dev/mtv-play/components/first/show/seasons.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/show/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js"}],"/Users/youzi/dev/mtv-play/components/first/shows/index.js":[function(require,module,exports){
var Overview = require('../overview')
var cases = require('old-vigour-js/browser/cases')
var Icon = require('../../icon')
var display = require('old-vigour-js/browser/element/properties/collection/display')

function favoTransform(v, cv) {
  var keys = cv && cv.keys
  var block = v._parent._parent._val === 'block'

  return (keys && keys.length && block) ? 'block' : 'none'
}

var showItems = new Overview.Items({
  pageheader: {
    text: {
      dictionary: 'text.nav.shows',
      touch: 'a - z'
    }
  },
  collection: {
    data: 'shows',
    filter: {
      condition: {
        title: {
          $contains: ''
        }
      },
      sort: 'title'
    },
    option: display,
    element: new Overview.Item({
      'events.click': function () {
        this.checkParent('on.show', true).$userOrigin = this.data.from
      }
    })
  },
  model: {
    subscription: {
      $: {
        $: true
      }
    }
  }
})

var favouriteItems = new Overview.Items({
  pageheader: {
    'text.dictionary': 'text.favorites'
  },
  collection: {
    data: 'favourites',
    option: display,
    element: new Overview.Item({
      desktop: {
        css: {
          addClass: 'favo-item'
        },
        thumb: {
          w: {
            sub: 15,
            multiply: 1 / 2
          },
          h: {
            self: 'w',
            divide: 4 / 3
          }
        },
        info: false
      },
      'events.click': function () {
        this.checkParent('on.show', true).$userOrigin = this.data.from
      }
    })
  },
  '!touch': {
    display: {
      val: 'block',
      transform: {
        data: 'favourites',
        transform: favoTransform
      }
    }
  },
  touch: {
    pageheader: {
      display: {
        val: 'block',
        transform: {
          data: 'favourites',
          transform: favoTransform
        }
      }
    },
    message: new Icon({
      icon: 'favoriteadd',
      'text.dictionary': 'text.noFavos',
      display: {
        data: 'favourites',
        transform: function (v, cv) {
          var keys = cv && cv.keys && cv.keys.length
          return !keys ? 'block' : 'none'
        }
      }
    })
  }
})

module.exports = new Overview({
  container: {
    position: 'relative',
    search: require('../../text/search'),
    on: {
      $render: {
        defer: function (update) {
          var caller = this._parent._caller
          if (cases.desktop) {
            (caller._parent = caller.parent).addEvent(
              'scroll',
              function () {}, 'overviewScroll'
            )
          } else {
            window.requestAnimationFrame(function () {
              if (caller._node) {
                caller.node.scrollTop = exports.scrollTop || cases.touch && 1
                caller.events.scroll._val.call(caller, false)
              }
            })
          }

          caller.set({
            on: {
              connect: cases.$hasReceiver
            }
          })

          update()
        }
      },
      $remove: cases.desktop && {
        defer: function (update) {
          var caller = this._parent._caller
          caller._parent.removeEvent(false, 'overviewScroll')
          update()
        }
      },
      connect: {
        defer: function (update) {
          var caller = this._parent._caller
          caller.events.scroll._val.call(caller, false)
          update()
        }
      }
    },
    favos: favouriteItems,
    items: showItems,
    events: {
      scroll: function (e) { // << accoutnt for search etc!!
        var scrollTop = this.node.scrollTop
        if (e !== false) exports.scrollTop = scrollTop
        if (!cases.$hasReceiver.val) return
        if (this && this.items) {
          var items = this.items.children,
            length = items.length

          if (this._k === void 0 || this._l !== length) { //gen keys in correct order
            var arr = []
            for (var i = items.length - 1; i >= 0; i--) {
              var data = items[i].data
              if (data) arr.unshift(data._name)
            }
            this._k = arr
            this._h = this.node.offsetHeight
            this._s = items[1] && items[1].node.offsetTop
            this._sh = this.node.scrollHeight - this._s
            this._l = length
          }

          var holdersize = this._h,
            start = this._s,
            totalsize = this._sh,
            keys = this._k

          if (start > scrollTop) {
            holdersize -= start - scrollTop
          }

          this.data.highlight.$userOrigin = getHighlight(holdersize, totalsize, scrollTop - start, keys)
        }
      }
    },
    model: {
      complete: function () {
        this.model = {
          complete: null
        }
        this.node.scrollTop = exports.scrollTop || cases.touch && 1
        this.events.scroll._val.call(this, false)
      }
    }
  }
}).Class

function getHighlight(holdersize, totalsize, scrollpos, datakeys) {
  var proportion = holdersize / totalsize
  var position = scrollpos / totalsize
  var length = datakeys.length,
    index = Math.round(length * position)
  var end = index + Math.round(length * proportion)

  if (index < 0) {
    end += -index
    index = 0
  }
  return datakeys.slice(index, end).join('.')
}

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../text/search":"/Users/youzi/dev/mtv-play/components/text/search.js","../overview":"/Users/youzi/dev/mtv-play/components/first/overview/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/element/properties/collection/display":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/collection/display.js"}],"/Users/youzi/dev/mtv-play/components/first/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require('./style.less')

var app = require('old-vigour-js/app/')
var Element = require('old-vigour-js/app/ui/element')
var Switcher = require('old-vigour-js/app/ui/switcher')
var transitions = require('old-vigour-js/app/ui/switcher/transitions')
var cases = require('old-vigour-js/browser/cases')
var Icon = require('../../icon')
var page = require('./page')
var media = require('./media')
var show = require('./show')

module.exports = exports = new Switcher({
  css: 'first-switcher',
  desktop: {
    scrollbar: {
      val: app.w,
      transform: function (v, cv) {
        return cv < 1300 || 'y'
      }
    },
    transition: {
      defer: function(update) {
        this._caller.node.scrollTop = 0
        update()
      }
    }
  },
  on: {
    page: {
      defer: function() {
        (cases.$isFullscreen.val ? fullScreenHandler : page)
        .apply(this, arguments)
      }
    },
    show: {
      defer: function() {
        (cases.$isFullscreen.val ? fullScreenHandler : show)
        .apply(this, arguments)
      }
    },
    season: {
      defer: function(update, args) {
        if (args[0]) this._parent.show._update()
        update()
      }
    },
    media: {
      defer: function() {
        (cases.$isFullscreen.val ? fullScreenHandler : media)
        .apply(this, arguments)
      }
    }
  },
  onTransition: {
    val: 'fade',
    touch: 'slide'
  },
  backFallback: backFallback,
  loader: new Element({
    css: 'first-loader',
    x: {
      translate: true
    },
    loadicon: new Icon({
      icon: 'logo'
    })
  })
})
.inject(transitions)
.Class

function fullScreenHandler(update) {
  var on = this._parent,
    receiver = on.ms._val,
    mediadata = cases.$isReceiver.val ? receiver.media.$userOrigin.val : on.media.$userOrigin.val

  on._caller.transition = {
    element: media.getElement(),
    $params: media.getParams(on.media, mediadata, true)
  }

  app.state.video = {
    val: mediadata.from
  }

  update()
}

function backFallback() {
  var previous = this.previous,
    current = this.current

  if (previous) {
    if (previous === 'page') {
      this.on.page.$userOrigin = this.on.page.val || ((this.current === 'show' || this.current === 'episode') && 'shows') || (this.current === 'channel' && 'channels') || 'discover'
      return
    } else {
      if (this.on[previous]) {
        var previousFrom = this.on[previous].from,
          mediaFrom = this.on.media.from
        if (previousFrom._parent._name === 'navigation') {
          if (previous === 'show' && mediaFrom._parent._name !== 'navigation') {
            previousFrom = mediaFrom._parent._parent._parent._parent
            if (previousFrom._name !== 'show') previousFrom = null
          } else {
            previousFrom = null
          }
        }
        if (previousFrom) {
          this.on[previous].$userOrigin = previousFrom
          return
        }
      }
    }
  }

  this.on.page.$userOrigin = typeof this.on.page.val === 'string' ? this.on.page.val : 'discover'
}

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./media":"/Users/youzi/dev/mtv-play/components/first/switcher/media.js","./page":"/Users/youzi/dev/mtv-play/components/first/switcher/page.js","./show":"/Users/youzi/dev/mtv-play/components/first/switcher/show.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/switcher/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/app/ui/switcher":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/index.js","old-vigour-js/app/ui/switcher/transitions":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/transitions.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/switcher/media.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var cases = require('old-vigour-js/browser/cases')
var app = require('old-vigour-js/app/')
var Element

module.exports = exports = function (update) {
  var switcher = this._parent._caller
  var mediadata = this.$userOrigin.val || (mediadata = this.$userOrigin.val = this.from)

  if (!exports.isEpisode(mediadata)) {
    var currentPath = mediadata.from._path
    var indexOfSeasons = currentPath.indexOf('seasons')
    var indexOfChannels
    var path

    if (~indexOfSeasons) {
      indexOfChannels = currentPath.lastIndexOf('channels')
      path = currentPath.slice(indexOfChannels, indexOfSeasons)
      mediadata = this.$userOrigin.val = app.content.get(path)
    }
  }

  switcher.transition = {
    element: exports.getElement(),
    direction: exports.getDirection(switcher, mediadata),
    $params: exports.getParams(this, mediadata),
    $options: exports.getOptions(mediadata)
  }

  exports.setStatus(switcher, mediadata)

  update()
}

exports.isEpisode = function (mediadata) {
  return !~mediadata._contentPath.indexOf('channels')
}

exports.getDirection = function (switcher, mediadata) {
  var current = switcher.current

  return exports.isEpisode(mediadata) ? current !== 'episode' ? 1 : 0 : current !== 'channel' ? 1 : 0
}

exports.getElement = function () {
  return Element || (Element = require('../watch'))
}

exports.getOptions = function (mediadata) {
  var seasondata = exports.isEpisode(mediadata) && mediadata._parent._parent
  var seasonFrom = cases.tablet && seasondata && seasondata.from
  var mediaFrom = mediadata.from
  var waitForLoad = seasonFrom || mediaFrom

  if (waitForLoad) {
    return {
      loader: waitForLoad
    }
  }
}

exports.getParams = function (_this, mediadata, fullscreen) {
  var parent = _this._parent
  var usage = parent.usage
  var msMedia = parent.ms._val.media.$userOrigin
  var isEpisode = exports.isEpisode(mediadata)
  var showdata
  var data = {
    media: mediadata,
    volume: parent.volume.from,
    msmedia: msMedia
  }

  if (isEpisode) {
    var seasondata = mediadata._parent._parent
    // when in fullscreen, only update the page data, not all userdata
    if (fullscreen) {
      data.season = seasondata
    } else {
      if (cases.phone) parent.season.$userOrigin.val = seasondata
      else parent.season.$userOrigin = seasondata

      data.season = parent.season.$userOrigin
    }
    data.show = showdata = app.user.navigation.show.$userOrigin.val = seasondata._parent._parent
    data.showusage = usage.from.get(showdata.from._contentPath)
    data.mediausage = usage.from.get(mediadata.from._contentPath, {
      time: 0
    })
  }

  // extra secure, faster
  cases.$isOnChannel.val = !isEpisode

  var params = {
    media: {
      player: {
        on: {
          msmedia: msMedia,
          media: mediadata
        }
      }
    },
    on: {
      channel: {
        val: cases.$isOnChannel,
        listen: mediadata
      },
      resize: cases.tablet && app.w
    },
    data: data
  }

  return params
}

exports.setStatus = function (switcher, mediadata) {
  var current = switcher.current
  var isEpisode = exports.isEpisode(mediadata)
  var previous

  if (cases.phone) {
    previous = isEpisode ? (current === 'page' ? current : 'show') : 'page'
  } else {
    previous = 'page'
  }

  switcher.previous = previous
  switcher.current = isEpisode ? 'episode' : 'channel'
}

},{"../watch":"/Users/youzi/dev/mtv-play/components/first/watch/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/switcher/page.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var cases = require('old-vigour-js/browser/cases')
var user = require('old-vigour-js/app').user

module.exports = function (update) { // discover / shows / channels
  var page = this.$userOrigin.val
  var parent = this._parent
  var caller = parent._caller
  var content = parent.content.from
  var loadedBenchmark
  var pagedata
  var on
  if (page) {
    if (page === 'discover') {
      if (exports[page] === void 0) {
        exports[page] = require('../discover')
      }
      var role = user.role.val
      if (!role || role === 3) {
        pagedata = {
          marquee: content.get('discover_marquee_free.list'),
          releases: loadedBenchmark = content.get('discover_row1_free.list'),
          recommended: content.get('discover_row2_free.list'),
          free: content.get('discover_row3_free.list')
        }
        on = {
          val: user.role,
          defer: function (update) {
            role = this.from.val
            if (role && role !== 3) {
              user.navigation.page.$userOrigin = 'discover'
            }
            update()
          }
        }
      } else {
        pagedata = {
          marquee: content.get('discover_marquee_premium.list'),
          releases: loadedBenchmark = content.get('discover_row1_premium.list'),
          recommended: content.get('discover_row2_premium.list'),
          free: content.get('discover_row3_premium.list')
        }
        on = {
          val: user.role,
          defer: function (update) {
            role = this.from.val
            if (!role || role === 3) {
              user.navigation.page.$userOrigin = 'discover'
            }
            update()
          }
        }
      }

      pagedata.channels = content.get('channels')
      pagedata.watched = parent.watched.from
      pagedata.scroll = parent.scroll.from
      pagedata.carousel = parent.carousel.from

    } else if (page === 'shows') {
      if (exports[page] === void 0) {
        exports[page] = require('../shows')
      }
      pagedata = {
        shows: loadedBenchmark = content.get('shows'),
        favourites: parent.favourites.from,
        search: parent.search._val,
        highlight: parent.highlight.from
      }
    } else if (page === 'channels') {
      if (exports[page] === void 0) {
        exports[page] = require('../channels')
      }
      pagedata = {
        channels: loadedBenchmark = content.get('channels')
      }
    }

    caller.transition = {
      element: exports[page],
      $params: {
        data: pagedata,
        on: on
      },
      $options: {
        loader: cases.tablet && (caller.current === 'page' && caller._last !== page) ? true : loadedBenchmark && loadedBenchmark.from,
        animation: !(cases.tablet && (caller.current === 'page')),
        delay: cases.tablet && (caller.current === 'page') && 350
      },
      direction: caller.current !== 'page' && -1
    }

    caller.current = 'page'
    caller._last = page //hotfix for transitions
  }

  update()
}

},{"../channels":"/Users/youzi/dev/mtv-play/components/first/channels/index.js","../discover":"/Users/youzi/dev/mtv-play/components/first/discover/index.js","../shows":"/Users/youzi/dev/mtv-play/components/first/shows/index.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/switcher/show.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var cases = require( 'old-vigour-js/browser/cases' )
var app = require( 'old-vigour-js/app/' )
var media = require( './media' )
var Element

if( cases.phone ) {
  module.exports = exports = function( update ) {
    var parent = this._parent,
      switcher = parent._caller,
      showdata = this.$userOrigin.val

    switcher.transition = {
      element: exports.getElement(),
      $params: exports.getParams( this, showdata ),
      $options: exports.getOptions( this, showdata ),
      direction: exports.getDirection( switcher, showdata )
    }

    parent.season.$userOrigin._update()

    switcher.previous = 'page'
    switcher.current = 'show'

    update()
  }

  exports.getDirection = function( switcher, showdata ) {
    var current = switcher.current
    return current === 'page' ? 1 : current === 'episode' && -1
  }

  exports.getElement = function() {
    return Element || ( Element = require( '../show' ) )
  }

  exports.getOptions = function( _this, showdata ) {
    var seasonFrom = _this._parent.season.from
    var showFrom = showdata.from

    return {
      loader: seasonFrom
    }
  }

  exports.getParams = function( _this, showdata ) {
    var parent = _this._parent
    var showname = showdata._name
    var season = parent.season
    var usage = parent.usage
    var params

    if( !season.$userOrigin.val || !season.from.checkParent( '_name', showname ) ) {
      season.$userOrigin.val = showdata.from.get( 'seasons.0' )
    }

    params = {
      on: {
        season: season.$userOrigin,
        show: showdata
      },
      data: {
        show: showdata,
        showusage: usage.from.get( showdata.from._contentPath )
      }
    }

    return params
  }
} else {
  module.exports = function( update ) {
    var showdata = this.$userOrigin.val
    var showname = showdata._name
    var season = this._parent.season
    var seasonNr = season.from._parent._parent === showdata.from && season.from._name
    var parent = this._parent
    var m = parent.media
    var _contentPath

    if( !m.from.checkParent( '_name', showname ) || !m.$userOrigin.val ) {
      seasonNr = ( !seasonNr || isNaN( seasonNr ) ) ? 0 : seasonNr
      season = showdata.get('seasons.' + seasonNr)
      
      season.subscribe({
        episodes:{
          0:{
            title:true
          }
        }
      })
      season.subscribe({
        episodes:true
      })

      var episodes = season.get('episodes')

      episodes.is('loaded',function(){
        season.unsubscribe({
          episodes:{
            0:{
              title:true
            }
          }
        })
        season.unsubscribe({
          episodes:true
        })
        if(!m.from.checkParent( '_name', showname ) || !m.$userOrigin.val){
          m.$userOrigin = episodes.val ? episodes.get('0') : season.get('extras.0')
        }
        update()
      })
    }else{
      m._update()
      update()
    }
  }
}

},{"../show":"/Users/youzi/dev/mtv-play/components/first/show/index.js","./media":"/Users/youzi/dev/mtv-play/components/first/switcher/media.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/switcher/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/tv/grid.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var Img = require( '../../img' )
var app = require( 'old-vigour-js/app/' )

var Item = new Img( {
  css: 'tv-grid-item',
  h: {
    val: app.h,
    divide: 3
  },
  w: {
    self: 'h',
    multiply: 4 / 3
  },
  display: 'inline-block'
} ).Class

var BigItem = new Item( {
  w: {
    self: 'h',
    multiply: 8 / 3,
    add: {
      val: app.w.val,
      multiply: 0.02 * 0.8
    }
  }
} ).Class

var Row = new Element( {
  category: {
    text: 'this is the field',
    h: {
      val: app.h,
      divide: 3
    },
    w: {
      self: 'h',
      multiply: 5 / 6
    },
    css: 'tv-grid-category'
  },
  display: {
    data: function( data ) {
      return data.length === 0 ? 'none' : 'block'
    }
  },
  events: {
    arrowUp: function() {
      if( this.$prev.val ) this.$prev.val.$focus()
    },
    arrowDown: function() {
      if( this.$next.val ) this.$next.val.$focus()
    },
    arrowRight: function() {
      app.focusState.prev = this._name
      app.focusState.from.val = 'row'
    },
    click: function() {
      this.events.arrowRight._val.call( this )
    },
    arrowLeft: function() {
      var menu = this.checkParent( 'sidemenu', true )
      app.focusState.val = 'menu'
    },
    back: function( e ) {
      //if last is grid
      e.preventDefault()
      app.focusState.val = 'menu'
    },
    $focus: function( e ) {
      var category = this.category
      var node = category.node
      var grid = this.parent
      var rect
      var appHeight = app.h.val
      var screenBottom = appHeight - 80
      var screenTop = appHeight / 5

      app.focusState.prev = this._name

      category.css = e ? 'tv-grid-category current' : 'tv-grid-category'

      if( e ) {
        rect = node.getBoundingClientRect()
        if( rect.bottom > screenBottom ) {
          grid.y = grid.y.val - ( rect.bottom - screenBottom )
        } else if( rect.top < screenTop ) {
          grid.y = grid.y.val + ( screenTop - rect.top )
        }
        grid.y._p = null
      }

    }
  },
  css: 'tv-row',
  collection: {
    data: true,
    element: Item
  }
  /*
    keyboard stuff
  */
} ).Class

var Grid = module.exports = exports = new Element( {
  css: 'tv-grid',
  y: {
    val: app.h.val / 5,
    animation: {
      easing: 'outCubic',
      time: 18
    }
  },
  on: {
    $new: {
      defer: function( update ) {
        this._parent._caller.y._p = true
        update()
      }
    },
    focusState: {
      defer: function( update, args ) {
        //dit moet naar de switcher!
        var _this = this

        if( _this.from.val === 'grid' ) {
          //this._parent.focusState.from.prev.grid
          var parent = _this._parent

          if( parent ) {
            var key = parent.focusState.from.prev
            var _caller = parent._caller
            var child = ( key && _caller[ key ] ) || _caller.children[ 0 ]

            child.$focus()
          }
        } else if( _this.from.val === 'row' ) {
          app.user.updateNavigation()
        }

        update()
      }
    },
    $parent: {
      defer: function( update, args ) {
        var caller = this._parent._caller
        var first
        var obj

        if( caller && caller.data ) {
          for( var key in caller.data ) {
            var tKey = key
            key = '$$' + key
            if( !caller[ key ] ) {
              if( !obj ) obj = {}
              if( key === 'marquee' ) {
                obj[ key ] = new Row( {
                  'category.text': tKey.length > 2 ? {
                    dictionary: 'text.' + tKey
                  } : tKey,
                  bigItem: new BigItem( {
                    data: caller.data[ tKey ].get( 0 )
                  } ),
                  item: new Item( {
                    data: caller.data[ tKey ].get( 1 )
                  } )
                } )
              } else {
                obj[ key ] = new Row( {
                  'category.text': tKey.length > 2 ? {
                    dictionary: 'text.' + tKey
                  } : tKey,
                  data: caller.data[ tKey ]
                } )
              }
              if( !first ) first = key
            }
          }

          if( first ) {
            caller.set( obj )
            this._parent.focusState._update()
          }

        }

        update()
      }
    }
  }
} ).Class

exports.Row = Row
exports.Item = Item

},{"../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/tv/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Element = require( 'old-vigour-js/app/ui/element' )
var app = require( 'old-vigour-js/app/' )
var cases = require( 'old-vigour-js/browser/cases' )
var Switcher = require( 'old-vigour-js/app/ui/switcher' )
var transitions = require( 'old-vigour-js/app/ui/switcher/transitions' )
var config = require( 'old-vigour-js/util/config' )
var Message = require( './message' )
var Icon = require( '../../icon' )
var events = require( 'old-vigour-js/browser/events' )

var Signin = new Message( {
  css: {
    addClass: 'tv-signin'
  },
  container: {
    holder: {
      title: {
        text: {
          dictionary: 'text.login.tvTitle'
        }
      },
      subtitle: {
        text: {
          dictionary: 'text.login.tvSubtitle'
        }
      },
      bottomimage: {}
    }
  }
} ).Class

var RoadBlock = new Message( {
  css: {
    addClass: 'tv-roadblock'
  },
  container: {
    holder: {
      topimage: {},
      title: {
        text: {
          dictionary: 'text.login.tvTitle'
        }
      },
      subtitle: {
        text: {
          dictionary: 'text.login.tvSubtitle'
        }
      },
      bottomimage: {}
    }
  },
  events: {
    $focus: function() {}
  }
} ).Class

module.exports = exports = new Switcher( {
    css: 'first-switcher ui-img',
    x: {
      val: app.w,
      multiply: 1 / 5,
      animation: {
        easing: 'outCubic',
        time: 18
      }
    },
    w: {
      val: app.w
    },
    onTransition: 'fade',
    desktop: {
      scrollbar: 'y'
    },
    on: {
      page: {
        defer: require( './page' )
      },
      show: {
        defer: require( './show' )
      },
      media: {
        defer: function( update, args ) {
          this._parent.show.update()
          update()
        }
      },
      signin: {
        defer: function( update, args ) {
          var caller = this._parent._caller
          caller.transition = {
            element: Signin
          }
          update()
        }
      },
      roadblock: {
        defer: function( update, args ) {
          if( this._val ) {
            var _this = this
            var caller = this._parent._caller
            var focused = events.$focused.val
            var roadblock = new RoadBlock( {
              events: {
                click: function() {
                  this.events.back._val.call( this )
                },
                back: function() {
                  focused.$focus()
                  _this.val = false
                  this.remove()
                }
              }
            } )

            caller.parent.set( {
              roadblock: roadblock
            } )

            roadblock.$focus()
          }
          update()
        }
      }
    },
    background: {
      data: 'img',
      transform: function( v, cv ) {
        if( !cv ) return ' '
        var w = Math.ceil( ( this.w || this.checkParent( 'w', true ) ).val ) || app.w.val
        var h = Math.ceil( ( this.h || this.checkParent( 'h', true ) ).val ) || app.h.val

        w = range( w, 100 )
        h = range( h, 100 )

        return config.img + '/image/' + cv + '/' + w + '/' + h + '?effect=overlayBlur&overlay=overlayDarkpurple3&radius=' + ( h / 15.67 | 0 ) + '&sigma=' + ( h / 20 | 0 )
      },
      load: function( t ) {
        if( t ) t.opacity = 1
      }
    }
  } )
  .inject( transitions )
  .Class

function range( amount, val ) {
  return Math.ceil( amount / val ) * val
}

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./message":"/Users/youzi/dev/mtv-play/components/first/tv/message.js","./page":"/Users/youzi/dev/mtv-play/components/first/tv/page.js","./show":"/Users/youzi/dev/mtv-play/components/first/tv/show.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/app/ui/switcher":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/index.js","old-vigour-js/app/ui/switcher/transitions":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/transitions.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/message.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Element = require( 'old-vigour-js/app/ui/element' )

module.exports = new Element( {
  css: 'tv-message',
  container: {
    holder: {
      topimage: {}
    }
  }
} ).Class

},{"old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/page.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var Grid = require( './grid' )
var app = require( 'old-vigour-js/app/' )
var Row = require( './row/page' )
var ChannelRow = require( './row/channel' )

var Data = require( 'old-vigour-js/data' )
  .inject( require( 'old-vigour-js/data/selection' ) )
var letters = '#abcdefghijklmnopqrstuvwxyz'.split( '' ) //abcdefghijklmnopqrstuvwxyz
var showdata
var stub

module.exports = exports = function( update, args ) {
  var page = this.$userOrigin.val
  var parent = this._parent
  var caller = parent._caller
  var pagedata

  caller.x = {
    multiply: app.focusState.val === 'row' ? 0 : 1 / 5
  }

  caller.data = null

  if( page === 'discover' ) {
    exports[ page ] = app.focusState.val === 'row' ? Row : Grid // app.focusState.val === 'grid' ? Grid : Row 

    pagedata = {
      spotlight: app.content.get( 'marquee.list' ),
      free: app.content.get( 'free.list' ),
      recommended: app.content.get( 'recommended.list' )
    }

  } else if( page === 'shows' ) {

    exports[ page ] = app.focusState.val === 'row' ? Row : Grid

    if( !showdata ) {
      showdata = {}
      stub = new Data( app.content.get( 'shows' ), {
        subscription: {
          $: {
            title: true,
            img: true
          }
        },
        block: true
      } )

      for( var i = 0, _len = letters.length; i < _len; i++ ) {
        showdata[ letters[ i ] ] = new Data( app.content.get( 'shows' ), {
          sort: 'title',
          block: true,
          range: [ 0, 5 ],
          condition: {
            title: {
              $contains: letters[ i ] === '#' ? '^\\d' : '^[' + letters[ i ] + ']'
            }
          }
        } )
      }
    }

    pagedata = showdata

  } else if( page === 'channels' ) {
    exports[ page ] = ChannelRow
    pagedata = app.content.from.get( 'channels' )
  }
  exports.stamp = args[ 1 ]
  if( page === 'shows' && app.focusState.val !== 'row' ) { //
    app.content.get( 'shows' ).is( function() {
      return( showdata.a.length > 0 && showdata[ '#' ].length > 0 && showdata.g.length > 3 )
    }, setPage )
  } else {
    setPage()
  }

  function setPage() {
    if( exports[ page ] && exports.stamp === args[ 1 ] ) {
      caller.transition = {
        element: exports[ page ],
        $params: {
          data: pagedata,
          on: {
            focusState: app.focusState
          } //SOMETHING GOES WRONG HERE
        },
        $options: {
          force: true
        },
        direction: caller.current !== 'page' && -1
      }
      caller.current = 'page'
    }
  }

  update()

}

},{"./grid":"/Users/youzi/dev/mtv-play/components/first/tv/grid.js","./row/channel":"/Users/youzi/dev/mtv-play/components/first/tv/row/channel.js","./row/page":"/Users/youzi/dev/mtv-play/components/first/tv/row/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/data/selection":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/selection.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/row/channel.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var app = require( 'old-vigour-js/app/' )
var dictionary = require( 'old-vigour-js/app/dictionary' )
var VObj = require( 'old-vigour-js/object' )
var epgData = require( '../../../epg_temp' )
var Seekbar = require( '../../../player/seekbar' )
var clockTime = epgData.clockTime
var Item = require( './item' )
var elements = require( './elements' )

var ChannelItem = new Item( {
  background: {
    gone: false
  },
  information: {
    channeltitle: {
      css: 'ui-item-text',
      text: {
        data: 'title'
      }
    },
    now: {
      w: 80,
      text: {
        dictionary: 'text.now'
      }
    },
    epg: {
      w: {
        parent: 'w',
        sub: 80 + 30
      },
      showtitle: {
        text: {
          data: 'title'
        }
      },
      time: {
        text: {
          data: 'minutes_since_midnight',
          transform: clockTime,
          add: [ ' - ', {
            data: 'endtime',
            transform: clockTime
          } ]
        }
      },
      bar: new Seekbar( {
        seek: {
          w: {
            val: epgData.minutesSinceMidnight,
            sub: {
              data: 'minutes_since_midnight'
            },
            divide: {
              data: 'duration'
            },
            transform: function( v, cv ) {
              return !isNaN( parseInt( cv ) ) ? cv * 100 + '%' : 0
            },
            clear: true
          }
        },
        button: false
      } ),
      model: {
        inherit: false
      }
    }
  },
  model: {
    subscription: {
      epgid: true
    },
    val: function( data ) {
      var epgid = data.epgid && data.epgid.val
      if( epgid !== void 0 ) {
        this.information.epg.data = epgData.now( epgid )
        this.model = false
      }
    }
  },
  events: {
    arrowRight: function() {
      var focusState = app.focusState.val
      if( focusState !== 'row' && ( !this.$prev.val || !this.$prev.val.cover ) ) {
        app.focusState.val = 'row'
      } else if( this.$next.val ) this.$next.val.$focus()
    },
    arrowLeft: function() {
      var focusState = app.focusState.val
      if( focusState === 'grid' ) {
        app.focusState.val = 'menu'
      } else if( this.$prev.val && this.$prev.val.cover ) {
        this.$prev.val.$focus()
      } else {
        app.focusState.val = 'grid'
      }
    },
    back: function( e ) {
      //if last is grid
      e.preventDefault()
      var rows = this.checkParent( 'rows', true )
      rows.x._p = true
      app.focusState.val = app.focusState.val === 'row' ? 'grid' : 'menu'
    },
    click: function() {
      if( this.cover.icon.val === 'lockedContent' ) {
        var roadblock = this.checkParent( 'on.roadblock', true )
        if( roadblock ) roadblock.val = true
      } else {
        app.user.navigation.media.$userOrigin.val = this.data.from
        app.state.val = {
          val: 'player',
          video: this.data.from
        }
      }
    }
  }
} ).Class

module.exports = exports = new elements.BasicRowView( {
  css: {
    addClass: 'tv-channels'
  },
  indicator: {
    display: {
      val: app.focusState,
      transform: function( v, cv ) {
        return cv === 'row' ? 'block' : 'none'
      }
    },
    title: {
      text: {
        dictionary: 'text.nav.channels'
      }
    }
  },
  rows: {
    css: 'tv-row',
    collection: {
      element: ChannelItem,
      data: true
    }
  },
  on: {
    focusState: {
      defer: function( update, args ) {
        var val = this.from.val
        var caller = this._parent._caller

        if( val === 'grid' ) {
          caller.parent.x = {
            multiply: 1 / 5
          }
        } else if( val === 'row' ) {
          caller.parent.x = {
            multiply: 0
          }
        }

        if( caller.rows && caller.rows.children[ 0 ] && ( val !== 'menu' || args[ 0 ] !== '$parent' ) ) {
          caller.rows.children[ 0 ].$focus()
        }

        update()
      }
    },
    $parent: {
      defer: function( update, args ) {
        this._parent.focusState._update( '$parent' )
        update()
      }
    }
  }
} ).Class

},{"../../../epg_temp":"/Users/youzi/dev/mtv-play/components/epg_temp.js","../../../player/seekbar":"/Users/youzi/dev/mtv-play/components/player/seekbar/index.js","./elements":"/Users/youzi/dev/mtv-play/components/first/tv/row/elements.js","./item":"/Users/youzi/dev/mtv-play/components/first/tv/row/item.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/row/elements.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var app = require( 'old-vigour-js/app/' )
var dictionary = require( 'old-vigour-js/app/dictionary' )

exports.Indicator = new Element( {
  css: 'tv-row-indicator',
  text: {
    data: true,
    dictionary: function( val, cv ) {
      if( cv ) {
        if( cv instanceof Object && cv.number ) {
          return {
            text: cv.number && cv.number.val
          }
        }
        cv = String( cv )
        if( cv.length > 2 ) return 'text.' + cv
        return {
          text: cv
        }
      }
    }
  },
  display: 'inline-block'
} ).Class

var BasicRowView = exports.BasicRowView = new Element( {
  css: 'tv-row-view',
  indicator: {
    title: {}
  },
  rows: {
    on: {
      $new: {
        defer: function( update ) {
          this._parent._caller.x._p = true
          update()
        }
      }
    },
    y: app.h.val / 5,
    x: {
      val: 0,
      animation: {
        easing: 'outCubic',
        time: 18
      }
    }
  }
} ).Class

exports.RowView = new BasicRowView( {
  indicator: {
    list: {
      text: '',
      collection: {
        element: exports.Indicator //eigen indicators
          ,
        data: true,
        filter: true
      }
    }
  },
  info: {
    on: {
      $remove: {
        defer: function( update ) {
          console.log( 'remove?' )
          var caller = this._parent._caller
          if( caller._timer ) clearTimeout( caller._timer )
          update()
        }
      }
    },
    opacity: {
      data: 'description',
      transform: function( v, cv ) {
        if( !cv ) {
          this.css = 'dontAnimate'
          return 0
        } else {
          this.css = ''
          return 1
        }
      }
    },
    title: {
      text: {
        data: 'title'
      }
    },
    showsubtitle: {
      css: 'subtitle',
      display: {
        data: 'episodeCount',
        transform: function( v, cv ) {
          return cv ? 'block' : 'none'
        }
      },
      text: {
        val: {
          data: 'seasonCount'
        },
        add: [ ' ', {
          dictionary: 'text.seasons'
        }, ' ', {
          data: 'episodeCount'
        }, ' ', {
          dictionary: 'text.episodes'
        } ]
      }
    },
    episodesubtitle: {
      css: 'subtitle',
      display: {
        data: 'duration',
        transform: function( v, cv ) {
          return cv ? 'block' : 'none'
        }
      },
      text: {
        data: 'duration',
        transform: function( v, cv ) {
          return ~~( cv / 60 ) + ' '
        },
        add: {
          dictionary: 'text.min'
        }
      }
    },
    description: {
      text: {
        data: 'description'
      }
    }
  }
} ).Class

},{"old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/row/item.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var Img = require( '../../../img' )
var app = require( 'old-vigour-js/app/' )
var cases = require( 'old-vigour-js/browser/cases' )
var dictionary = require( 'old-vigour-js/app/dictionary' )
var VObj = require( 'old-vigour-js/object' )
var Icon = require( '../../../icon' )

function next( t, parent ) {
  parent = parent ? this : this.parent
  var sib = parent && parent.node.nextSibling
  if( sib && sib.base ) {
    if( !sib.base.children[ 0 ] ) {
      return next.call( sib.base, false, true )
    }
    return sib.base.children[ 0 ]
  }
}

function prev( select, parent ) {
  parent = parent ? this : this.parent
  var sib = parent && parent.node.previousSibling
  if( sib && sib.base ) {
    var child = sib.base.children[
      select === void 0 ? sib.base.children.length - 1 : select
    ]

    if( !child ) return prev.call( sib.base, select, true )
    return child
  }
}

var Item = module.exports = new Img( {
  on: {
    data: 'link'
  },
  define: {
    $selectIndicator: function( field ) {

      var indicator = this.checkParent( 'indicator.list', true ),
        findit = indicator && indicator.find( 'data', field )

      if( !findit ) {
        findit = indicator && indicator.find( 'data._val', field )
      }

      if( findit && indicator && indicator._focused !== findit ) {
        if( indicator._focused ) indicator._focused.css = 'tv-row-indicator'
        findit.css = 'tv-row-indicator current'
        indicator._focused = findit
      }

    },
    $focusCommon: function( event ) {

      var rows = this.checkParent( 'rows', true )
      var rowview = rows.parent
      var node = this.node
      var screenLeft = 40
      var next = this
      var prev
      var cnt = 4
      var info
      var data

      if( event ) {
        rect = node.getBoundingClientRect()
        rows.x = rows.x.val + ( screenLeft - rect.left ) + rowview.parent.x.val
        info = rowview.info
        prev = this.$prev.val

        while( cnt-- && next ) {
          if( next.background.gone.val ) next.background = {
            gone: false
          }
          next = next.$next.val
        }
        if( prev && prev.background.gone && prev.background.gone.val ) {
          prev.background = {
            gone: false
          }
        }

        if( info ) {
          data = this.data
          info.data = {}
          if( info._timer ) {
            clearTimeout( info._timer )
            info._timer = null
          }
          info._timer = setTimeout( function() {
            info.data = data
            info._timer = null
          }, 500 )
        }
        rows.x._p = null
      }

      this.css = event ? 'tv-row-item current' : 'tv-row-item'
    }
  },
  css: 'tv-row-item',
  h: {
    val: app.h,
    divide: 3,
    multiply: 1 / 0.8
  },
  w: {
    self: 'h',
    multiply: 4 / 3
  },
  background: {
    gone: true
  },
  cover: new Icon( {
    css: 'ui-icon relative-size',
    icon: {
      data: 'access',
      transform: function( v, access ) {
        if( access === 1 && !cases.$isUpgraded.val ) return 'lockedContent'
        if( access === 2 && !cases.$isUpgraded.val ) return 'lockedContent'
        if( access === 3 && ( !cases.$isUpgraded.val || ( app.user.role.val === 3 ) ) ) return 'lockedContent'
        return 'empty'
      }
    }
  } ),
  display: 'inline-block',
  events: {
    click: function( e ) {
      var data = this.data && this.data.from
      if( data ) {
        if( data.link ) {

          var link = data.link.val.split( '.' )
          var show = link[ 3 ] === 'shows'
          var episode = link[ link.length - 2 ] === 'episodes'
          var linkdata

          if( episode ) {
            linkdata = app.content.from.get( link.slice( 3 ) )
            app.user.navigation.media.$userOrigin.val = linkdata
            app.state.val = {
              val: 'player',
              video: linkdata
            }
          } else if( show ) {
            app.user.navigation.show.$userOrigin = app.content.get( link.slice( 3 ) )
          } else {
            console.error( 'other type of link!' )
          }

        } else if( data._parent._name === 'shows' ) {
          app.user.navigation.show.$userOrigin = data
        } else if( data._parent._name === 'episodes') {
          if( this.cover.icon.val === 'lockedContent' ) {
            var roadblock = this.checkParent( 'on.roadblock', true )
            if( roadblock ) roadblock.val = true
          } else {
            app.user.navigation.media.$userOrigin.val = data
            app.state.val = {
              val: 'player',
              video: data
            }
          }
        }
      }
    },
    arrowRight: function() {
      if( this.$next.val ) this.$next.val.$focus()
    },
    arrowDown: function() {
      var _prev = prev.call( this, 0 )
      if( _prev ) _prev.$focus()
    },
    arrowUp: function() {
      var _next = next.call( this )
      if( _next ) _next.$focus()
    },
    $focus: function( e ) {
      var name = this.parent._name
      var field
      var special

      if( name ) {
        field = name.slice( 2 )
      } else {
        name = this.data._parent._parent._name
        field = this.data._parent._parent
        special = true
      }

      if( !special ) {
        app.focusState.prev = name
      }

      this.$selectIndicator( field )
      this.$focusCommon( e )
    }
  },
  '$next.transform': function( val, cv ) {
    if( !cv ) {
      return next.call( this )
    }
  },
  '$prev.transform': function( val, cv ) {
    if( !cv ) {
      return prev.call( this )
    }
  }
} ).Class

},{"../../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/row/page.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var Img = require( '../../../img' )
var app = require( 'old-vigour-js/app/' )
var dictionary = require( 'old-vigour-js/app/dictionary' )
var VObj = require( 'old-vigour-js/object' )
var Item = require( './item' )
var elements = require( './elements' )
var Data = require( 'old-vigour-js/data' )

var SingleRow = new Element( {
  css: 'tv-row',
  collection: {
    data: true,
    element: new Item( {
      events: {
        arrowLeft: function() {
          if( this.$prev.val ) {
            this.$prev.val.$focus()
          } else {
            var focusState = app.focusState.from
            focusState.val = 'grid'
          }
        },
        back: function( e ) {
          e.preventDefault()
          app.focusState.val = 'grid'
        }
      }
    } )
  }
} ).Class

var pageRow = module.exports = exports = new elements.RowView( {
  'indicator.list.model.inherit': false,
  on: {
    focusState:
    //deze iets meer sharen! -- gewoon callen als functie
    {
      defer: function( update, args ) {
        var _this = this
        var parent = _this._parent
        if( _this.from.val === 'row' ) {
          if( parent ) {
            var key = parent.focusState.from.prev //dit moet nog gefixed! 
              ,
              _caller = parent._caller.rows

            if( _caller.children.length ) {
              var child = ( key && _caller[ key ] && _caller[ key ].children[ 0 ] ) || _caller.children[ 0 ].children[ 0 ]

              if( !child && _caller.children[ 1 ] ) {
                child = _caller.children[ 1 ].children[ 0 ]
              }
              if( child && !child._$focused ) {
                child.$focus()
              }
            }
          }
        } else if( _this.from.val === 'grid' ) {
          app.user.updateNavigation()
        }
        update()
      }
    },
    $parent: {
      defer: function( update, args ) {

        var caller = this._parent._caller
        var first
        var obj
        var _this = this

        if( caller && caller.data && this._cachedData !== caller.data ) {
          this._cachedData = caller.data
          var keys = new Data( [] )
          var page = app.user.navigation.page.val
          var sobj = {
              rows: {}
            }
            //is show!
          for( var i in caller.data ) {
            if( !caller[ i ] ) {
              sobj.rows[ '$$' + i ] = new SingleRow( {
                data: caller.data[ i ]
              } )
            }
            keys.push( i )
          }

          caller.indicator.title.text = {
            dictionary: 'text.nav.' + page
          }

          caller.indicator.list.data = keys

          caller.set( sobj )

          this._parent.focusState._update()
        }
        update()
      }
    }
  }
} ).Class

},{"../../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","./elements":"/Users/youzi/dev/mtv-play/components/first/tv/row/elements.js","./item":"/Users/youzi/dev/mtv-play/components/first/tv/row/item.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/row/show.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var app = require( 'old-vigour-js/app/' )
var dictionary = require( 'old-vigour-js/app/dictionary' )
var VObj = require( 'old-vigour-js/object' )
var Item = require( './item' )
var elements = require( './elements' )
var raf = require( 'old-vigour-js/browser/animation/raf' )

var SingleRow = new Element( {
  css: 'tv-row',
  collection: {
    data: 'episodes',
    element: new Item( {
      events: {
        arrowLeft: function() {
          if( this.$prev.val ) {
            this.$prev.val.$focus()
          } else {
            var focusState = app.focusState.from
            if( this.parent && this.parent.data._parent && this.parent.data._parent._name === 'seasons' ) {
              focusState._val = 'row'
              app.user.navigation.page.$userOrigin = app.user.navigation.page.val || 'shows'
            }
          }
        },
        back: function() {
          var focusState = app.focusState.from
          focusState._val = 'row'
          app.user.navigation.page.$userOrigin = app.user.navigation.page.val || 'shows'
        }
      }
    } )
  }
} ).Class

var showRow = module.exports = exports = new elements.RowView( {
  indicator: {
    title: {
      text: {
        data: 'title'
      }
    },
    list: {
      text: {
        dictionary: 'text.season',
        add: ' '
      },
      collection: {
        data: 'seasons'
      }
    }
  },
  rows: {
    model: {
      subscription: {
        title: true,
        seasons: {
          $: {
            number: true,
            episodes: {
              $: {
                img: true,
                title: true
              }
            }
          }
        }
      },
      block: true
    },
    collection: {
      element: SingleRow,
      data: 'seasons'
    }
  },
  on: {
    $remove: {
      defer: function( update, args ) {
        if( this._deferRafid ) {
          window.cancelAnimationFrame( this._deferRafid )
        }
      }
    },
    $parent: {
      defer: function( update, args ) {

        var caller = this._parent._caller
        var first
        var obj
        var _this = this

        if( caller._deferRafid ) {
          window.cancelAnimationFrame( caller._deferRafid )
        }

        if( caller && caller.data ) {
          var keys = []
          var page = app.user.navigation.page.val
          if( caller.data._parent._name === 'shows' ) {
            caller.data.get( 'seasons' ).is( 'loaded', function() {
              if( caller.rows && caller.rows.children[ 0 ] ) {
                caller.rows.children[ 0 ].children[ 0 ].$focus()
              } else {
                caller._deferRafid = raf( function() {
                  if( caller.rows && caller.rows.children[ 0 ] ) {
                    caller.rows.children[ 0 ].children[ 0 ].$focus()
                  }
                } )
              }
            } )
          }
        }
        update()
      }
    }
  }
} ).Class

},{"./elements":"/Users/youzi/dev/mtv-play/components/first/tv/row/elements.js","./item":"/Users/youzi/dev/mtv-play/components/first/tv/row/item.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/show.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var Data = require( 'old-vigour-js/data' )
  .inject( require( 'old-vigour-js/data/selection' ) )
var Row
var app = require( 'old-vigour-js/app/' )

module.exports = function( update, args ) {
  var show = this.$userOrigin
  var parent = this._parent
  var caller = parent._caller
  var pagedata = {}
  var element

  caller.x = {
    multiply: 0
  }

  if( show ) {
    caller.data = show
    if( !Row ) {
      Row = require( './row/show' ) // app.focusState.val === 'grid' ? Grid : Row 
    }
    var seasons = show.get( 'seasons' )
    element = Row
    pagedata = show.from
  }

  if( element ) {
    caller.transition = {
      element: element,
      $params: {
        data: pagedata,
        info: {
          data: {}
        }
      },
      $options: {
        force: true
      }
    }
    update()
  } else {
    update( true )
    throw new Error( 'wrong tv - show.js , no element!' )
  }

}

},{"./row/show":"/Users/youzi/dev/mtv-play/components/first/tv/row/show.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/data/selection":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/selection.js"}],"/Users/youzi/dev/mtv-play/components/first/tv/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/first/watch/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var Icon = require('../../icon')
var Player = require('../../player')
var Favourite = require('../favourite')
var app = require('old-vigour-js/app/')
var Seasons = require('../seasons')
var Topbar = require('../menu').Topbar
var text = require('../../text')
var Epg = require('../epg')
var cases = require('old-vigour-js/browser/cases')
var Switcher = require('old-vigour-js/app/ui/switcher')
var landscape
var dictionary = require('old-vigour-js/app/dictionary')

var seasonText = dictionary.get('text.season')
var specialsText = dictionary.get('text.specials')

var ad = require('../../ad')
var MediumAd = ad.Medium
var BillboardAd = ad.Billboard

Switcher = new Switcher({
  onTransition: function(current, last) {
    if (last) last.remove()
    this.add(current)
  }
}).Class

var Info = new Element({
  touch: {
    scrollbar: 'y'
  },
  phone: {
    h: app.h.val - Topbar.base.h.val - app.w.val * 9 / 16
  },
  header: {
    title: new text.Title({
      text: {
        data: 'media.title'
      }
    })
  },
  description: new text.Description({
    '!phone.ad': new MediumAd()
  })
}).Class

var ChannelInfo = new Info().Class

var EpisodeInfo = new Info({
  header: {
    add: [new Icon({
      icon: 'share',
      name: 'share',
      events: {
        click: function() {
          var popup = this.checkParent('on.popup', true).from
          popup.data = this.checkParent('data', true).media.from
          popup.val = 'share'
        }
      }
    }), 'title'],
    subtitle: {
      text: {
        val: {
          data: 'season.number',
          transform: function(v, cv) {
            return cv !== 9000 ? seasonText.val + ' ' : specialsText.val
          },
          listen: dictionary
        },
        add: [' ', {
          data: 'season.number',
          transform: function(v, cv) {
            return cv !== 9000 ? cv : ' '
          }
        }, ' ', {
          dictionary: 'text.episode'
        }, ' ', {
          data: 'media.number'
        }]
      }

    }
  }
}).Class

var ChannelTitle = new text.Title({
  text: {
    data: 'media.title'
  }
}).Class

var ShowTitle = new text.Title({
  text: {
    data: 'show.title'
  },
  favourite: new Favourite()
}).Class

function updateLayout(update) {
  var parent = this._parent
  var caller = parent._caller
  var w = window.innerWidth
  var h = window.innerHeight
  var data = caller.data
  var type = 'side'

  landscape = w > h

  if (!this.from.val) return

  if (landscape) {
    if (!caller[type]) {
      if (caller.media[type]) {
        caller.media[type].remove()
      }

      caller.node.style.tableLayout = 'auto'

      caller.add(new Switcher({
        name: type,
        data: data
      }), 'media')

      caller.media.info.set({
        display: 'block',
        h: {
          val: app.h,
          sub: [Topbar.base.h.val, {
            val: app.w,
            sub: 400,
            multiply: 9 / 16
          }]
        }
      })

      parent.channel._update()

    }

  } else {
    if (!caller.media[type]) {
      if (caller[type]) {
        caller[type].remove()
      }

      caller.media.add(new Switcher({
        name: type,
        data: data
      }), 'info')

      caller.node.style.tableLayout = 'fixed'

      caller.media.info.set({
        display: 'table-cell',
        h: {
          val: app.h,
          sub: [Topbar.base.h.val, {
            val: app.w,
            sub: 0,
            multiply: 9 / 16
          }]
        }
      })

      parent.channel._update()

    }
  }

  if (!caller.on.resize.val) {
    caller.set({
      on: {
        resize: app.w
      }
    })
  }

  update()
}

module.exports = new Element({
  css: 'first-watch',
  x: {
    translate: true
  },
  model: {
    subscription: {
      title: true,
      number: true,
      description: true
    }
  },
  on: {
    channel: {
      val: false,
      defer: function(update) {
        var caller = this._parent._caller,
          info = caller.media.info,
          side = caller.side || caller.media.side,
          header = caller.pageheader && caller.pageheader.container,
          params = {
            // data: caller.data
          },
          isChannel = cases.$isOnChannel.val

        if (caller.data) {
          params.data = caller.data
          params.data.media = app.user.navigation.media
        }

        if (isChannel === false) {
          info.transition = {
            element: EpisodeInfo,
            $params: params
          }

          if (header) {
            header.transition = {
              element: ShowTitle,
              $params: params
            }
          }

          if (side) {
            params.on = {
              media: app.user.navigation.media.$userOrigin
            }

            //quick fix dirty!
            if (!landscape) {
              params.list = {
                h: {
                  sub: {
                    add: {
                      val: app.w,
                      divide: 16 / 9
                    }
                  }
                }
              }
            }

            side.transition = {
              element: Seasons,
              $params: params
            }

            side.css = 'first-seasons seasons-only'
          }
        } else if (isChannel === true) {
          if (cases.phone) info.css = 'first-seasons first-epg'

          info.transition = {
            element: cases.phone ? Epg : ChannelInfo,
            $params: params
          }

          if (header) {
            header.transition = {
              element: ChannelTitle,
              $params: params
            }
          }

          if (side) {

            if (!landscape) {
              params.list = {
                h: {
                  sub: {
                    add: {
                      val: app.w,
                      divide: 16 / 9
                    }
                  }
                }
              }
            }

            side.transition = {
              element: Epg,
              $params: params
            }
            side.css = 'first-seasons first-epg'
          }
        }

        update()
      }
    },
    $render: {
      defer: function(update) {
        var parent = this._parent
        if (cases.tablet) {
          parent.resize._update()
        }
        parent.channel._update()
        update()
      }
    }
  },
  tablet: {
    on: {
      resize: {
        defer: updateLayout
      }
    }
  },
  media: {
    player: new Player.Holder(),
    info: new Switcher()
  },
  desktop: {
    add: [ new Element({
      name: 'pageheader',
      ad: new BillboardAd(),
      container: new Switcher()
    }), 'media'],
    margin: {},
    side: new Switcher()
  }
}).Class


},{"../../ad":"/Users/youzi/dev/mtv-play/components/ad/index.js","../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../player":"/Users/youzi/dev/mtv-play/components/player/index.js","../../text":"/Users/youzi/dev/mtv-play/components/text/index.js","../epg":"/Users/youzi/dev/mtv-play/components/first/epg/index.js","../favourite":"/Users/youzi/dev/mtv-play/components/first/favourite/index.js","../menu":"/Users/youzi/dev/mtv-play/components/first/menu/index.js","../seasons":"/Users/youzi/dev/mtv-play/components/first/seasons/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/first/watch/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/app/ui/switcher":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/first/watch/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/icon/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var cases = require( 'old-vigour-js/browser/cases' )
var icon = new Element( {
  css: 'ui-icon'
} )
var map = {
  discover: '\ue600',
  shows: '\ue601',
  tv: '\ue602',
  settings: '\ue603',
  cast: '\ue604',
  play: '\ue605',
  pause: '\ue606',
  fullscreen: '\ue607',
  pullback: '\ue608',
  swipeup: '\ue609',
  close: '\ue60a',
  closesmall: '\ue60b',
  dropdown: '\ue60c',
  arrowright: '\ue60d',
  search: '\ue60e',
  cart: '\ue60f',
  email: '\ue610',
  favorite: '\ue611',
  favoriteadd: '\ue612',
  favoriteremove: '\ue623',
  locked: '\ue613',
  logout: '\ue614',
  profile: '\ue615',
  share: '\ue616',
  arrowleft: '\ue617',
  exitfullscreen: '\ue618',
  right: '\ue619',
  wrong: '\ue61a',
  logo: '\ue61b',
  scan: '\ue61c',
  facebook: '\ue61d',
  twitter: '\ue61e',
  phone: '\ue61f',
  iphone: '\ue61f',
  android: '\ue61f',
  tablet: '\ue620',
  desktop: '\ue621',
  laptop: '\ue622',
  menu: '\ue624',
  leftnav: '\ue625',
  rightnav: '\ue626',
  noresult: '\ue627',
  volume: '\ue628',
  rewind: '\ue629',
  fastforward: '\ue62a',
  disconnect: '\ue62b',
  monster: '\ue62c',
  lockedRight: '\ue62d',
  watching: '\ue62e',
  notWatched: '\ue62f',
  airplay: '\ue630',
  gender: '\ue631',
  age: '\ue632',
  newsletter: '\ue633',
  warning: '\ue634',
  whatsapp: '\ue635',
  loader1: '\ue636',
  loader2: '\ue637',
  loader3: '\ue638',
  loader4: '\ue639',
  lockedContent: '\ue63a',
  fullscreenAlt: '\ue63b',
  exitfullscreenAlt: '\ue63c',
  playAlt: '\ue63d',
  pauseAlt: '\ue63e',
  lockedContentAlt: '\ue63f',
  empty: ' '
}

icon.extend( {
  icon: function( val ) {
    var v = '<span>' + ( map[ val.val ] || '' ) + '</span>'
    var value = this.node.innerHTML
    var divindex = value.indexOf( '<div' )
    if( ~divindex ) v += value.slice( divindex )
    this.html = v;
  }
} )

module.exports = exports = icon.Class
exports.map = map

},{"./style.less":"/Users/youzi/dev/mtv-play/components/icon/style.less","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/icon/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/common.less"][0].apply(exports,arguments)
},{}],"/Users/youzi/dev/mtv-play/components/img/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var app = require('old-vigour-js/app/')
var animationFrame = require('old-vigour-js/browser/animation/frame')
var img = new Element()
var cases = require('old-vigour-js/browser/cases')
var config = require('old-vigour-js/util/config')
var timer
var density = cases.retina ? 2 : 1
var imgUrl = config.imgOrigin

module.exports = exports = new img.Class( {
  opacity: {
    val: 0
  },
  background: {
    data: 'img',
    load: function( t ) {
      if( t ) t.opacity = 1
    },
    transform: function( val, cv ) {
      if( !cv ) return

      var w = Math.ceil( ( this.w || this.checkParent( 'w', true ) ).val ) || app.w.val
      var h = Math.ceil( ( this.h || this.checkParent( 'h', true ) ).val ) || app.h.val
      var imgrange = val._parent.range
      var rect

      if( imgrange ) {
        rect = range( w, h, imgrange.val )
        w = rect.w
        h = rect.h
      }

      return config.img + '/image/' + w * density + '/' + h * density + '?' + 'url=' + imgUrl + cv + '/original'
    }
  },
  slow: {
    opacity: 1,
    'background.load': null
  },
  css: 'ui-img'
} ).Class

exports.density = density

exports.Basic = new Element(
{ css:'ui-img'
, background:
  { data:'img'
  , load:function(t) {
      if(t) t.opacity = 1
    }
  , transform:function( v, cv ){
      if(!cv) return
      return config.img + '/image/' + this.w.val * density + '/' + this.h.val * density + '?' + 'url=' + imgUrl + cv + '/original'
    }
  },
  opacity: {
    val: 0
  },
  slow: {
    opacity: 1,
    'background.load': null
  }
} ).Class

exports.Relative = new Element( {
  css: 'ui-img',
  background: {
    data: 'img',
    load: function( t ) {
      if( t ) t.opacity = 1
    },
    transform: function( v, cv ) {
      if( !cv ) return ''
      var node = this.node
      var w = node.offsetWidth
      var h
      var _this = this
      var imgrange = v._parent.range
      var rect

      if( !w ) {
        if( !_this.rafId ) {
          _this.rafId = window.requestAnimationFrame( function() {
            if( _this.rendered ) _this.background.update( _this )
          } )
        }
        return ''
      }

      h = node.offsetHeight

      if( imgrange ) {
        rect = range( w, h, imgrange.val )
        w = rect.w
        h = rect.h
      }
      return config.img + '/image/' + w * density + '/' + h * density + '?' + 'url=' + imgUrl + cv + '/original'
    }
  },
  opacity: {
    val: 0
  },
  slow: {
    opacity: 1,
    'background.load': null
  }
} ).Class

exports.Carousel = new exports.Relative( {
  background: {
    transform: function( v, cv ) {
      if( !cv ) return ''
      var node = this.node
      var h = node.offsetHeight
      var w
      var _this = this
      var imgrange = v._parent.range
      var rect

      if( !h ) {
        if( !_this.rafId ) {
          _this.rafId = window.requestAnimationFrame( function() {
            if( _this.rendered ) _this.background.update( _this )
          } )
        }
        return ''
      }

      w = Math.ceil( Math.min( node.offsetWidth, h / 9 * 16 ) )

      if( imgrange ) {
        rect = range( w, h, imgrange.val )
        w = rect.w
        h = rect.h
      }
      return config.img + '/image/' + w * density + '/' + h * density + '?' + 'url=' + imgUrl + cv + '/original'
    }
  }
} ).Class


exports.Overlay = new exports( {
  background: {
    transform:function( v, cv ) {
      if(!cv) return ''
      var w = Math.ceil((this.w || this.checkParent('w',true)).val) || app.w.val
      var h = Math.ceil((this.h || this.checkParent('h',true)).val) || app.h.val
      return config.img + '/image/' + w * density + '/' + h * density + '?' + 'url=' + imgUrl + cv + '/original&effect=overlayBlur&overlay=overlay_lightest&radius=0&sigma=0'
    }
  }
} ).Class

exports.Intro = new exports( {
  background: {
    transform: function( v, cv ) {
      if( !cv ) return ''
      var node = this.node
      var w = node.offsetWidth
      var _this = this

      if( !w ) {
        if( !_this.rafId ) {
          _this.rafId = window.requestAnimationFrame( function() {
            if( _this.rendered ) _this.background.update( _this )
          } )
        }
        return ''
      }

      return config.img + '/image/' + w * density + '/' + node.offsetHeight * density + '?url=https://wwwmtvplay-a.akamaihd.net/img/intro/' + cv
    }
  }
} ).Class

function range( width, height, val ) {
  var ratio = height / width
  var newWidth = Math.ceil( width / val ) * val
  var newHeight = Math.ceil( newWidth * ratio )
  return {
    w: newWidth,
    h: newHeight
  }
}

},{"./style.less":"/Users/youzi/dev/mtv-play/components/img/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/animation/frame":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/frame.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/img/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/item/index.js":[function(require,module,exports){

require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
  , Icon = require('../icon')
  , Img = require('../img')
  , text = require('../text')
  , cases = require('old-vigour-js/browser/cases')
  , Input = text.Input
  , Switch = require('../button').Switcher
  , Title = text.Title
  , TitleSubtitle = new text.TitleSubtitle(
    { css:'ui-item-text'
    }).Class
  , app = require('old-vigour-js/app/')
  , user = app.user


// if(cases.phone) Img = Img.Sprite

//base item
module.exports = exports = new Element(
{ css:'ui-item'
}).Class

exports.Basic = new exports( {
  txt: new Title()
} ).Class

//used in settings, teaser
exports.IconRight = new exports.Basic( {
  righticon: new Icon( {
    icon: 'arrowright'
  } )
} ).Class

exports.IconRightSub = new exports.Basic( {
  righticon: new Icon( {
    icon: 'arrowright'
  } ),
  css: {
    addClass: 'ui-item-sub'
  },
  txt: new TitleSubtitle()
} ).Class

//used in menu, devices, lang selection
exports.IconLeft = new exports( {
  lefticon: new Icon( {
    icon: {
      data: 'icon'
    }
  } ),
  txt: new Title()
} ).Class

//used in management
exports.Block = new exports( {
  left: {
    'title.text.dictionary': 'text.all',
    'subtitle.text.dictionary': 'text.nav.shows'
  },
  center: {
    'title.text.dictionary': 'text.all',
    'subtitle.text.dictionary': 'text.nav.channels'
  },
  right: {
    'title.text.dictionary': 'text.every',
    'subtitle.text.dictionary': 'text.episode'
  },
  css: {
    addClass: 'block'
  }
} ).Class

//used in topbar, management, menuList
exports.Menu = new exports.IconLeft( {
  h: 55,
  css: {
    addClass: 'ui-item-menu'
  },
  righticon: new Icon()
} ).Class

//used in channel overview, miniplayer-phone

exports.Thumb = new exports( {
  thumb: {
    w: {
      val: 100,
      phone: 70
    },
    h: {
      val: 71,
      phone: 45
    },
    img: new Img.Basic( {
      w: {
        val: 100,
        phone: 70
      },
      h: {
        val: 71,
        phone: 45
      }
    } )
  },
  txt: new TitleSubtitle(),
  righticon: new Icon( {
    icon: 'arrowright'
  } )
} ).Class

//used in discover and overview
exports.Large = new Element(
{   crawler: {
  node: 'a',
  href: {
    data: function( data ) {
      return app.user.$parse(data).url || ''
    }
  },
  attr: {
    onclick: 'return false'
  }
}
, css:'ui-item-large'
, display:'inline-block'
, thumb:new Img({w:310,h:220})
, info:
  { txt:new TitleSubtitle()
  , description: { text: { data:'description' } }
  }
}).Class

exports.Indicator = new exports.Thumb( {
  righticon: new Icon( {
    on: {
      data: 'id'
    },
    icon: {
      data: 'access',
      transform: function( val, cv ) {

        var access = app.util.access( cv, this.data ),
          icon = ( access && ~access.indexOf( 'play' ) ) ? cases.desktop ? 'empty' : 'arrowright' : access
        return icon === 'lockedContent' ? 'lockedContentAlt' : icon

      },
      listen: [ app.user.role, app.user.purchases ]
    }
  } )
} ).Class

exports.Topbar = new exports.Menu( {
  position: 'absolute',
  name: 'topbar',
  h: 44,
  css: {
    addClass: 'ui-item-topbar'
  },
  y: {
    val: 0,
    translate: true
  },
  iosFull: {
    h: {
      add: 20
    }
  },
  txt: {
    x: {
      translate: true,
      val: 1
    }
  }
} ).Class

exports.TitleSubtitle = TitleSubtitle

exports.Switcher = new exports.IconRightSub( {
  righticon: new Element( {
    hold: new Switch()
  } )
} ).Class

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../text":"/Users/youzi/dev/mtv-play/components/text/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/item/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/item/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/loader/index.js":[function(require,module,exports){
require( './style.less' )

var Sprite = require( 'old-vigour-js/app/ui/sprite' )
var Element = require( 'old-vigour-js/app/ui/element' )
var cases = require( 'old-vigour-js/browser/cases' )

module.exports = exports = new Element( {
  css: 'ui-loader',
  append: new Sprite( {
    w: 31,
    h: 31,
    params: {
      cols: 1,
      rows: 19
    }
  } )
} ).Class

exports.Simple = new Sprite( {
  css: 'ui-loader-simple',
  'w,h': 21,
  params: {
    cols: 1,
    rows: 19
  }
} ).Class

if( !cases.ios && !cases.desktop ) {
  exports.Logo = new Element( {
    css: 'loader logo noanim',
    w: 110,
    h: 110
  } ).Class
} else {
  exports.Logo = new Sprite( {
    css: 'loader logo',
    w: 110,
    h: 110,
    params: {
      cols: 1,
      rows: 26
    } // once:true }
  } ).Class
}

},{"./style.less":"/Users/youzi/dev/mtv-play/components/loader/style.less","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/app/ui/sprite":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/sprite/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/loader/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/common.less"][0].apply(exports,arguments)
},{}],"/Users/youzi/dev/mtv-play/components/password/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )

module.exports = new Element( {
	css: 'password-input',
	container:{
		logo:{
		},
		header:{
			text:'MTV Play is currently in BETA'
		},
		subtitle:{
			text:'Enter password to continue'
		},
		field:{
			node: 'input',
		  attr: {
		    type: 'password',
		    placeholder: 'password'
		  }
		}
	}
} ).Class

},{"./style.less":"/Users/youzi/dev/mtv-play/components/password/style.less","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/password/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/player/backdrop.js":[function(require,module,exports){
require( './style.less' )

var app = require( 'old-vigour-js/app' )
var Element = require( 'old-vigour-js/app/ui/element' )
var Img = require( '../img' )
var Icon = require( '../icon' )

module.exports = new Element( {
  name: 'backdrop',
  css: 'relative-size',
  img: new Img.Relative( {
    css: 'relative-size',
    background: {
      data: 'show.img',
      load: function( t ) {
        t.opacity = 0.3
      }
    }
  } ),
  holder: {
    info: {
      title: {
        'text.dictionary': 'text.sender.remotePlaybackTitle'
      },
      txt: {
        'text.dictionary': 'text.sender.remotePlaybackSubtitle'
      }
    },
    pullback: new Icon( {
      icon: 'pullback',
      pulltext: {
        'text.dictionary': 'text.pullBack'
      }
    } )
  },
  events: {
    click: function() {
      app.user.receiver.media.$userOrigin = false
    }
  }
} ).Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../img":"/Users/youzi/dev/mtv-play/components/img/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/player/style.less","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/player/controls/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var app = require( 'old-vigour-js/app/' )
var Seekbar = require( '../seekbar' )
var videoUtil = require( 'old-vigour-js/browser/element/video/util' )
var cases = require( 'old-vigour-js/browser/cases' )

module.exports = new Element( {
  css: 'player-controls',
  container: {
    progress: {
      text: {
        data: 'mediausage.time',
        multiply: {
          data: 'media.duration'
        },
        transform: function( v, cv ) {
          return videoUtil.time( Math.abs( cv ) )
        }
      }
    },
    seekbar: new Seekbar( {
      w: {
        sub: 200
      }
    } ),
    duration: {
      text: {
        data: 'media.duration',
        transform: function( v, cv ) {
          return videoUtil.time( cv )
        }
      }
    }
  }
} ).Class

},{"../seekbar":"/Users/youzi/dev/mtv-play/components/player/seekbar/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/player/controls/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/element/video/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/video/util.js"}],"/Users/youzi/dev/mtv-play/components/player/controls/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/player/index.js":[function(require,module,exports){
require('./style.less')

var app = require('old-vigour-js/app/')
var cases = require('old-vigour-js/browser/cases')
var ua = require('old-vigour-js/browser/ua')
var Element = require('old-vigour-js/app/ui/element')
var Video = require('./video')
var Overlay = require('./overlay')
var Backdrop = require('./backdrop')
var config = require('old-vigour-js/util/config')
var density = cases.retina ? 2 : 1
var keyUpID = 'keyUpID'
var raf = require('old-vigour-js/browser/animation/raf')
var fromMediaSwitch
var prefix = ua.prefix
var version = ua.version

document.cookie = '_L1Nl9uK_DJGt_RDAVBq_=_L1Nl9uK_DJGt_RDAVBq_; domain=.mtvplay.tv'

function launchIntoFullscreen (el) {
  var element = el.node || el
  if (element.requestFullscreen) {
    element.requestFullscreen()
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen()
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen()
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen()
  } else if ((element = el.video && el.video.jqHandle.node) && element.webkitEnterFullscreen()) {
    element.webkitEnterFullscreen()
  }
}

function exitFullscreen () {
  if (document.exitFullscreen) {
    document.exitFullscreen()
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen()
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen()
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen()
  }
}

function swiped () { // make this a case!
  var mediaData = app.user.navigation.media.from
  var msMediaData = app.user.receiver.media.from
  var swiped = cases.$hasReceiver.val && msMediaData._cachedPath === mediaData._cachedPath

  return swiped
}

function updateSwipe () {
  var player = this._parent._caller
  var holder = player.parent
  var video = player.video

  if (!holder) return
  if (!cases.$isReceiver.val) {
    player._cachedW = null
    if (swiped()) {
      if (player._fullscreen) {
        player.x = app.w
      } else {
        player.y = {
          multiply: -1
        }
      }

      raf(function () {
        if (swiped()) app.playing.from.val = false
      })

      if (holder.backdrop.empty) {
        holder.set({
          backdrop: new Backdrop({
            data: player.video.data
          })
        })
      }

      return true
    } else if (player.y.multiply.val) {
      player.x = 0
      player.y = {
        multiply: 0
      }
    }
  } else if (player.__ready && !swiped) {
    return true
  }
}

// on receiver media update > update swipe & update time
function onMsMedia (update) {
  var caller = this._parent._caller
  var video = caller.video
  var videoData = video && video.data
  var mediaUsage = videoData && videoData.mediausage && videoData.mediausage.from
  var videoTime = video && video.time.from.val

  var updateTime = updateSwipe.call(this)

  if (!cases.$isOnChannel.val && updateTime && mediaUsage && (videoTime || videoTime === 0)) {
    mediaUsage.set('time', Math.abs(videoTime))
  }

  update()
}

// on media nav > update swipe
function onMedia (update) {
  if (!cases.tv && !cases.$isReceiver.val) {
    var player = this._parent._caller
    player.y._p = true
    updateSwipe.call(this)
    player.y._p = null
  }
  update()
}

// on render > set play & bind msmedia & bind media & bind fullscreen
function onRender (update) {
  var parent = this._parent,
    player = parent._caller

  app.playing.from.val = cases.tv || (!cases.$isActive.val && cases.$isReceiver.val) ? true : false

  parent.msmedia.val = {
    val: app.user.receiver.media,
    listen: [cases.$hasReceiver]
  }

  parent.media.val = app.user.navigation.media

  parent.fullscreen.val = cases.$isFullscreen

  raf(function () {
    if (player.video) {
      player.__ready = true
      player.video.$play = app.playing
      player.overlay.on.volume.val = app.volume
    }
  })

  window.player = player

  if (cases.desktop) {
    app.addEvent('keydown', function (e) {
      if (app.popup.val || (!cases.$isReceiver.val && swiped())) return

      var keyEvent = true
      // space or enter
      if (e.keyCode === 32 || e.keyCode === 13) player.togglePlay()
      // left
      else if (e.keyCode === 37) player.seekBackward()
      // right
      else if (e.keyCode === 39) player.seekForward()
      // up
      else if (e.keyCode === 38) player.volumeUp()
      // down
      else if (e.keyCode === 40) player.volumeDown()
      // F
      else if (e.keyCode === 70) player.goFullscreen()

      else keyEvent = false

      if (keyEvent) {
        e.preventDefault()
      }

    }, keyUpID)
  } else if (cases.tv) {
    player.$focus()
  }

  update()
}

// on remove > pause global play
function onRemove (update) {
  app.playing.from.val = false

  app.removeEvent(false, keyUpID)

  update()
}

function onFullscreen (update) {
  var fullscreen = this.from.val
  var player = this._parent._caller
  var fsListener = prefix === 'ms' ? (version <= 11 ? 'MSFullscreenChange' : 'fullscreenChange') : prefix +'fullscreenchange'

  if (fullscreen) {
    if (window.statusBar) window.statusBar.hide()
    else if (cases.desktop) launchIntoFullscreen(player)
    else if (cases.phone) launchIntoFullscreen(player)

    player._exitFullscreen = function (e) {
      var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement
      if (!fullscreenElement) {
        app.state.val = 'first'
      }
    }
    document.addEventListener(fsListener, player._exitFullscreen)
  } else {
    if (window.statusBar) window.statusBar.show()
    exitFullscreen()
    document.removeEventListener(fsListener, player._exitFullscreen)
  }

  raf.repeat(function () {
    if (player.background) player.background._update()
  }, 2)

  update()
}

function seekBackward () {
  var usage = this.data && this.data.mediausage
  if (usage && usage.time && !cases.$isOnChannel.val) usage.time.from.val = Math.max(0, Math.abs(usage.time.from.val) - 0.01)
}

function seekForward () {
  var usage = this.data && this.data.mediausage
  if (usage && usage.time && !cases.$isOnChannel.val) usage.time.from.val = Math.min(1, Math.abs(usage.time.from.val) + 0.01)
}

function togglePlay () {
  app.playing.from.val = !app.playing.val
}

function volumeUp () {
  if (app.volume.val <= 0.9) app.volume.from.val += 0.1
}

function volumeDown () {
  if (app.volume.val >= 0.1) app.volume.from.val -= 0.1
}

module.exports = exports = new Element({
  on: {
    fullscreen: {
      defer: onFullscreen
    },
    msmedia: // update y and also time on msmedia update
    {
      defer: onMsMedia
    },
    media: // update y on media navigation
    {
      defer: onMedia
    },
    $render: {
      defer: onRender
    },
    $remove: {
      defer: onRemove
    }
  },
  tv: {
    css: 'base-player fullscreen-player',
    events: {
      back: function () {
        app.state.val = 'first'
      },
      click: togglePlay,
      arrowLeft: seekBackward,
      arrowRight: seekForward,
      $focus: function (e) {}
    }
  },
  chromecast: {
    css: 'base-player fullscreen-player'
  },
  x: {
    val: 0,
    animation: {
      time: 24,
      easing: 'outCubic',
      done: function (cv) {
        if (cv) {
          this.y._p = true
          this.y = {
            multiply: -1
          }
          this.y._p = null
          this.x._p = true
          this.x = 0
          this.x._p = null
          goFullscreen.exit.call(this)
        }
      }
    }
  },
  y: {
    translate: true,
    val: app.w,
    defer: function (update, args) {
      var _this = this
      if (!this._caller.rendered) {
        update(true)
        return true
      }
      if (args[2] === false) {
        raf(function () {
          _this._p = true
          update()
          _this._p = null
        })
      } else {
        update()
      }
    },
    transform: function (v, cv) {
      if (this._cachedW !== cv) {
        this._cachedW = cv
        this._cachedY = this.node.offsetHeight
      }
      var value = this._cachedY || (this._cachedY = this.node.offsetHeight)
      if (value) return value
    },
    multiply: {
      val: 0,
      animation: {
        time: 24,
        easing: 'outCubic'
      }
    }
  },
  video: new Video(),
  overlay: new Overlay(),
  adMessage: {
    text: {
      dictionary: 'text.advertisement'
    },
    display: {
      val: 'none',
      $isPlayingAd: 'block'
    },
    touch: {
      events: {
        click: function () {
          var viacomPlayer = this.parent.video.jqHandle
          if (viacomPlayer && !(cases.native && cases.ios && !window.device)) {
            var a = window.open
            window.open = function (url) {
              window.open = a
              app.api.url.val = url
            }
            viacomPlayer.invokeAd()
          }
        }
      }
    }
  },
  background: {
    data: 'media.img',
    $bubble: {
      self: true
    },
    transform: function (v, cv) {
      if (!cv) return ''

      var node = this.node,
        w = node.offsetWidth,
        _this = this

      if (!w) {
        if (!_this.rafId) {
          _this.rafId = raf(function () {
            if (_this.rendered) _this.background.update(_this)
          })
        }
        return ''
      }

      return config.img + '/image/' + cv + '/' + w * density + '/' + node.offsetHeight * density
    }
  }
}).Class

var goFullscreen = cases.phone
  ? cases.native
    ? require('./phone-fullscreen')
    : function () {
      cases.$isFullscreen.val = !cases.$isFullscreen.val
    }
  : function () {
  if (cases.$isFullscreen.val) {
    var user = app.user,
      receiver = cases.$isReceiver.val,
      mediadata = this.checkParent('data.media', true),
      seasondata

    if (receiver) {
      if (mediadata) {
        if (mediadata._parent._name === 'episodes') {
          seasondata = mediadata._parent._parent
          user.navigation.season.$userOrigin.val = seasondata
          user.navigation.show.$userOrigin.val = seasondata._parent._parent
        }
        user.navigation.media.$userOrigin = mediadata.from
      }
      user.activeClient.$userOrigin = user.cloud.client.from
      user.receiver.media.$userOrigin = false
    } else {
      app.state.val = 'first'
    }
  } else {
    // app.playing.from.val = true
    app.state.val = 'player'
  }
}

exports.base.define({
  seekBackward: seekBackward,
  seekForward: seekForward,
  togglePlay: togglePlay,
  volumeUp: volumeUp,
  volumeDown: volumeDown,
  goFullscreen: goFullscreen
})

exports.Holder = new Element({
  css: 'player-holder',
  backdrop: {
    empty: true
  },
  player: new exports({
    css: {
      val: 'base-player windowed-player',
      $isFullscreen: !cases.phone && 'base-player fullscreen-player'
    }
  })
}).Class

},{"./backdrop":"/Users/youzi/dev/mtv-play/components/player/backdrop.js","./overlay":"/Users/youzi/dev/mtv-play/components/player/overlay/index.js","./phone-fullscreen":"/Users/youzi/dev/mtv-play/components/player/phone-fullscreen.js","./style.less":"/Users/youzi/dev/mtv-play/components/player/style.less","./video":"/Users/youzi/dev/mtv-play/components/player/video/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/player/overlay/index.js":[function(require,module,exports){
var app = require('old-vigour-js/app/')
var cases = require('old-vigour-js/browser/cases')
var Element = require('old-vigour-js/app/ui/element')
var Controls = require('../controls')
var Icon = require('../../icon')
var Img = require('../../img')
var Play = require('./play')
var Volume = require('../volume')
var dictionary = require('old-vigour-js/app/dictionary')
var specialsText = dictionary.get('text.specials')

function swipeUp(e) {
  var data = this.checkParent('_d', true)
  e.prevent = true
  app.user.receiver.media.$userOrigin.val = data.media.from
}

var Clickable = new Element({
  on: {
    data: 'media.id'
  },
  buttons: {
    play: new Play({
      display: !cases.phone && {
        data: 'media.access',
        transform: function (val, cv) {
          var icon = app.util.access(cv, this.data && this.data.media && this.data.media.from)
          return (icon && ~icon.indexOf('play')) ? 'none' : 'inline-block'
        }
      }
    }),
    swipe: new Icon({
      icon: 'swipeup',
      display: {
        data: 'media.access',
        transform: function (cv) {
          var media = this.data && this.data.media && this.data.media.from,
            accesAllowed = media && !(media._parent && media._parent._name === 'channels' && app.user.role.val === 3) && (cases.$isUpgraded.val || (media.access && !media.access.val) || (media.val && media.val.access && !media.val.access.val)),
            showSwipeButton = cases.$hasReceiver.val && accesAllowed

          return showSwipeButton ? 'inline-block' : 'none'
        },
        listen: [cases.$hasReceiver, app.user.role, app.user.purchases]
      },
      events: {
        click: swipeUp
      }
    })
  },
  events: {
    click: !cases.touch ? function () {
      app.playing.from.val = !app.playing.val
    } : function () {
      var opacity = this.parent.opacity
      opacity.val = opacity.val ? 0 : 1
    }
  }
}).Class

var PointerElement = new Element().Class

PointerElement.base.extend({
  pointerEvents: function (val) {
    this.node.style.pointerEvents = val.val
  }
})

module.exports = new PointerElement({
  on: {
    $remove: {
      defer: function (update) {
        var overlay = this._parent._caller
        if (overlay._timer) {
          clearTimeout(overlay._timer)
        }
        update()
      }
    },
    volume: {
      defer: function (update) {
        var overlay = this._parent._caller
        overlay.opacity.val = 1
        update()
      }
    }
  },
  opacity: {
    val: 1,
    defer: function (update, args) {
      var caller = this._caller

      if (this._block) return true

      if (this._val === 1) {
        if (caller._timer) clearTimeout(caller._timer)
        caller._timer = setTimeout(function () {
          if (app.playing.val) caller.opacity.val = 0
          caller._timer = null
        }, 2500)
      }

      update()
    },
    listen: app.playing
  },
  infoholder: {
    display: {
      val: 'table',
      $isPlayingAd: 'none',
      $isOnChannel: 'none'
    },
    '!phone.thumb': new Img({
      h: {
        val: 50,
        $isFullscreen: 110
      },
      w: {
        self: 'h',
        defer: function (update) {
          this._caller.background._update()
          update()
        }
      },
      background: {
        data: 'show.img'
      }
    }),
    titles: {
      showtitle: {
        text: {
          data: 'media.title'
        }
      },
      showsubtitle: {
        text: {
          val: {
            dictionary: 'text.season',
            transform: function (v, cv) {
              return cv && cv[0]
            },
            add: {
              data: 'season.number',
              transform: function (v, cv) {
                var realNumber = this.data && this.data.media.from._parent._parent.number,
                  realNumberVal = realNumber && realNumber.val
                if (realNumberVal) cv = realNumberVal
                return (cv > 9 ? cv : '0' + cv) + ' '
              }
            }
          },
          add: [{
            val: {
              dictionary: 'text.episode',
              transform: function (v, cv) {
                return cv && cv[0]
              }
            }
          }, {
            data: 'media.number',
            transform: function (v, cv) {
              return (cv > 9 ? cv : '0' + cv)
            }
          }],
          transform: function (v, cv) {
            var t = this.text._val
            return t && t.add.__lval == 9000 ? specialsText.val : cv
          }
        }
      }
    }
  },
  clickable: new Clickable(),
  '!iosBrowser.controls': {
    css: {
      val: '',
      $isOnChannel: {
        val: 'on-channel',
        $isPlayingAd: ''
      }
    },
    on: {
      data: 'media.id'
    },
    left: new Play(),
    display: {
      data: 'media.access',
      transform: function (val, cv) {
        return app.util.access(cv, this.data && this.data.media && this.data.media.from) === 'lockedContent' ? 'none' : 'table'
      },
      listen: [app.user.role, app.user.purchases]
    },
    center: new Controls({
      container: {
        display: {
          val: 'block',
          $isOnChannel: 'none',
          $isPlayingAd: 'none'
        },
        seekbar: {
          bg: {
            seekLoader: {
              opacity: {
                val: 0,
                $isLoadingVideo: 1
              }
            }
          }
        }
      },
      adMessage: {
        text: {
          dictionary: 'text.countdown'
        },
        display: {
          val: 'none',
          $isPlayingAd: 'block'
        }
      }
    }),
    '!tv.right': {
      volume: {
        holder: new Volume({
          bars: {
            data: 'volume'
          }
        })
      },
      fullscreen: new Icon({
        icon: {
          val: 'fullscreen',
          $isFullscreen: 'exitfullscreen'
        },
        events: {
          click: function () {
            var player = this.checkParent('player', true)
            if (player) player.goFullscreen()
          }
        }
      })
    }
  },
  events: {
    down: function (e) {
      var opacity = this.opacity
      if (cases.$isFullscreen.val && !opacity.val) {
        e.prevent = true
        opacity.val = 1
      }
    }
  },
  desktop: {
    pointerEvents: {
      val: 'auto',
      $isPlayingAd: 'none'
    },
    events: {
      move: function () {
        var opacity = this.opacity
        if (!opacity.val) {
          opacity.val = 1
          opacity._block = true
          setTimeout(function () {
            opacity._block = null
          }, 1000)
        }
      }
    }
  }
}).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../controls":"/Users/youzi/dev/mtv-play/components/player/controls/index.js","../volume":"/Users/youzi/dev/mtv-play/components/player/volume/index.js","./play":"/Users/youzi/dev/mtv-play/components/player/overlay/play.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/player/overlay/play.js":[function(require,module,exports){
var Icon = require( '../../icon' ),
  cases = require( 'old-vigour-js/browser/cases' ),
  app = require( 'old-vigour-js/app/' )

module.exports = exports = new Icon( {
  on: {
    data: 'media.id'
  },
  icon: {
    val: {
      data: 'media.access',
      transform: function( val, cv ) {
        var icon = app.util.access( cv, this.data && this.data.media && this.data.media.from )
        return icon
      }
    },
    $playing: cases.phone ? 'pause' : 'pauseAlt',
    transform: function( v, cv ) {
      if( !this._loading ){
        this.rotate = 0
      }
      return this._loading ? 'loader2' : cv
    },
    listen: [
      app.user.role,
      app.user.purchases.from
    ]
  },
  rotate: {
    val: 0,
    animation: {
      complete: function() {
        var rotate = this.rotate
        rotate._p = true
        rotate = 0
        rotate._p = false
        this._loading = false
        this.icon.update( this )
      }
    }
  },
  events: {
    click: function( e ) {
      e.prevent = true
      app.playing.from.val = !app.playing.val
    }
  }
} ).Class

exports.base.define( {
  load: function() {
    this._loading = true
    this.icon.update( this )
    this.rotate = this.rotate.val + 360
  }
} )

/*
, trial = user.role.val === 3

*/

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/player/phone-fullscreen.js":[function(require,module,exports){
var app = require('old-vigour-js/app/')
var cases = require('old-vigour-js/browser/cases')

function fullscreen ( exit ) {
  var page = this.checkParent('media', true)
  var switcher = page.checkParent('switcher', true)
  var player = page.player.player
  var topbar = switcher.checkParent('topbar', true)
  var controls = player.overlay.controls
  var fullscreenButton = controls.right.fullscreen
  var seekbar = controls.center.container.seekbar
  var miniplayer = this.checkParent('miniplayer', true)
  var style = player.node.style
  var _this = this

  if ( window.StatusBar) {
    if ( exit ) window.StatusBar.show()
    else window.StatusBar.hide()

    if ( player._fullscreen === void 0) {
      player.setSetting({
        name: 'StatusBar',
        remove: function () {
          window.StatusBar.show()
          if ( this._listener) app.h.removeListener(this._listener)
        }
      })
    }
  }

  var topbarHeight = topbar.node.offsetHeight

  player.set({
    rotate: exit ? 0 : 90,
    x: 0
  })

  player.adMessage.node.style.zIndex = exit ? null : '1'
  player.overlay.node.style.zIndex = exit ? null : '1'
  switcher.node.style.zIndex = exit ? null : '1'
  style.zIndex = exit ? null : '1'
  style.margin = exit ? '0' : '-' + topbarHeight + 'px ' + app.w.val + 'px'
  style.width = exit ? null : app.h.val + 'px'
  style.height = exit ? null : app.w.val + 'px'
  page.node.style.overflow = exit ? null : 'visible'

  if ( player._listener) app.h.removeListener(player._listener)

  if ( !exit) {
    player._listener = function () {
      style.width = app.h.val + 'px'
    }
    app.h.on(player._listener)
  }

  fullscreenButton.set({
    icon: exit ? 'fullscreen' : 'exitfullscreen',
    events: {
      click: exit ? exports : function () {
        fullscreen.call(this, true)
      }
    }
  })

  seekbar._left = exit ? false : true
  player._fullscreen = exit ? false : true
}

module.exports = exports = function () {
  fullscreen.call(this)
}

exports.exit = function () {
  fullscreen.call(this, true)
}

},{"old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/player/players/viacom.js":[function(require,module,exports){
var ua = require('old-vigour-js/browser/ua')
var _ios = ua.platform === 'ios'
var app = require('old-vigour-js/app/')
var cases = require('old-vigour-js/browser/cases')
var config = require('old-vigour-js/util/config')

module.exports = exports = require('old-vigour-js/browser/element/video/html5')

function setTime (val, force) {
  this._correctTime = val
  if (!this.channel && this._ready && this._time !== val) {
    if (this.jqHandle && (!this.__paused || force)) {
      this.tset = null
      this.out = null
      this.cnt = null
      this.jqHandle.setCurrentTime(Math.abs(Math.round(val)))
      this._time = val
    } else {
      this.tset = true
    }
  }
}

function createPlayer (t, cb) {
  var country = app.country || app.region.val
  if (!country || !~config.availableRegions.indexOf(country.toUpperCase())) {
    cases.$allowPlayback.val = false
    app.playing.from.val = false
    return
  }

  if (typeof VIACOM === 'undefined') {
    app.api.player.once('success', function () {
      exports.settings = app.api.player.settings
      exports.adsEnabled = exports.settings.ads.enabled
      if (t.rendered) createPlayer(t, cb)
    })
    app.api.player.val = true
    return
  }

  t.addEvent('down', function (e) {
    if (!cases.$isPlayingAd.val) {
      e.preventDefault()
    }
  })

  if (t.data && t.data.media) {
    if (t.data.media.from.videolang) {
      exports.settings.localization.language = t.data.media.from.videolang.val
    }
  }

  if (cases.tv) {
    exports.settings.force = 'html5'
    exports.settings.html5smartTVMode = 'Samsung'
  } else if (cases.chromecast) {
    exports.settings.force = 'html5'
    exports.settings.html5smartTVMode = 'Chromecast'
    exports.settings.ads.enabled = false
  }

  exports.settings.ads.fw_ssid = exports.settings.ads.viralSID
  t.jqHandle = new window.VIACOM.Mediaplayer(
    '.video', exports.settings, {
      controls: false,
      'webkit-playsinline': true
    }, app.api.player.debug
  )

  t.jqHandle.addEventListener('error', function (error) {
    console.error(error)
  })

  t.jqHandle.addEventListener('ended', function (e) {
    app.playing.from.val = false
  })

  t.jqHandle.addEventListener('ads:rollPlaying', function (e) {
    cases.$isPlayingAd.val = true
  })

  t.jqHandle.addEventListener('ads:rollEnded', function (e) {
    cases.$isPlayingAd.val = false
  })

  var video = t.jqHandle.proxy.player && t.jqHandle.proxy.player.video
  if (video) {
    video.setAttribute('webkit-playsinline', '"true"')
    video.removeAttribute('controls')

    if (_ios) {
      video.addEventListener('webkitendfullscreen', function () {
        window.requestAnimationFrame(function () {
          document.body.scrollTop = 0
        })
        t.pause()
        app.playing.from.val = false
      }, false)
    }

    t.video = video
    t.setEvents()
  }

  t.node.style.backgroundColor = 'black'

  exports.protoNew.call(t)

  if (cb) {
    cb()
  }
}

exports.settings = app.api.player.settings

exports.protoNew = exports.new

exports.new = function () {}

exports.setEvents = false

function initVideo (_this, src) {
  var type
  _this._correctTime = Math.abs(_this.time.val) * _this.duration.from.val
  if (src && typeof src === 'string') {
    if (_this.data.media && ~_this.data.media.from._path.indexOf('channels')) {
      type = 'simulcast_stream'
    } else {
      type = 'local_playlist'
    }

    _this._correctTime = void 0
    console.info('starting load src:', src)
    _this.jqHandle.load(
      type,
      src, {
        startTime: Math.abs(_this.time.val) * _this.duration.from.val || void 0,
        simulcastApiKey: exports.settings.simulcastApiKey
      },
      function (obj) {
        console.info('done load src:', src)
        var skipTo = window.$.H5P.Player.prototype.skipTo
        window.$.H5P.Player.prototype.skipTo = function(skipValue) {
          console.error('skipTo:', skipValue)
          return skipTo.apply(this, arguments)
        }

        _this._ready = true
        if (!cases.phoneBrowser) {
          app.playing.from.val = true
        }
        if (_this._correctTime !== void 0) {
          setTime.call(_this, Math.abs(_this._correctTime), true)
        }

      },
      'http://api.mtvnn.com/v2/mrss.xml?uri=mgid:sensei:video:mtvnn.com:' + type + '-' + src
    )
  }
}

exports.play = function (val) {
  var _this = this
  var src

  if (val) {
    if (!_this.jqHandle || !_this.__src) {
      src = _this.src.val
      _this.__src = src

      if (!_this.jqHandle) {
        createPlayer(_this, function () {
          initVideo(_this, src)
        })
      } else {
        initVideo(_this, src)
      }
    } else if (_this.jqHandle) {
      if (_this.tset) {
        setTime.call(_this, Math.abs(_this.time.val) * _this.duration.from.val, true)
      }
      _this.jqHandle.play()
    }
    _this.tset = null
  } else if (_this.jqHandle) {
    _this.jqHandle.pause()
  }
}

exports.volume = function (val) {
  var volume = val.val
  if (this.jqHandle && !isNaN(volume)) {
    this.jqHandle.setVolume(volume)
  }
}

exports.time = {
  set: setTime,
  get: function (val) {
    var time = this.jqHandle && this.jqHandle.getCurrentTime()
    // console.error("time:", time, time / this.duration.from.val, this.duration.from.val, val.val)
    return time / this.duration.from.val || val.val
  }
}

exports.remove = function (val) {
  if (this.jqHandle) {
    this.jqHandle.destroy()
  }
  this.jqHandle = null
  this.video = null
}

exports.src = function (val) {
  var src = val.val
  if (this.__src !== src) {
    this.__src = null
    if (this.jqHandle) {
      this.node.style.backgroundColor = null
      this.jqHandle.destroy()
      this.jqHandle = null
      this._ready = null
    } else if (cases.phoneBrowser && this.rendered) {
      var _this = this
      createPlayer(_this)
    } else {
      app.playing.from.val = true
    }
  }
}

},{"old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/element/video/html5":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/video/html5.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/player/seekbar/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'old-vigour-js/app/ui/element' )
var app = require( 'old-vigour-js/app/' )
var ua = require( 'old-vigour-js/browser/ua' )
var cases = require( 'old-vigour-js/browser/cases' )
var videoUtil = require( 'old-vigour-js/browser/element/video/util' )
var Icon = require( '../../icon' )
var _limitUpdates = ua.platform === 'ios' || ua.platform === 'android'

var setTime = ua.prefix === 'ms' ? function (e) {
  if (cases.$isPlayingAd.val) return

  var rect = this.node.getBoundingClientRect()
  var x
  var nr

  if (this._left) {
    x = rect.top
    nr = (e.pageY - x) / rect.height
  } else if (this._right) {
    x = rect.top
    nr = (rect.height - (e.pageY - x)) / rect.height
  } else {
    x = rect.left
    nr = (e.pageX - x) / (rect.right - x)
  }

  var val = nr > 1 ? 1 : nr < 0 ? 0 : nr
  if (val !== this._prevVal) {
    this.seek.data.mediausage.$userOrigin.set('time', val)
    this._prevVal = val
  }
} : function (e) {
  if (cases.$isPlayingAd.val) return

  var rect = this.node.getBoundingClientRect()
  var x
  var nr

  if (this._left) {
    x = rect.top
    nr = (e.y - x) / rect.height
  } else if (this._right) {
    x = rect.top
    nr = (rect.height - (e.y - x)) / rect.height
  } else {
    x = rect.left
    nr = (e.x - x) / (rect.right - x)
  }

  var val = nr > 1 ? 1 : nr < 0 ? 0 : nr
  if (val !== this._prevVal) {
    this.seek.data.mediausage.$userOrigin.set('time', val)
    this._prevVal = val
  }
}

var seekbar = new Element({
  css: 'ui-seekbar',
  bg: {},
  seek: {
    w: {
      data: 'mediausage.time',
      transform: function (v, cv) {
        if (cv) {
          return Math.abs(cv) * 100 + '%'
        }
      }
    }
  },
  '!tv.button': {
    display: {
      val: 'inline-block',
      $isPlayingAd: 'none',
      $isReceiver: 'none'
    }
  },
  events: {
    down: cases.touch ? function (e) {
      var overlayOpacity = this.parent.parent.parent.opacity
      if (!overlayOpacity || overlayOpacity.val === 1) setTime.call(this, e)
      else this._skipUp = true
    } : setTime,
    drag: setTime,
    up: cases.touch ? function (e) {
      var overlayOpacity = this.parent.parent.parent.opacity
      if (!this._skipUp) setTime.call(this, e)
      else this._skipUp = null
    } : setTime
  }
})

module.exports = exports = seekbar.Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/player/seekbar/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/element/video/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/video/util.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js"}],"/Users/youzi/dev/mtv-play/components/player/seekbar/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/player/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/player/video/index.js":[function(require,module,exports){
var app = require( 'old-vigour-js/app/' )
var cases = require( 'old-vigour-js/browser/cases' )
var Video = require( 'old-vigour-js/browser/element/video' )
var viacom = require( '../players/viacom' )
var postpone = require( 'old-vigour-js/browser/events/util' ).postpone
var playTv = postpone( function( t ) {
  if( app.playing.val ) {
    t.play( true )
  }
}, 501 )

module.exports = new Video( {
  node: 'div',
  player: viacom,
  src: {
    data: 'media.mrss'
  },
  duration:0,
  // duration: {
  //   data: 'media.duration'
  // },
  css: 'video-container',
  time: {
    data: 'mediausage.time',
    defer: function( update, args ) {
      if( cases.$isOnChannel.val || cases.$isPlayingAd.val ) return true
      update()
    }
  },
  volume: {
    data: 'volume'
  },
  $play: {
    defer: function( update ) {
      var video = this._caller
      if( app.state.val === 'second' ) return true
      if( cases.desktop ) {
        window.requestAnimationFrame( function() {
          if( video.rendered ) update()
          else update( true )
        } )
      } else {
        update()
      }
    }
  },
  model: {
    subscription: {
      videolang: true,
      access: true,
      video: true,
      mrss: true,
      duration:true
    }
  },
  events: {
    src: function( src ) {
      this.duration = this.data.media.from.get('duration')
      cases.$isPlayingAd.val = false
      if( src.val && ( cases.tv || cases.$isReceiver.val ) && this.rendered ) {
        var usage = this.data && this.data.mediausage
        app.playing.from.val = true
        if( usage && !cases.$isOnChannel.val ) usage.from.set( 'time', Math.abs( this.time.from.val ) )
        this.play()
      } else {
        app.playing.from.val = false
      }
    },
    progress: function( p, b ) {
      var time = -Math.abs( p )
      var usage = this.data && this.data.mediausage
      var overlay
      if( cases.$isPlayingAd.val ) {

      } else if( cases.$isOnChannel.val ) {

      } else if( usage ) {
        if( app && app.mediaTime ) app.mediaTime.val = time
        usage.from.set( 'time', time ) //set minus for no update! 
      }

    },
    play: function() {
      var overlay = getOverlay.call( this )
      if( overlay ) overlay.opacity = this.playing ? 0 : 1
      if( cases.$isOnChannel.val && this.playing && app && app.mediaTime ) {
        app.mediaTime.val = -0.01
      }
    },
    stalled: function() {
      var overlay = getOverlay.call( this )
      if( overlay && !cases.chromecast ) overlay.opacity = 1

      cases.$isLoadingVideo.val = true
    },
    seeking: function( val ) {
      if( !this._notRendered && this.rendered ) {
        var overlay = getOverlay.call( this )
        if( overlay ) overlay.opacity = 1
        if( app.playing.val ) {
          if( !this.__paused ) this.pause( true )
          playTv( this )
        }

        cases.$isLoadingVideo.val = true
      } else {
        this._notRendered = true
      }
    },
    canplay: function() {}

  }
} ).Class

function getOverlay() {
  return this._overlay || ( this._overlay = this.parent && this.parent.overlay )
}

},{"../players/viacom":"/Users/youzi/dev/mtv-play/components/player/players/viacom.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/element/video":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/video/index.js","old-vigour-js/browser/events/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js"}],"/Users/youzi/dev/mtv-play/components/player/volume/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'old-vigour-js/app/ui/element' )
var ua = require('old-vigour-js/browser/ua')

var setVol = ua.prefix === 'ms' ? function (e) {
  var rect = this.node.getBoundingClientRect()
  var x = rect.left
  var nr = (e.pageX - x) / this.w.val
  this.data.volume.from = nr > 1 ? 1 : nr < 0 ? 0 : nr
} : function (e) {
  var rect = this.node.getBoundingClientRect()
  var x = rect.left
  var nr = (e.x - x) / this.w.val
  this.data.volume.from = nr > 1 ? 1 : nr < 0 ? 0 : nr
}

var volume = new Element({
  css: 'player-volume',
  w: 50,
  events: {
    down: setVol,
    drag: setVol,
    up: setVol
  }
})

volume.extend({
  bars: function (val) {
    var val = val.val
    var bars = this.children
    var width = 28 + 5
    var volume = width * (isNaN(val) ? 1 : val) + 5
    for (var i in bars) {
      volume -= width / 5
      bars[i].nested.x = -3 + Math.min(volume, 3)
    }
  }
})

var five = 5
while (five--) volume.add(new Element({
  nested: {}
}))

module.exports = volume.Class

},{"./style.less":"/Users/youzi/dev/mtv-play/components/player/volume/style.less","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js"}],"/Users/youzi/dev/mtv-play/components/player/volume/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/popup/article.js":[function(require,module,exports){
// anim up op phone
// anders scale en fade
var Img = require('../img')
var Page = require('./page')
var Autolinker = require('autolinker')

module.exports = exports = new Page({
  css: 'popup-article',
  img: new Img.Relative({
    h: 190,
    display: {
      data: 'img',
      transform: function (c, cv) {
        return cv ? 'block' : 'none'
      }
    }
  }),
  title: {
    text: {
      data: 'title'
    }
  },
  body: {
    html: {
      data: 'text',
      transform: function (v, cv) {
        return cv && Autolinker.link( cv, { className: 'popup-article-link' } )
      }
    }
  }
}).Class

exports.Cookie = new exports({
  body: {
    html: {
      data: 'text',
      transform: function (v, cv) {
        return cv && Autolinker.link( cv.replace('Klik HIER','<span class="popup-article-link" onclick="var app = document.body.base, p = app.popup;p.data = app.content.get([\'legal_cookies_extended\', \'list\', \'0\']);p.val = \'article\'">Klik HIER</span>')
        , { className: 'popup-article-link'} )
      }
    }
  }
}).Class
},{"../img":"/Users/youzi/dev/mtv-play/components/img/index.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","autolinker":"/Users/youzi/dev/mtv-play/node_modules/autolinker/dist/Autolinker.js"}],"/Users/youzi/dev/mtv-play/components/popup/auth.js":[function(require,module,exports){
// anim up op phone
// anders scale en fade
var Element = require('old-vigour-js/app/ui/element')
var Icon = require('../icon')
var cases = require('old-vigour-js/browser/cases')
var Button = require('../button')
var Input = require('../text/input')
var Item = require('../item')
var Page = require('./page')
var app = require('old-vigour-js/app/')

// user.activeDevices  // TODO SAME AS IN MENU >> UNITE
var Term = new Element({
  'events.click': function () {
    var popup = this.checkParent('on.popup', true).from
    popup.previous = popup.val
    popup.data = app.content.get([this._name, 'list', '0'])
    popup.val = 'article'
  },
  css: 'term'
}).Class

exports.FbButton = new Button({
  'events.click': function () {
    var api = this.checkParent('api', true)
    api.facebook.login.val = true
  }
}).Class

exports.GetApp = new Page({
  css: 'getapp',
  on: {
    $parent: {
      defer: function (update) {
        var topbar = this._parent._caller.checkParent('topbar', true)
        if (topbar) {
          topbar.empty()
          topbar.node.style.backgroundColor = '#3a1a58'
        }
        update()
      }
    }
  },
  info: {
    title: {
      'text.dictionary': 'text.register.redirectTitle'
    },
    subtitle: {
      'text.dictionary': 'text.register.redirectSubtitle'
    },
    freepass: {}
  },
  'ios.teleport': new Button({
    text: {
      dictionary: 'text.register.redirectTeleport'
    },
    'events.click': function () {
      window.location.href = 'fb709421825777638://'
    }
  })
}).Class

var Conditions = new Element({
  top: {
    text: {
      dictionary: 'text.signInTOS'
    }
  },
  items: {
    privacy: new Term({
      text: {
        dictionary: 'text.privacy'
      }
    }),
    terms: new Term({
      text: {
        dictionary: 'text.terms'
      }
    })
  }
}).Class

exports.Login = new Page({
  css: 'login',
  logo: {},
  '!windowsMobile.facebook': new exports.FbButton({
    'text.dictionary': 'text.account.signin.facebook'
  }),
  email: new Button({
    text: {
      dictionary: 'text.account.signin.email'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.val = 'loginEmail'
    }
  }),
  conditions: new Conditions({
    css: 'alignedTop'
  })
}).Class

exports.Login.Email = new Input.Form({
  css: 'login',
  scrollbar: 'y',
  x: {
    translate: true
  },
  email: new Input({
    input: 'email'
  // verification add later!
  }),
  password: new Input({
    input: 'password'
  }),
  'desktop.confirm': new Button({
    text: {
      dictionary: 'text.account.signin.title'
    },
    'events.confirm': function () {
      var form = this.parent
      form.done.call(form)
    }
  }),
  conditions: new Conditions(),
  verify: ['email', 'password'],
  bottom: {
    'text.dictionary': 'text.account.forgot.title',
    'events.click': function () {
      var api = this.checkParent('api', true)
      api.password.forgot.val = this.parent.email.val
    }
  },
  define: {
    done: function () {
      if (this.verified) {
        var api = this.checkParent('api', true)
        api.login.val = {
          email: this.email.val,
          password: this.password.val
        }
      } else {
        app.notification.val = 'invalid'
      }
    }
  }
}).Class

var RegisterConditions = exports.RegisterConditions = new Conditions({
  top: {
    text: {
      dictionary: 'text.termsOfService'
    }
  }
}).Class

exports.Register = new Page({
  css: 'register',
  logo: {},
  '!windowsMobile.facebook': new exports.FbButton({
    'text.dictionary': 'text.account.signup.facebook'
  }),
  email: new Button({
    text: {
      dictionary: 'text.account.signup.email'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.val = 'registerEmail'
    }
  }),
  or: {
    display: {
      val: 'none',
      $hasOperator: 'block'
    },
    text: {
      dictionary: 'text.or'
    }
  },
  operator: new Button({
    display: {
      val: 'none',
      $hasOperator: 'block'
    },
    text: {
      dictionary: 'text.account.signup.operator'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.val = 'operatorList'
    }
  }),
  conditions: new RegisterConditions({
    css: 'alignedTop'
  })
}).Class

exports.Register.Email = new Input.Form({
  css: 'register',
  scrollbar: 'y',
  x: {
    translate: true
  },
  email: new Input({
    input: 'email'
  }),
  password: new Input({
    input: 'password'
  }),
  repeatPassword: new Input({
    input: {
      val: 'password',
      text: 'text.repeatPassword'
    }
  }),
  verify: ['email', 'password', 'repeatPassword'],
  'desktop.confirm': new Button({
    text: {
      dictionary: 'text.next'
    },
    'events.confirm': function () {
      var form = this.parent
      form.done.call(form)
    }
  }),
  conditions: new RegisterConditions(),
  define: {
    done: function () {
      if (this.verified) {
        if (this.password.val === this.repeatPassword.val) {
          var popup = this.checkParent('on.popup', true).from
          popup.data = {
            type: this.data && this.data._name,
            email: this.email.val,
            password: this.password.val
          }
          popup.val = 'registerNewsletter'
        } else {
          app.notification.val = 'noMatchPassword'
        }
      } else {
        app.notification.type = this.verificationError && this.verificationError.val
        app.notification.val = 'invalid'
      }
    }
  }
}).Class

var NewsLetterButton = new Item.Switcher({
  txt: {
    'title.text.dictionary': 'text.newsletterTitle',
    'subtitle.text.dictionary': 'text.newsletterSubtitle'
  },
  'events.click': function () {
    if (!this.parent.data) this.parent.data = {}
    var data = this.parent.data
    data.newsletter = !this.righticon.hold.switchOn.val
    this.righticon.hold.switchOn = data.newsletter
  },
  add: [new Icon({
    name: 'lefticon',
    icon: 'newsletter'
  }), 'txt']
}).Class

var Dropdown

if (cases.phone && cases.native) {
  var DropdownMenu = new Element({
    css: 'auth-dropdown',
    position: 'absolute',
    y: {
      animation: {
        time: 18,
        easing: 'outCubic',
        done: function () {
          if (this._remove) this.remove()
        }
      }
    },
    model: {
      complete: function () {
        var _this = this
        window.requestAnimationFrame(function () {
          _this.y = {
            sub: _this.node.offsetHeight
          }
        })
      }
    }
  }).Class

  function removeDropdown () {
    app.dropdown._remove = true
    app.dropdown.y = {
      sub: 0
    }
    app.dropdownBackdrop.remove()
  }

  Dropdown = new Item.IconLeft({
    lefticon: {
      icon: 'newsletter'
    },
    txt: {
      css: {
        data: 'value',
        transform: function (v, cv) {
          return cv.trim() === 'txt' ? 'inactive' : ' '
        }
      },
      text: {
        dictionary: {
          data: 'dictionary'
        }
      },
      model: {
        inherit: false
      }
    },
    model: function (data) {
      if (data instanceof Array) this.txt.data = data[0]
    },
    'events.click': function () {
      if (!app.dropdown) {
        var form = this.parent
        var name = this._name
        var data = this.data

        if (!this._dData) this._dData = data.splice(1)

        app.set({
          dropdownBackdrop: {
            css: 'relative-size',
            'events.click': removeDropdown
          },
          dropdown: new DropdownMenu({
            y: app.h,
            collection: {
              data: true,
              element: new Element({
                text: {
                  dictionary: {
                    data: 'dictionary'
                  }
                },
                'events.click': function () {
                  if (!form.data) form.data = {}
                  form.data[name] = this.data.value
                  form[name].txt.data = this.data
                  removeDropdown()
                }
              })
            },
            data: this._dData
          })
        })
      }
    }
  }).Class
} else {
  Dropdown = new Item({
    select: {
      node: 'select',
      collection: {
        data: true,
        element: new Element({
          node: 'option',
          attr: {
            value: {
              data: 'value'
            }
          },
          text: {
            dictionary: {
              data: 'dictionary'
            }
          }
        })
      }
    },
    'events.change': function (e) {
      if (!this.parent.data) this.parent.data = {}
      this.parent.data[this._name] = e.target.value
    },
    add: [new Icon({
      name: 'lefticon',
      icon: 'newsletter'
    }), 'select']
  }).Class
}

function confirmRegisterNewsletter () {
  var api = this.checkParent('api', true),
    parent = this.parent
  if (!parent.data) parent.data = {}
  api.register.val = parent.data
}

exports.Register.Newsletter = new Input.Form({
  css: 'register newsletter',
  scrollbar: 'y',
  x: {
    translate: true
  },
  age: new Dropdown({
    'on.$render.defer': function (update) {
      this._parent._caller.data = [{
        value: '',
        dictionary: 'text.age'
      }, {
        dictionary: 'options.age.0.text',
        value: '1'
      } // you can put any integer value in min_age and max_age
        , {
          dictionary: 'options.age.1.text',
          value: '2'
        }, {
          dictionary: 'options.age.2.text',
          value: '3'
        }
      ]
      update()
    },
    lefticon: {
      icon: 'age'
    }
  }),
  gender: new Dropdown({
    'on.$render.defer': function (update) {
      this._parent._caller.data = [{
        value: '',
        dictionary: 'text.gender'
      }, {
        value: 'male',
        dictionary: 'options.gender.0.text'
      }, {
        value: 'female',
        dictionary: 'options.gender.1.text'
      }, {
        value: 'other',
        dictionary: 'options.gender.2.text'
      }]
      update()
    },
    lefticon: {
      icon: 'gender'
    }
  }),
  newsletter: new NewsLetterButton(),
  'desktop.confirm': new Button({
    text: {
      dictionary: 'text.account.signup.title'
    },
    'events.confirm': function () {
      var form = this.parent
      form.done.call(form)
    }
  }),
  conditions: new RegisterConditions(),
  define: {
    done: function confirmRegisterNewsletter () {
      var api = this.checkParent('api', true)
      if (!this.data) {
        this.data = {}
      }
      console.log('???', this.data.type)
      if (this.data.type) {
        localStorage.setItem('registerOperator', this.data.type)
      }
      api.register.val = this.data
    }
  }
}).Class

exports.PasswordReset = new Input.Form({
  css: 'register',
  scrollbar: 'y',
  x: {
    translate: true
  },
  password: new Input({
    input: 'password'
  }),
  repeatPassword: new Input({
    input: {
      val: 'password',
      text: 'text.repeatPassword'
    }
  }),
  'desktop.confirm': new Button({
    text: {
      dictionary: 'text.account.passwordReset'
    },
    'events.confirm': function () {
      var form = this.parent
      form.done.call(form)
    }
  }),
  define: {
    done: function () {
      if (this.password.val === this.repeatPassword.val) {
        var api = this.checkParent('api', true)
        api.password.reset.val = {
          password: this.password.val
        }
      } else {
        app.notification.val = 'noMatchPassword'
      }
    }
  }
}).Class

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../text/input":"/Users/youzi/dev/mtv-play/components/text/input.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/buy.js":[function(require,module,exports){
// anim up op phone
// anders scale en fade
var Element = require('old-vigour-js/app/ui/element')
var app = require('old-vigour-js/app')
var Button = require('../button')

module.exports = exports = new Element({
  css: 'upgrade',
  block: {
    img: {}
  },
  'bottom.text.dictionary': 'text.legalContainer',
  continue: new Button({
    'text.dictionary': 'text.continue'
  })
}).Class

exports.Monthly = new exports({
  block: {
    'title.text.dictionary': 'text.purchase.monthlyPass.title',
    'txt.text': {
      dictionary: 'text.purchase.monthlyPass.body',
      add: [ ' ', app.api.price.monthly ]
    }
  },
  'continue.events.click': function () {
    var api = this.checkParent('api', true)
    api.purchase.val = {
      subscription: 'monthly'
    }
  }
}).Class

exports.Single = new exports({
  block: {
    'title.text.dictionary': 'text.purchase.singlePass.title',
    'txt.text': {
      dictionary: 'text.purchase.singlePass.body',
      add: [ ' ', app.api.price.single ]
    }
  },
  'continue.events.click': function () {
    var api = this.checkParent('api', true)
    api.purchase.val = {
      product: app.user.navigation.media.from
    }
  }
}).Class

exports.Yearly = new exports({
  block: {
    'title.text.dictionary': 'text.purchase.yearlyPass.title',
    'txt.text': {
      dictionary: 'text.purchase.yearlyPass.body',
      add: [ ' ', app.api.price.yearly ]
    }
  },
  'continue.events.click': function () {
    var api = this.checkParent('api', true)
    api.purchase.val = {
      subscription: 'yearly'
    }
  }
}).Class

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/comingSoon.js":[function(require,module,exports){
// anim up op phone
// anders scale en fade

var Page = require('./page')
var app = require('old-vigour-js/app')
var dictionary = require('old-vigour-js/app/dictionary')

module.exports = exports = new Page({
  css: 'popup-coming-soon',
  logo: {},
  img: {},
  container: {
    title: {
      text: {
        dictionary: 'text.notAvailable.title'
      }
    },
    body: {
      text: {
        dictionary: 'text.notAvailable.text'
      }
    },
    email: {
      text: 'helpme@mtvplay.tv',
      'events.click': function () {
        app.api.email.send.val = {
          address: 'helpme@mtvplay.tv',
          subject: dictionary.get('text.mailHelp.title').val,
          body: dictionary.get('text.mailHelp.body').val
        }
      }
    }
  }
}).Class

},{"./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/devices.js":[function(require,module,exports){
var Element = require('old-vigour-js/app/ui/element')
var util = require('old-vigour-js/util')
var Icon = require('../icon')
var Item = require('../item')
var cases = require('old-vigour-js/browser/cases')
var Button = require('../button')
var config = require('old-vigour-js/util/config')
var ua = require('old-vigour-js/browser/ua')
var raf = require('old-vigour-js/browser/animation/raf')
var Page = require('./page')
var app = require('old-vigour-js/app/')

module.exports = exports = new Page({
  css: 'devices',
  myDevice: {
    icon: new Icon({
      icon: ua.device
    }),
    dInfo: {
      dTitle: {
        'text.dictionary': 'text.thisDevice'
      },
      dSubtitle: {
        text: cases.touch ? ua.device + ' ' + ( ua.platform === 'ios' ? 'iOS' : ua.platform) + ( ua.version ? ' ' + ua.version : '') : ua.platform + ' ' + ua.browser + ' ' + ua.version
      }
    }
  },
  middle: {
    display: {
      val: 'block',
      $hasDevices: 'none'
    },
    icon: new Icon({
      icon: 'monster'
    }),
  },
  listTitle: {
    'text.dictionary': 'text.available',
    display: {
      val: 'none',
      $hasDevices: 'block'
    }
  },
  list: {
    display: {
      val: 'none',
      $hasDevices: 'block'
    },
    collection: {
      element: new Item.IconLeft({
        'model': function ( data ) {
          if ( data && data.from && data.from.device && !/(desktop)|(tv)|(cast)|(tablet)|(airplay)/.test(data.from.device.val)) {
            this.opacity = 0.5
          }
        },
        events: {
          click: function () {
            var user = this.checkParent('on.user', true)._val
            var client = this.data.from
            if ( /(desktop)|(tv)|(cast)|(tablet)|(airplay)/.test(client.device.val)) {
              user.setReceiver(client)
            }
          }
        },
        display: {
          data: 'title',
          transform: function ( v, cv ) {
            return cv ? 'table' : 'none'
          }
        },
        lefticon: {
          icon: {
            data: {
              val: function ( data ) {
                var device = data && data.from && data.from.device && data.from.device.val
                return device === 'chromecast' ? 'cast' : device
              },
              listen: 'device'
            }
          }
        }
      }),
      data: true
    }
  },
  info: {
    display: {
      val: 'block',
      $hasDevices: 'none'
    },
    'title.text.dictionary': 'text.watchBigger',
    'description.text.dictionary': 'text.watchBig'
  },
  learn: new Button({
    display: {
      val: 'block',
      $hasDevices: 'none'
    },
    'text.dictionary': 'text.learnMore',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = 'devices'
      popup.val = 'faq'
    }
  }),
  on: {
    $render: {
      defer: function () {
        var caller = this._parent._caller
        caller.on.devices._val._update()
      }
    },
    devices: {
      defer: function ( update ) {
        var caller = this._parent._caller
        caller.on.receiver._update()
        caller.data = this.from
        update()
      }
    },
    receiver: {
      defer: function ( update ) {
        var _this = this
        raf(function () {
          if ( _this._parent) {
            var caller = _this._parent._caller,
              receiver = caller.checkParent('on.user', true)._val.receiverClient,
              elem = caller.list.find('_d.from', receiver.from)
            if ( elem ) {
              if ( _this.focus && _this.focus._node) {
                _this.focus.css = {
                  removeClass: 'current'
                }
              }
              _this.focus = elem
              elem.css = {
                addClass: 'current'
              }
            } else if ( _this.focus) {
              if ( _this.focus && _this.focus._node) {
                _this.focus.css = {
                  removeClass: 'current'
                }
                _this.focus = null
              }
            }
          }
          update()
        })
      }
    }
  }
}).Class

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/faq.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var Icon = require( '../icon' )
var Item = require( '../item' )
var Page = require( './page' )
var app = require( 'old-vigour-js/app/' )

module.exports = new Page( {
  css: 'faq',
  scrollbar: 'y',
  on: {
    $parent: {
      defer: function( update ) {
        this._parent._caller.data = app.content.from.get( 'faq.list' )
        update()
      }
    }
  },
  collection: {
    data: true,
    element: new Item.IconRight( {
      'events.click': function() {
        var popup = this.checkParent( 'on.popup', true ).from
        popup.previous = 'faq'
        popup.data = this.data
        popup.val = 'article'
      }
    } )
  }
} ).Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/index.js":[function(require,module,exports){
require('./style.less')
var Element = require('old-vigour-js/app/ui/element')
var util = require('old-vigour-js/util')
var app = require('old-vigour-js/app/')
var Icon = require('../icon')
var cases = require('old-vigour-js/browser/cases')
var Switcher = require('old-vigour-js/app/ui/switcher')
var auth = require('./auth')
var operator = require('./operator')
var Settings = require('./settings')
var Profile = require('./profile')
var Share = require('./share')
var Devices = require('./devices')
var Roadblock = require('./roadblock')
var Article = require('./article')
var Languages = require('./languages')
var Faq = require('./faq')
var Wifi = require('./wifi')
var Newsletter = require('./newsletter')
var mobile = require('./mobile')
var Intro = require('./intro')
var Upgrade = require('./upgrade')
var Buy = require('./buy')
var GetApp = auth.GetApp
var ComingSoon = require('./comingSoon')

var popupWidth = cases.phone ? app.w.val : 400

var config = require('old-vigour-js/util/config')
var ajax = require('old-vigour-js/browser/network/ajax')

// popup data
exports = new Element({
  css: 'popup-window',
  on: {
    $new: {
      defer: function (update) {
        var caller = this._parent._caller
        if (app.popup.val === 'languages') caller.y._p = true
        window.requestAnimationFrame(function () {
          if (caller.y) caller.y._p = false
        })
        update()
      }
    },
    loading: {
      defer: function (update, args) {
        // this.clearCache()
        if (!this._parent._caller) {
          return true
        }
        if (args[0] && (args[0] === true || typeof args[0] === 'string')) {
          this._parent._caller.overlay.display = 'block'
        } else {
          this._parent._caller.overlay.display = 'none'
        }
        update()
      }
    },
    popup: {
      defer: function (update) {
        var val = this.from.val
        var parent = this._parent
        var _caller = parent._caller
        var overlay = parent.overlay._val
        var user = parent.user._val
        var receiver = user.receiverClient

        
        // if (typeof val === 'number') {
        //   ajax({
        //     // url: 'https://api.mtvnn.com/v2/airings.json/?channel_id=' + 1 + '&filter=today&bust=' + ~~( Math.random() * 1000000 ),
        //     url: 'https://api.mtvnn.com/v2/site/m79obhheh2/en/articles/' + val + '.json',
        //     headers: {
        //       Accept: '*/*'
        //     },
        //     // iframe: 'http://www.mtvplay.tv/xhr/index.html',
        //     iframe: config.epg,
        //     method: 'GET',
        //     complete: function (result) {
        //       console.info('result:', result)
        //       // prep data and do popup.val = Article etc
        //     },
        //     error: function (err) {
              
        //     }
        //   })
        //   return true
        // }

        var types = {
            comingSoon: {
              dictionary: 'text.comingSoon',
              element: ComingSoon
            },
            verifyMobile: {
              dictionary: 'text.mtvMobile',
              element: mobile.Verify
            },
            countryCodes: {
              dictionary: 'text.chooseTelCode',
              element: mobile.CountryCodes,
              previous: 'verifyMobile'
            },
            share: {
              dictionary: 'text.share',
              element: Share
            },
            wifi: {
              dictionary: 'settings.connectivity',
              element: Wifi,
              previous: 'settings'
            },
            newsletter: {
              dictionary: 'text.newsletterTitle',
              element: Newsletter,
              previous: 'settings'
            },
            roadblock: {
              dictionary: 'text.oops',
              element: Roadblock
            },
            roadblockUpgrade: {
              dictionary: 'text.buyPremium',
              element: Roadblock
            },
            roadblockMedia: {
              dictionary: 'text.lockedEpisode',
              element: Roadblock.Media
            },
            article: {
              title: this.val !== 'faq',
              element: Article,
              dictionary: 'settings.help'
            },
            articleCookie: {
              title: this.val !== 'faq',
              element: Article.Cookie,
              dictionary: 'settings.help'
            },
            getApp: {
              dictionary: 'text.getapp',
              element: GetApp
            },
            operatorList: {
              dictionary: 'text.operator.choose',
              element: operator.List,
              previous: 'register'
            },
            operatorAuth: {
              title: true,
              element: operator.Register,
              previous: 'operatorList',
              righticon: {
                icon: {
                  icon: 'empty'
                },
                text: {
                  dictionary: 'text.done'
                }
              }
            },
            operatorAuthAlt: {
              previous: 'operatorList',
              title: true,
              element: operator.RegisterAlternative
            },
            operatorListUpgrade: {
              previous: 'upgrade',
              dictionary: 'text.operator.deals',
              element: operator.ListUpgrade
            },
            operatorAuthUpgrade: {
              title: true,
              element: operator.Upgrade,
              righticon: {
                icon: {
                  icon: 'empty'
                },
                text: {
                  dictionary: 'text.done'
                }
              }
            },
            upgradeOperator: {
              dictionary: 'text.operator.choose',
              element: auth.Register.ChooseOperator,
              previous: 'upgrade'
            },
            devices: {
              dictionary: 'text.devices',
              element: Devices,
              params: {
                on: {
                  receiver: receiver,
                  devices: user.devices
                }
              }
            },
            loginEmail: {
              dictionary: 'text.account.signin.title',
              element: auth.Login.Email,
              previous: 'login',
              righticon: {
                icon: {
                  icon: 'empty'
                },
                text: {
                  dictionary: 'text.done'
                }
              }
            },
            passwordReset: {
              dictionary: 'text.account.passwordReset',
              element: auth.PasswordReset
            },
            login: {
              dictionary: 'text.account.signin.title',
              element: auth.Login
            },
            registerEmail: {
              dictionary: 'text.account.signup.title',
              element: auth.Register.Email,
              previous: 'register',
              righticon: {
                icon: {
                  icon: 'empty'
                },
                text: {
                  dictionary: 'text.next'
                }
              }
            },
            registerSuccess: {
              dictionary: 'text.account.signup.success',
              element: auth.Register.Success
            },
            registerNewsletter: {
              dictionary: 'text.account.signup.title',
              element: auth.Register.Newsletter,
              previous: 'registerEmail',
              righticon: {
                icon: {
                  icon: 'empty'
                },
                text: {
                  dictionary: 'text.done'
                }
              }
            },
            register: {
              dictionary: 'text.account.signup.title',
              element: auth.Register
            },
            upgrade: {
              dictionary: 'text.upgrade',
              element: Upgrade
            },
            settings: {
              dictionary: 'text.nav.settings',
              element: Settings
            },
            profile: {
              dictionary: 'text.profile',
              element: Profile,
              params: {
                data: {
                  email: user.email,
                  pic: user.profilePic
                }
              }
            },
            languages: {
              dictionary: 'text.settings.languages.title',
              element: Languages,
              previous: 'settings',
              params: {
                on: {
                  language: app.language
                }
              }
            },
            faq: {
              dictionary: 'settings.help',
              element: Faq,
              previous: 'settings'
            },
            intro: {
              dictionary: false,
              element: Intro
            },
            getStarted: {
              dictionary: 'text.mtvMobile',
              element: Intro.getStarted
            },
            getStartedContinue: {
              dictionary: 'text.account.signup.title',
              element: Intro.getStartedContinue,
              previous: 'intro' // 'getStarted'
            },
            buyMonthly: {
              dictionary: 'text.upgrade',
              element: Buy.Monthly,
              previous: 'upgrade'
            },
            buySingle: {
              dictionary: 'text.lockedEpisode',
              element: Buy.Single,
              previous: 'roadblockMedia'
            },
            buyYearly: {
              dictionary: 'text.upgrade',
              element: Buy.Yearly,
              previous: 'upgrade'
            }
          },
          type

        if (!val) {
          overlay.val = false
          if (!cases.phone) {
            // _caller.scale = 0
            // _caller.display = 'none'
            _caller.remove()
          } else {
            _caller.y = app.h
          }
          update(true)
        } else {
          // TODO: listener voor sets on top als property
          overlay.val = 'popup'
            // make selection using ifs and lazy
          type = types[this.from.val]

          if (type) {
            if (this.from.previous) {
              type.previous = this.from.previous
              this.from.previous = null
            }

            // this.from.title

            if (type.title && this.from.data) {
              _caller.topbar.holder.title.text = this.from.data.get('title')
            } else {
              _caller.topbar.holder.title.text = type.dictionary !== false ? {
                dictionary: type.dictionary || this.from.val
              } : ''
            }

            var transition = {
              element: type.element
            }

            if (this.from.data) {
              transition.$params = {
                data: this.from.data
              }

              if (type.params) util.merge(transition.$params, type.params)

              // this._currentData = this.from.data
              // this.from.data = null 
              // now it never removes data........
              // TODO: hotfix think of a solution
              // maybe just tell when a type has to clear data

            } else if (type.params) {
              transition.$params = type.params
              this.from.data = null
            } else {
              this.from.data = null
            }

            if (!type.previous) {
              _caller.topbar.holder.lefticon.icon = 'empty'
            } else {
              _caller.topbar.holder.lefticon.icon = 'arrowleft'
              _caller.switcher.previous = type.previous
            }

            if (!cases.desktop) {
              if (type.righticon) {
                _caller.topbar.holder.righticon.set(type.righticon)
              } else {
                _caller.topbar.holder.righticon.set({
                  icon: {
                    icon: 'close'
                  },
                  text: '',
                  css: ''
                })
              }
            }

            _caller.switcher.transition = transition
            update()

          } else {
            console.error('cannot find popup-type', this.from.val)
            update(true)
          }

        }
      }
    }
  },
  position: 'absolute',
  phone: {
    w: app.w,
    h: app.h,
    y: {
      val: 0,
      animation: {
        time: app.h.val / 30,
        start: app.h,
        easing: 'outCubic',
        done: function (cv) {
          var t = this
          if (cv >= 100) t.remove()
        }
      }
    }
  },
  '!phone': {
    w: {
      val: app.w,
      sub: 30,
      max: 400
    },
    h: {
      val: app.h,
      sub: 30,
      max: 600
    },
    x: {
      val: app.w,
      sub: {
        self: 'w'
      },
      divide: 2
    },
    y: {
      val: app.h,
      sub: {
        self: 'h'
      },
      divide: 3,
      min: 15
    },
    '!android.opacity': {
      val: 1,
      animation: {
        time: 15,
        start: 0,
        easing: 'outCubic'
      }
    }
  },
  topbar: {
    css: 'first-topbar',
    h: {
      val: 40,
      phone: {
        iosFull: 60
      }
    },
    holder: {
      lefticon: new Icon({
        icon: 'arrowleft',
        'events.click': function () {
          this.checkParent('switcher', true).back()
        }
      }),
      title: {
        text: ''
      },
      righticon: {
        icon: new Icon({
          icon: 'close'
        }),
        text: '',
        'events.click': cases.desktop ? function (e) {
          e.preventDefault()
          this.checkParent('on.popup', true).from = false
        } : function (e) {
          e.preventDefault()
          var page = this.checkParent('switcher', true)._swElem
            //             console.log(page.done)
          if (page && page.done) page.done.call(page)
          else this.checkParent('on.popup', true).from = false
        }
      }
    }
  },
  switcher: new Switcher({
    node: 'div', // , css:firefox && 'firefox'
    on: {
      $remove: {
        defer: function (update) {
          var caller = this._parent._caller
          if (caller._timer) clearTimeout(caller._timer)
          update()
        }
      }
    },
    h: {
      parent: 'h',
      sub: {
        val: 40,
        phone: {
          iosFull: 60
        }
      }
    },
    onTransition: cases.slow ? function (current, last, direction) {
      if (last) last.remove()
      this.add(current)
    } : function (current, last, direction, options) {
      direction = app.popup.direction !== void 0 ? app.popup.direction : 1
      app.popup.direction = void 0
      if (direction && last) {
        current.x = {
          val: 0,
          animation: {
            start: direction === 1 ? popupWidth : -popupWidth,
            time: 20,
            delay: 1,
            easing: 'outCubic',
            done: function () {
              if (last) last.remove()
            }
          }
        }

        last.x = {
          val: direction === 1 ? -popupWidth : popupWidth,
          animation: {
            time: 20,
            delay: 1,
            easing: 'outCubic'
          }
        }

        if (direction === -1) this.add(current, last)
        else this.add(current)

      } else {
        if (last) last.remove()
        this.add(current)
      }
    },
    backFallback: function () {
      if (this.previous) {
        app.popup.direction = -1
        if (this.previous instanceof Object) {
          app.popup.data = this.previous.data
          app.popup.val = this.previous.val
        } else {
          app.popup.val = this.previous
        }
      }
    }
  }),
  overlay: {
    display: 'none'
  }
})

exports.topbar.holder.righticon.extend({
  fn: function () {}
})

module.exports = exports.Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./article":"/Users/youzi/dev/mtv-play/components/popup/article.js","./auth":"/Users/youzi/dev/mtv-play/components/popup/auth.js","./buy":"/Users/youzi/dev/mtv-play/components/popup/buy.js","./comingSoon":"/Users/youzi/dev/mtv-play/components/popup/comingSoon.js","./devices":"/Users/youzi/dev/mtv-play/components/popup/devices.js","./faq":"/Users/youzi/dev/mtv-play/components/popup/faq.js","./intro":"/Users/youzi/dev/mtv-play/components/popup/intro.js","./languages":"/Users/youzi/dev/mtv-play/components/popup/languages.js","./mobile":"/Users/youzi/dev/mtv-play/components/popup/mobile.js","./newsletter":"/Users/youzi/dev/mtv-play/components/popup/newsletter.js","./operator":"/Users/youzi/dev/mtv-play/components/popup/operator.js","./profile":"/Users/youzi/dev/mtv-play/components/popup/profile.js","./roadblock":"/Users/youzi/dev/mtv-play/components/popup/roadblock.js","./settings":"/Users/youzi/dev/mtv-play/components/popup/settings.js","./share":"/Users/youzi/dev/mtv-play/components/popup/share.js","./style.less":"/Users/youzi/dev/mtv-play/components/popup/style.less","./upgrade":"/Users/youzi/dev/mtv-play/components/popup/upgrade.js","./wifi":"/Users/youzi/dev/mtv-play/components/popup/wifi.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/app/ui/switcher":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/network/ajax":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/ajax.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/intro.js":[function(require,module,exports){
var Element = require('old-vigour-js/app/ui/element')
var Button = require('../button')
var Img = require('../img')
var Page = require('./page')
var app = require('old-vigour-js/app/')

var Slide = new Element({
  img: new Img.Intro({
    on: {
      $new: {
        defer: function (update) {
          this._parent._caller.background.update()
          update()
        }
      }
    }
  })
}).Class

module.exports = exports = new Page({
  on: {
    $parent: {
      defer: function (update) {
        var parent = this._parent
        var caller = parent._caller
        var topbar = caller.checkParent('topbar', true)
        var roll
        if (topbar) {
          roll = caller.roll
          caller._topbar = topbar
          roll._dots = new exports.Dots()
          topbar.node.style.backgroundColor = '#3a1a58'
          topbar.set({
            holder: {
              title: {
                dots: roll._dots
              }
            }
          })
          roll.x = caller.parent.parent.w.val - 15
          parent.popup.val = app.popup
        }
        update()
      }
    },
    popup: {
      defer: function (update, args) {
        var val = this._val._val
        if (val !== 'intro') {
          var topbar = this._parent._caller._topbar
          if (topbar) {
            if (val === 'settings') {
              topbar.node.style.backgroundColor = '#5d4078'
            }
            topbar.holder.title.dots.remove()
          }
        }
        update()
      }
    }
  },
  roll: {
    css: 'intro-roll',
    x: {
      val: 0,
      multiply: 0,
      animation: {
        time: 18,
        easing: 'outCubic',
        complete: function (cv) {
          var dots = this._dots.children
          for (var i = dots.length - 1; i >= 0; i--) {
            dots[i].css = i === -this._pos ? 'focus' : ''
          }
        }
      }
    },
    append: [Slide, {
      'img.background': '1.png',
      'title.text.dictionary': 'intro.welcome.title',
      'subtitle.text.dictionary': 'intro.welcome.body'
    }, {
      'img.background': '2.png',
      'title.text.dictionary': 'intro.devices.title',
      'subtitle.text.dictionary': 'intro.devices.body'
    }, {
      'img.background': '3.png',
      'title.text.dictionary': 'intro.connect.title',
      'subtitle.text.dictionary': 'intro.connect.body'
    }, {
      'img.background': '4.png?1',
      // {
      //   val: {
      //     val: '4.png',
      //     $accessForEveryone: '5.png'
      //   }
      // },
      'subtitle.text.dictionary': 'intro.free.body',
      button: new Button({
        'text.dictionary': 'intro.free.button',
        'events.click': function () {
          this.checkParent('on.popup', true).from = 'getStartedContinue'
        }
      })
    }],
    events: {
      grab: {
        x: true,
        up: setPosition
      }
    }
  }
}).Class

exports.getStarted = new Element({
  css: 'get-started',
  on: {
    $parent: {
      defer: function (update) {
        var parent = this._parent
        var caller = parent._caller
        var topbar = caller.checkParent('topbar', true)

        if (topbar) {
          topbar.node.style.backgroundColor = '#5d4078'
          caller._topbar = topbar
        }

        update()
      }
    }
  },
  'title.text.dictionary': 'intro.mobile.title',
  'subtitle.text.dictionary': 'intro.mobile.body',
  append: [Button, {
    css: {
      addClass: 'yes'
    },
    'text.dictionary': 'intro.mobile.button',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = popup.val
      popup.val = 'verifyMobile'
    }
  }, {
    css: {
      addClass: 'skip'
    },
    'text.dictionary': 'button.skip',
    'events.click': function () {
      this.checkParent('on.popup', true).from = false
    }
  }]
}).Class

exports.getStartedContinue = new Element({
  css: 'get-started',
  on: {
    $parent: {
      defer: function (update) {
        var parent = this._parent,
          caller = parent._caller,
          topbar = caller.checkParent('topbar', true)
        if (topbar) {
          topbar.node.style.backgroundColor = '#5d4078'
          caller._topbar = topbar
        }
        update()
      }
    }
  },
  'title.text.dictionary': 'intro.register.title',
  'subtitle.text.dictionary': 'intro.register.body',
  append: [Button, {
    css: {
      addClass: 'facebook'
    },
    'text.dictionary': 'text.account.signup.facebook',
    'events.click': function () {
      var api = this.checkParent('api', true)
      api.facebook.login.val = true
    }
  }, {
    css: {
      addClass: 'email'
    },
    'text.dictionary': 'text.account.signup.email',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      this.parent._topbar.node.style.backgroundColor = '#5d4078'
      popup.previous = popup.val
      popup.val = 'registerEmail'
    }
  }, {
    css: {
      addClass: 'operator'
    },
    display: {
      val: 'none',
      $hasOperator: 'block'
    },
    'text.dictionary': 'text.account.signup.operator',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      this.parent._topbar.node.style.backgroundColor = '#5d4078'
      popup.previous = popup.val
      popup.val = 'operatorList'
    }
  }],
  'or.text.dictionary': 'text.or',
  signin: new Button({
    'text.dictionary': 'text.account.signin.title',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      this.parent._topbar.node.style.backgroundColor = '#5d4078'
      popup.previous = popup.val
      popup.val = 'login'
    }
  })
}).Class

exports.Dots = new Element({
  css: 'intro-dots',
  append: [Element, {
    css: 'focus'
  }, {}, {}, {}]
}).Class

function setPosition (e, d, ld) { // unify with switcher
  var treshold = 120,
    flick = 10,
    l = this.children.length,
    oldPos = this._pos || (this._pos = 0),
    newPos = oldPos

  if (Math.abs(ld.x) > flick) {
    if (ld.x < 0 && !(d.x > treshold)) newPos = Math.max(oldPos - 1, -l + 1)
    if (ld.x > 0 && !(d.x < -treshold)) newPos = Math.min(oldPos + 1, 0)
  } else {
    if (d.x < -treshold) newPos = Math.max(oldPos - 1, -l + 1)
    if (d.x > treshold) newPos = Math.min(oldPos + 1, 0)
  }

  if (this.x._e) this.x = {
      _esub: this.x._e._val
    }
  setPos(this, newPos)
}

function setPos (roll, newPos) {
  var oldPos = roll._pos || (roll._pos = 0),
    dts = roll._dots

  if (newPos !== oldPos) {
    roll.x = {
      multiply: newPos
    }
    roll._pos = newPos
  }
}

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","../img":"/Users/youzi/dev/mtv-play/components/img/index.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/languages.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var util = require( 'old-vigour-js/util' )
var Icon = require( '../icon' )
var Item = require( '../item' )
var cases = require( 'old-vigour-js/browser/cases' )
var config = require( 'old-vigour-js/util/config' )
var raf = require( 'old-vigour-js/browser/animation/raf' )
var Page = require( './page' )

module.exports = new Page( {
  css: 'languages',
  on: {
    $parent: {
      defer: function( update ) {
        this._parent._caller.data = config.languages
        this._parent.language._update()
        update()
      }
    },
    language: {
      defer: function( update ) {
        var _this = this
        raf( function() {
          if( !_this._parent ) {
            update( true )
          } else {
            var caller = _this._parent._caller,
              language = ( _this._parent._val || caller.checkParent( 'on.language', true ) ),
              elem = caller.find( '_d', language.val )
            if( elem ) {
              if( _this.focus && _this.focus._node ) {
                _this.focus.css = {
                  removeClass: 'current'
                }
              }
              _this.focus = elem
              elem.css = {
                addClass: 'current'
              }
            }
            update()
          }
        } )
      }
    }
  },
  collection: {
    data: true,
    element: new Item( {
      'title.text': {
        data: true,
        dictionary: function( val, cv ) {
          return cv && 'text.languages.' + cv + '.title'
        }
      },
      'events.click': function() {
        var language = this.checkParent( 'on.language', true )
        var popup = this.checkParent( 'on.popup', true ).from
        language.$userOrigin.val = String( this.data )
        popup.direction = -1
        popup.val = 'settings'
      }
    } )
  }
} ).Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/mobile.js":[function(require,module,exports){
//anim up op phone
// anders scale en fade
var Element = require( 'old-vigour-js/app/ui/element' )
var util = require( 'old-vigour-js/util' )
var Icon = require( '../icon' )
var cases = require( 'old-vigour-js/browser/cases' )
var Button = require( '../button' )
var Input = require( '../text/input' )
var Item = require( '../item' )
var config = require( 'old-vigour-js/util/config' )
var raf = require( 'old-vigour-js/browser/animation/raf' )
var Page = require( './page' )
var app = require( 'old-vigour-js/app/' )

exports.Verify = new Page( {
  css: 'verifymobile',
  'on.$parent.defer': function( update ) {
    this._parent._caller.data = {
      code: app.telCode
    }
    update()
  },
  top: {
    'text.dictionary': 'text.enterYourNumber'
  },
  country: new Item.IconRight( {
    txt: {
      text: {
        data: 'code',
        dictionary: function( c, cv ) {
          return cv && cv.slice && 'text.countries.' + cv.slice( 0, 2 ) + '.title'
        },
        add: [ ' (+', {
          data: 'code',
          transform: function( c, cv ) {
            return cv && config.countrycodes[ cv ]
          }
        }, ')' ]
      }
    },
    'events.click': function() {
      var popup = this.checkParent( 'on.popup', true ).from
      popup.val = 'countryCodes'
    }
  } ),
  phonenumber: new Input( {
    input: 'phone',
    'lefticon.html': {
      data: 'code',
      transform: function( v, cv ) {
        return cv && ( '+' + config.countrycodes[ cv ] || cv )
      }
    }
  } ),
  verify: new Button( {
    text: {
      dictionary: 'text.verify'
    },
    'events.click': function() {
      var api = this.checkParent( 'api', true )

      if( this.parent.phonenumber.input ) console.log( this.parent.phonenumber.input )

      api.mobile.verify.val = {
        phonenumber: this.parent.phonenumber.val,
        country: config.countrycodes[ this.parent.data.code.val ]
      }

    }
  } )
} ).Class

//use region to select
exports.CountryCodes = new Element( {
  css: 'languages codes',
  on: {
    $parent: {
      defer: function( update ) {
        this._parent._caller.data = config.mtvmobile
        this._parent.language.val = app.telCode
        this._parent.language._update()
        update()
      }
    },
    language: {
      //handig in het framework!
      defer: function( update ) {
        var _this = this
        raf( function() {
          if( !_this._parent ) {
            update( true )
          } else {
            var caller = _this._parent._caller,
              language = ( _this._parent._val || caller.checkParent( 'on.language', true ) ).from,
              elem = caller.find( '_d', language.val )
            if( elem ) {
              if( _this.focus && _this.focus._node ) {
                _this.focus.css = {
                  removeClass: 'current'
                }
              }
              _this.focus = elem
              elem.css = {
                addClass: 'current'
              }
            }
            update()
          }
        } )
      }
    }
  },
  collection: {
    data: true,
    element: new Item( {
      'title.text': {
        data: true,
        dictionary: function( val, cv ) {
          return cv && cv.slice && 'text.countries.' + cv.slice( 0, 2 ) + '.title'
        },
        add: function( c, cv ) {
          return ' (+' + config.countrycodes[ String( this.data ) ] + ')'
        }
      },
      'events.click': function() {
        var popup = this.checkParent( 'on.popup', true ).from
        app.telCode.val = String( this.data )
        popup.val = 'verifyMobile'

      }
    } )
  }
} ).Class
},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../text/input":"/Users/youzi/dev/mtv-play/components/text/input.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/newsletter.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var Icon = require( '../icon' )
var Item = require( '../item' )
var Page = require( './page' )
var app = require( 'old-vigour-js/app/' )

module.exports = new Page( {
  css: 'newsletter',
  newsletterSwitcher: new Item.Switcher( {
    css: 'ui-item switch',
    'on.$render.defer': function( update ) {
      this._parent._caller.righticon.hold.switchOn = app.user.accept_newsletter.from
      update()
    },
    txt: {
      'title.text.dictionary': 'text.newsletterTitle',
      'subtitle.text.dictionary': 'text.newsletterSubtitle'
    },
    'events.click': function() {
      var newsletter = app.user.accept_newsletter.from
      newsletter.val = !newsletter.val
    }
  } )
} ).Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/operator.js":[function(require,module,exports){
var Button = require('../button')
var Input = require('../text/input')
var Item = require('../item')
var Page = require('./page')
var auth = require('./auth')
var RegisterConditions = auth.RegisterConditions
var app = require('old-vigour-js/app/')
var dictionary = require('old-vigour-js/app/dictionary')
var operatorText = dictionary.get('text.operator.future')

exports.List = new Page({
  css: 'operator',
  on: {
    $parent: {
      defer: function (update) {
        this._parent._caller.data = app.operators
        update()
      }
    }
  },
  top: {
    text: {
      dictionary: 'text.operator.select'
    }
  },
  collection: {
    data: true,
    element: new Item.IconRightSub({
      extend: {
        support_classic_registration: function () {},
        available_from: function () {},
        available: function () {}
      },
      support_classic_registration: {
        data: 'support_classic_registration'
      },
      available_from: {
        data: 'available_from'
      },
      available: {
        data: 'available'
      },
      'events.click': function () {
        if (this.available.val === true) {
          var popup = this.checkParent('on.popup', true).from
          popup.previous = {
            val: 'operatorList',
            data: this.parent.data
          }
          popup.data = this.data
          popup.val = this.support_classic_registration.val === true ? 'operatorAuthAlt' : 'operatorAuth'
        } else {
          app.notification.val = operatorText.val + ' ' + this.available_from.val
        }
      }
    })
  }
}).Class

exports.ListUpgrade = new exports.List({
  collection: {
    data: true,
    element: new Item.IconRightSub({
      extend: {
        support_classic_registration: function () {},
        available_from: function () {},
        available: function () {}
      },
      support_classic_registration: {
        data: 'support_classic_registration'
      },
      available_from: {
        data: 'available_from'
      },
      available: {
        data: 'available'
      },
      'events.click': function () {
        if (this.available.val === true) {
          var popup = this.checkParent('on.popup', true).from
          popup.previous = {
            val: 'operatorListUpgrade',
            data: this.parent.data
          }
          popup.data = this.data
          popup.val = 'operatorAuthUpgrade'
        } else {
          app.notification.val = operatorText.val + ' ' + this.available_from.val
        }
      }
    })
  }
}).Class

exports.Register = new Input.Form({
  css: 'login operator',
  scrollbar: 'y',
  x: {
    translate: true
  },
  top: {
    text: {
      dictionary: 'text.operator.register'
    }
  },
  username: new Input({
    input: 'user'
  }),
  password: new Input({
    input: 'password'
  }),
  'desktop.confirm': new Button({
    text: {
      dictionary: 'text.account.signin.title'
    },
    'events.confirm': function () {
      var form = this.parent
      form.done.call(form)
    }
  }),
  getInTouch: {
    text: {
      dictionary: 'text.operator.help'
    },
    button: {
      on:{
        url: {
          data: 'url'
        },
        faq_url: {
          data: 'faq_url'
        },
      },
      text: {
        data: 'title'
      },
      'events.click': function () {
        app.api.url.val = this.on.faq_url.val || this.on.url.val
      }
    }
  },
  conditions: new RegisterConditions(),
  verify: ['password'],
  define: {
    done: function () {
      if (this.verified) {
        var api = this.checkParent('api', true)
        api.operator.login.val = {
          operator: this.data._name,
          username: this.username.val,
          password: this.password.val
        }
      } else {
        app.notification.val = 'invalid'
      }
    }
  }
}).Class

exports.RegisterAlternative = new Page({
  css: 'register operator',
  top: {
    text: {
      dictionary: 'text.operator.register'
    }
  },
  '!windowsMobile.facebook': new auth.FbButton({
    'text.dictionary': 'text.account.signup.facebook',
    'events.click': function () {
      var operator = removeESCAPED(this.parent.data._name)
      window.localStorage.setItem('registerOperator', operator)
      var api = this.checkParent('api', true)
      api.facebook.login.val = true
    }
  }),
  email: new Button({
    text: {
      dictionary: 'text.account.signup.email'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = popup.val
      popup.data = this.parent.data
      popup.val = 'registerEmail'
    }
  }),
  conditions: new RegisterConditions({
    css: 'alignedTop'
  })
}).Class

exports.Upgrade = new exports.Register({
  top: {
    text: {
      dictionary: 'text.operator.authenticate'
    }
  },
  define: {
    done: function () {
      if (this.verified) {
        var api = this.checkParent('api', true)
        api.operator.upgrade.val = {
          operator: removeESCAPED(this.data._name),
          username: this.username.val,
          password: this.password.val
        }
      } else {
        app.notification.val = 'invalid'
      }
    }
  }
}).Class

function removeESCAPED(string) {
  var arr = string.split('__$ESCAPED_')
  return arr[1] || arr[0]
}

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../text/input":"/Users/youzi/dev/mtv-play/components/text/input.js","./auth":"/Users/youzi/dev/mtv-play/components/popup/auth.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/page.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )

module.exports = new Element( {
  x: {
    translate: true
  },
  scrollbar: 'y'
} ).Class

},{"old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/profile.js":[function(require,module,exports){
// anim up op phone
// anders scale en fade
var Element = require('old-vigour-js/app/ui/element')
var Icon = require('../icon')
var Item = require('../item')
var cases = require('old-vigour-js/browser/cases')
var dictionary = require('old-vigour-js/app/dictionary')
var app = require('old-vigour-js/app/')

var MenuItems = new Element({
  append: [new Item({
    css: 'ui-item',
    lefticon: new Icon(),
    title: {}
  }).Class, {
    'lefticon.icon': 'logout',
    'title.text.dictionary': 'text.account.logout',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true)
      popup.from.val = 'login'

      app.user.token.val = false
    }
  }]
}).Class

module.exports = exports = new Element({
  css: 'profile',
  pic: {
    icon: new Icon({
      icon: 'profile',
      display: {
        val: function () {
          return app.user.profilepic.val ? 'none' : 'block'
        },
        listen: app.user.profilepic
      }
    }),
    img: {
      background: app.user.profilepic,
      display: {
        val: function () {
          return app.user.profilepic.val ? 'block' : 'none'
        },
        listen: app.user.profilepic
      }
    }
  },
  username: {
    text: {
      val: app.user.first_name,
      transform: function (v, cv) {
        if (cv) {
          return cv
        } else {
          var email = app.user.email && app.user.email.val
          return email ? email.split('@')[0] : ''
        }
      },
      listen: app.user.email
    }
  },
  email: {
    text: app.user.email
  },
  holder: {
    display: {
      val: app.user.operator_name,
      transform: function (v, cv) {
        return cv ? 'none' : 'block'
      }
    },
    blocks: {
      allshows: {
        bold: {
          text: {
            dictionary: 'text.all'
          }
        },
        light: {
          text: {
            dictionary: 'text.nav.shows'
          }
        }
      },
      allchannels: {
        display: {
          val: app.user.role,
          transform: function (v, cv) {
            return cv === 3 ? 'none' : 'table-cell'
          }
        },
        bold: {
          text: {
            dictionary: 'text.all'
          }
        },
        light: {
          text: {
            dictionary: 'text.nav.channels'
          }
        }
      },
      everyepisode: {
        bold: {
          text: {
            dictionary: 'text.every'
          }
        },
        light: {
          text: {
            dictionary: 'text.episode'
          }
        }
      }
    },
    unlock: {
      display: {
        val: 'block',
        $isUpgraded: 'none'
      },
      text: {
        dictionary: 'text.purchase.getMore'
      }
    }
  },
  button: {
    text: {
      val: app.user.role,
      transform: function (c, cv) {
        var operatorName = app.user.operator_name.val
        if (operatorName) {
          return dictionary.get('text.premium').val
        } else if (!app.user.role.val) {
          return dictionary.get('text.upgrade').val
        } else if (app.user.role.val === 1) {
          return dictionary.get('text.premium').val
        } else if (app.user.role.val === 2) {
          return dictionary.get('text.mtvMobile').val
        } else if (app.user.role.val === 3) {
          return dictionary.get('text.trial').val
        }
        return cv
      },
      listen: app.user.operator_name
    },
    css: {
      val: app.user.role.text
    },
    'events.click': function () {
      if (app.user.role.val === 0) {
        var popup = this.checkParent('on.popup', true).from
        popup.previous = 'profile'
        popup.val = cases.$storeAvailable.val || cases.$hasMobile.val ? 'upgrade' : 'roadblock' // 'upgrade' Skirre gibbels hack
      }
    }
  },
  operatorSponsor: {
    display: {
      val: app.user.operator_name,
      transform: function (v, cv) {
        return cv ? 'block' : 'none'
      }
    },
    text: 'brought to you by',
    operatorLogo: {
      background: {
        val: app.user.operator_name,
        transform: function (v, cv) {
          var operators = cv && app.operators
          if (operators) {
            for (var i in operators) {
              var op = operators[i]
              if (op && (op = op._val)) {
                var title = op.title
                if (title && title.val.toLowerCase() === cv.toLowerCase()) {
                  return op.image._val
                }
              }
            }
          }
          return ''
        }
      }
    }
  },
  items: new MenuItems()
}).Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/roadblock.js":[function(require,module,exports){
var Element = require('old-vigour-js/app/ui/element')
var app = require('old-vigour-js/app')
var util = require('old-vigour-js/util')
var Icon = require('../icon')
var Item = require('../item')
var cases = require('old-vigour-js/browser/cases')
var Button = require('../button')
var Input = require('../text/input')
var config = require('old-vigour-js/util/config')
var Img = require('../img')
var Article = require('./article')
var Page = require('./page')

module.exports = exports = new Page({
  css: 'roadblock',
  logo: {
    display: {
      val: 'block',
      $isLoggedIn: 'none'
    }
  },
  '!native.mockup': {
    display: {
      val: 'none',
      $isLoggedIn: 'block'
    }
  },
  append: [
    new Element({
      css: 'info'
    }).Class, {
      'title.text.dictionary': 'text.needToRegister',
      'description.text.dictionary': 'text.easyRegister',
      display: {
        val: 'block',
        $isLoggedIn: 'none'
      }
    }, {
      'title.text.dictionary': 'text.upgradeRequired',
      'description.text.dictionary': 'text.upgradeRequired',
      display: {
        val: 'none',
        $isLoggedIn: 'block',
        transform: {
          val: 'none',
          $storeAvailable: false
        }
      }
    }, {
      'title.text.dictionary': 'text.mobileUpgrade',
      'description.text.dictionary': 'text.mobileUpgradeInfo',
      '!native.stores': {
        windowsstore: {},
        applestore: {},
        googlestore: {},
        googlecast: {},
        samsungtv: {},
        lgtv: {}
      },
      display: {
        val: 'none',
        $isLoggedIn: 'block',
        transform: {
          val: false,
          $storeAvailable: 'none'
        }
      }
    }
  ],
  signup: new Button({
    display: {
      val: 'block',
      $isLoggedIn: 'none'
    },
    'text.dictionary': 'text.account.signup.title',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = popup.val
      popup.val = 'register'
    }
  }),
  signin: new Button({
    display: {
      val: 'block',
      $isLoggedIn: 'none'
    },
    'text.dictionary': 'text.account.signin.title',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = popup.val
      popup.val = 'login'
    }
  }),
  upgrade: new Button({
    display: {
      val: 'none',
      $isLoggedIn: 'block',
      transform: {
        val: 'none',
        $storeAvailable: false
      }
    },
    'text.dictionary': 'text.upgrade',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = popup.val
      popup.val = 'upgrade'
    }
  }),
  or: {
    display: {
      val: 'none',
      $hasOperator: 'block'
    },
    text: {
      dictionary: 'text.or'
    }
  },
  operator: new Button({
    'text.dictionary': 'text.purchase.operator',
    display: {
      val: 'none',
      $hasOperator: 'block'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = popup.val
      popup.data = app.cloud.data.get(['mtvData', 'operators'])
      popup.val = 'operatorListUpgrade'
    }
  })
}).Class

exports.Media = new Page({
  css: 'roadblock media share',
  'holder.thumb': new Item.Thumb({
    thumb: {
      h: 60,
      img: {
        h: 60
      }
    },
    righticon: false
  }),
  buy: new Button({
    display: {
      val: 'none',
      $storeAvailable: 'block',
      '!$hasEpisodePass': 'none'
    },
    text: {
      dictionary: 'text.unlockPrice',
      add: [ ' ', app.api.price.single ]
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.val = 'buySingle'
    }
  }),
  or: {
    display: {
      val: 'none',
      $storeAvailable: 'block',
      '!$hasEpisodePass': 'none'
    },
    text: {
      val: '- ',
      add: [ {
        dictionary: 'text.or'
      }, ' -' ]
    }
  },
  upgrade: new Button({
    'text.dictionary': 'text.upgrade',
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = {
        val: 'roadblockMedia',
        data: this.parent.data
      }
      popup.val = 'upgrade'
    }
  }),
  mobile: new Button({
    'text.dictionary': 'text.purchase.freeWithMTV',
    display: {
      val: 'none',
      $hasMobile: 'block'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = 'upgrade'
      popup.val = 'verifyMobile'
    }
  }) // is set later
}).Class

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../text/input":"/Users/youzi/dev/mtv-play/components/text/input.js","./article":"/Users/youzi/dev/mtv-play/components/popup/article.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/settings.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var util = require( 'old-vigour-js/util' )
var Icon = require( '../icon' )
var Item = require( '../item' )
var cases = require( 'old-vigour-js/browser/cases' )
var Button = require( '../button' )
var Input = require( '../text/input' )
var config = require( 'old-vigour-js/util/config' )
var raf = require( 'old-vigour-js/browser/animation/raf' )
var Page = require( './page' )
var dictionary = require( 'old-vigour-js/app/dictionary' )
var app = require( 'old-vigour-js/app/' )

module.exports = new Element( {
  css: 'settings',
  scroller: {
    language: new Item.IconRightSub( {
      txt: {
        'title.text.dictionary': 'text.settings.languages.title',
        'subtitle.text.dictionary': 'text.settings.languages.subtitle'
      },
      'events.click': function() {
        var popup = this.checkParent( 'on.popup', true ).from
        popup.val = 'languages'
      }
    } ),
    FAQ: new Item.IconRightSub( {
      txt: {
        'title.text.dictionary': 'settings.help',
        'subtitle.text.dictionary': 'settings.helpSub'
      },
      'events.click': function() {
        var popup = this.checkParent( 'on.popup', true ).from
        popup.val = 'faq'
      }
    } ),
    help: new Item.IconRightSub( {
      txt: {
        'title.text.dictionary': 'settings.feedback',
        'subtitle.text.dictionary': 'settings.feedbackSub'
      },
      'events.click': function() {
        var api = this.checkParent( 'api', true )
        api.email.send.val = {
          address: 'helpme@mtvplay.tv',
          subject: dictionary.get( 'text.mailHelp.title' ).val,
          body: dictionary.get( 'text.mailHelp.body' ).val
        }
      }
    } ),
    '$hasMobile.about': new Item.IconRightSub( {
      txt: {
        'title.text.dictionary': 'settings.about',
        'subtitle.text.dictionary': 'settings.aboutSub'
      },
      'events.click': function() {
        var popup = this.checkParent( 'on.popup', true ).from,
          user = app.user //TODO: fix
        popup.previous = 'settings'
        popup.data = user.data.from.get( [ 'about', 'list', '0' ] )
        popup.val = 'article'
      }
    } ),
    newsletter: new Item.IconRightSub( {
      txt: {
        'title.text.dictionary': 'settings.enableNewsletter.title',
        'subtitle.text.dictionary': 'settings.enableNewsletter.subtitle'
      },
      display: {
        val: 'none',
        $isLoggedIn: 'table'
      },
      'events.click': function() {
        var popup = this.checkParent( 'on.popup', true ).from
        popup.val = 'newsletter'
      }
    } ),
    'native.wifi': new Item.IconRightSub( {
      txt: {
        'title.text.dictionary': 'settings.connectivity',
        'subtitle.text.dictionary': 'settings.connectivitySub'
      },
      'events.click': function() {
        var popup = this.checkParent( 'on.popup', true ).from
        popup.val = 'wifi'
      }
    } ),
    verifyMobile: new Item.IconRightSub( {
      display: {
        val: cases.$hasMobile,
        transform: function( v, cv ) {
          return cv && cases.$isLoggedIn.val ? 'table' : 'none'
        },
        listen: cases.$isLoggedIn
      },
      txt: {
        'title.text.dictionary': 'settings.verifyMobile',
        'subtitle.text.dictionary': 'settings.verifyMobileSub'
      },
      'events.click': function() {
        var popup = this.checkParent( 'on.popup', true ).from
        popup.previous = 'settings'
        popup.val = 'verifyMobile'
      }
    } ),
    'native.intro': new Item.IconRightSub( {
      txt: {
        'title.text.dictionary': 'settings.intro',
        'subtitle.text.dictionary': 'settings.introSub'
      },
      'events.click': function() {
        var popup = this.checkParent( 'on.popup', true ).from
        popup.previous = 'settings'
        popup.val = 'intro'
      }
    } )
  },
  version: {
    text: {
      val: 'MTV Play -',
      add: [ ' ', window.package && window.package.version ]
    }
  },
  phone: {
    h: {
      parent: 'h'
    },
    scroller: {
      scrollbar: 'y',
      h: {
        parent: 'h',
        sub: 80
      }
    }
  }
} ).Class

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../text/input":"/Users/youzi/dev/mtv-play/components/text/input.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/share.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var util = require( 'old-vigour-js/util' )
var Icon = require( '../icon' )
var Item = require( '../item' )
var cases = require( 'old-vigour-js/browser/cases' )
var Button = require( '../button' )
var Input = require( '../text/input' )
var config = require( 'old-vigour-js/util/config' )
var Img = require( '../img' )
var Page = require( './page' )

module.exports = exports = new Page( {
  css: 'share',
  'holder.thumb': new Item.Thumb( {
    thumb: {
      h: 60,
      img: {
        h: 60
      }
    },
    righticon: false
  } ),
  facebook: new Item.IconLeft( {
    lefticon: {
      icon: 'facebook'
    },
    'txt.text.dictionary': 'text.shareFacebook',
    'events.click': function() {
      var api = this.checkParent( 'api', true )
      api.facebook.share.val = {
        val: true,
        url: true
      }
    }
  } ),
  email: new Item.IconLeft( {
    lefticon: {
      icon: 'email'
    },
    'txt.text.dictionary': 'text.shareEmail',
    'events.click': function() {
      var api = this.checkParent( 'api', true )
      api.email.share.val = true
    }
  } )
} ).Class

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","../text/input":"/Users/youzi/dev/mtv-play/components/text/input.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/popup/upgrade.js":[function(require,module,exports){
var app = require('old-vigour-js/app')
var Button = require('../button')
var Page = require('./page')

exports = module.exports = new Page({
  css: 'upgrade',
  block: {
    img: {},
    'title.text.dictionary': 'text.purchase.goPremium',
    'txt.text.dictionary': 'text.purchase.getMore'
  },
  bottom: {
    'text.container': 'text.legalContainer'
  },
  monthlyFee: new Button({
    text: {
      dictionary: 'text.purchase.monthlyPass.title',
      add: [' ', app.api.price.monthly]
    },
    display: {
      val: 'none',
      $storeAvailable: 'block'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.val = 'buyMonthly'
    }
  }),
  annualFee: new Button({
    text: {
      dictionary: 'text.purchase.yearlyPass.title',
      add: [' ', app.api.price.yearly]
    },
    display: {
      val: 'none',
      $storeAvailable: 'block'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.val = 'buyYearly'
    }
  }),
  upgradeUsingPhone: new Button({
    text: {
      dictionary: 'tex.buyPremiumPhoneButton'
    },
    display: {
      val: 'block',
      $storeAvailable: 'none'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = 'upgrade'
      popup.val = 'roadblockUpgrade'
    }
  }),
  mobile: new Button({
    'text.dictionary': 'text.purchase.freeWithMTV',
    display: {
      val: 'none',
      $hasMobile: 'block'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = 'upgrade'
      popup.val = 'verifyMobile'
    }
  }),
  or: {
    display: {
      val: 'none',
      $hasOperator: 'block'
    },
    text: {
      dictionary: 'text.or'
    }
  },
  operator: new Button({
    'text.dictionary': 'text.purchase.operator',
    display: {
      val: 'none',
      $hasOperator: 'block'
    },
    'events.click': function () {
      var popup = this.checkParent('on.popup', true).from
      popup.previous = 'upgrade'
      popup.data = app.cloud.data.get(['mtvData', 'operators'])
      popup.val = 'operatorListUpgrade'
    }
  })
}).Class

},{"../button":"/Users/youzi/dev/mtv-play/components/button/index.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js"}],"/Users/youzi/dev/mtv-play/components/popup/wifi.js":[function(require,module,exports){
var Element = require( 'old-vigour-js/app/ui/element' )
var Icon = require( '../icon' )
var Item = require( '../item' )
var Page = require( './page' )
var app = require( 'old-vigour-js/app/' )

module.exports = new Page( {
  css: 'wifi',
  wifiSwitcher: new Item.Switcher( {
    css: 'ui-item switch',
    'on.$render.defer': function( update ) {
      this._parent._caller.righticon.hold.switchOn = app.wifiOnly
      update()
    },
    txt: {
      'title.text.dictionary': 'settings.enableCellular.title',
      'subtitle.text.dictionary': 'settings.enableCellular.subtitle'
    },
    'events.click': function() {
      var wifiOnly = app.wifiOnly
      wifiOnly.val = !wifiOnly.val
    }
  } )
} ).Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../item":"/Users/youzi/dev/mtv-play/components/item/index.js","./page":"/Users/youzi/dev/mtv-play/components/popup/page.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/rotate-message/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var Icon = require( '../icon' )

module.exports = new Element( {
  css: 'rotate-message',
  holder: {
    icon: new Icon( {
      icon: 'phone'
    } ),
    message: {
      text: {
        dictionary: 'text.rotateDevice'
      }
    }
  }
} ).Class

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/rotate-message/style.less","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/rotate-message/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/common.less"][0].apply(exports,arguments)
},{}],"/Users/youzi/dev/mtv-play/components/second/bar/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var dictionary = require( 'old-vigour-js/app/dictionary' )
var Icon = require( '../../icon' )
var text = require( '../../text' )
var active = dictionary.get( 'connect.active' )
var waiting = dictionary.get( 'connect.waiting' )
var cases = require( 'old-vigour-js/browser/cases' )

module.exports = new Element( {
  css: 'second-bar',
  device: new Icon( {
    icon: {
      data: 'activeClient.device'
    }
  } ),
  info: {
    html: {
      data: 'activeClient.device',
      transform: function( v, cv ) {
        return cv ? active.val + ' ' + text.highlight( cv ) : waiting.val
      },
      listen: active
    }
  }
} ).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../text":"/Users/youzi/dev/mtv-play/components/text/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/bar/style.less","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/second/bar/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/channel/index.js":[function(require,module,exports){
require('./style.less')

var app = require('old-vigour-js/app/')
var Element = require('old-vigour-js/app/ui/element')
var Icon = require('../../icon')
var Img = require('../../img')
var Grid = require('../grid')

var information = new Element({
  w: {
    val: Grid.colWidth,
    add: 10,
    multiply: 2,
    sub: 10
  },
  y: {
    val: Grid.rowHeight,
    divide: 2,
    add: 40
  },
  title: {
    text: {
      data: 'media.title'
    }
  },
  img: new Img({
    background: {
      data: 'media.img',
      range: 100
    },
    w: {
      parent: 'w'
    },
    h: {
      self: 'w',
      divide: 4 / 3
    }
  }),
  extratitle: {
    text: {
      data: 'media.title'
    }
  },
  description: {
    text: {
      data: 'media.description'
    }
  }
})

var cover = new Img({
  h: app.h,
  w: {
    val: app.w,
    sub: [ information.w, 160 ]
  },
  background: {
    data: 'media.img',
    range: 100
  },
  overlay: {
    message: {
      swipeicon: new Icon({
        icon: 'swipeup'
      }),
      text: 'Press Watch Big your device to start playing!'
    }
  }
})

module.exports = new Element({
  css: 'second-channel',
  information: information,
  cover: cover
}).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../grid":"/Users/youzi/dev/mtv-play/components/second/grid/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/channel/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/second/channel/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/channels/index.js":[function(require,module,exports){
require('./style.less')

var Grid = require('../grid')
var Element = require('old-vigour-js/app/ui/element')
var Img = require('../../img')
var app = require('old-vigour-js/app/')
var epgData = require('../../epg_temp')
var Seekbar = require('../../player/seekbar')
var clockTime = epgData.clockTime

var Item = new Element({
  w: {
    parent: 'itemWidth',
    sub: 10
  },
  css: 'grid-item',
  img: new Img({
    w: {
      parent: 'w',
      sub: 2
    },
    h: {
      parent: 'w',
      multiply: 3 / 4
    },
    background: {
      range: 100
    }
  }),
  information: {
    channeltitle: {
      css: 'ui-item-text',
      text: {
        data: 'title'
      }
    },
    now: {
      text: {
        dictionary: 'text.now'
      }
    },
    epg: {
      showtitle: {
        text: {
          data: 'title'
        }
      },
      time: {
        text: {
          data: 'minutes_since_midnight',
          transform: clockTime,
          add: [ ' - ', {
            data: 'endtime',
            transform: clockTime
          } ]
        }
      },
      bar: new Seekbar({
        seek: {
          w: {
            val: epgData.minutesSinceMidnight,
            sub: {
              data: 'minutes_since_midnight'
            },
            divide: {
              data: 'duration'
            },
            transform: function ( v, cv ) {
              return !isNaN(parseInt(cv)) ? cv * 100 + '%' : 0
            },
            clear: true
          }
        },
        button: false
      }),
      model: {
        inherit: false
      }
    }
  },
  model: {
    subscription: {
      epgid: true
    },
    val: function ( data ) {
      var epgid = data.epgid && data.epgid.val
      if ( epgid !== void 0) {
        this.information.epg.data = epgData.now(epgid)
        this.model = false
      }
    }
  }
}).Class

Grid = new Grid({
  css: 'second-channels',
  itemWidth: {
    val: app.w,
    sub: 160,
    divide: {
      val: 4,
      min: 4
    },
    clear: true
  },
  title: {
    text: 'channels'
  },
  y: {
    val: Grid.rowHeight,
    divide: 2,
    add: 40
  },
  collection: {
    data: 'channels',
    element: new Item()
  },
  model: function ( data ) {
    var keys = data.channels && data.channels.keys
    var length = keys && keys.length

    if ( length !== this._length) {
      this.itemWidth = {
        divide: length
      }
      this._length = length
    }
  }
})

module.exports = Grid.Class

},{"../../epg_temp":"/Users/youzi/dev/mtv-play/components/epg_temp.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../../player/seekbar":"/Users/youzi/dev/mtv-play/components/player/seekbar/index.js","../grid":"/Users/youzi/dev/mtv-play/components/second/grid/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/channels/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/second/channels/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/discover/index.js":[function(require,module,exports){
require('./style.less')

var app = require('old-vigour-js/app/')
var Element = require('old-vigour-js/app/ui/element')
var Grid = require('../grid')
var Img = require('../../img')
var cases = require('old-vigour-js/browser/cases')

var DiscoverGrid = new Grid({
  itemHeight: Grid.rowHeight,
  title: {},
  w: {
    self: 'itemWidth',
    add: 10,
    multiply: 1
  },
  collection: {
    data: true
  },
  model: {
    val: function (data) {
      data = data[this.collection._flag.data[2]]
      var keys = data && data.keys
      var length = keys && keys.length
      if (keys && length !== this._length) {
        var page = this.parent
        this.w = {
          multiply: Math.ceil(length / 4) || 1
        }
        this._length = length
        page._index = null
        page.horizontalScroll.update()
      }
    }
  }
}).Class

var Carousel = new Element({
  title: {
    text: {
      dictionary: 'text.nav.discover'
    }
  },
  holder: {
    h: {
      val: Grid.rowHeight,
      add: 10,
      multiply: 2,
      sub: 10
    },
    w: {
      val: Grid.colWidth,
      add: 10,
      multiply: 3,
      sub: 10
    },
    roll: {
      w: {
        parent: 'w'
      },
      h: {
        parent: 'h'
      },
      x: {
        parent: 'w',
        multiply: {
          data: 'carousel'
        },
        animation: !cases.chromecast && {
          easing: 'outCubic',
          time: 36
        }
      },
      collection: {
        data: 'marquee',
        element: new Img({
          w: {
            parent: 'w'
          },
          h: {
            parent: 'h'
          },
          background: {
            range: 100
          }
        })
      }
    }
  }
}).Class

var discoverPage = new Element()

discoverPage.extend({
  horizontalScroll: function (val) {
    var p = val.val
    var treshold = 1 / 4
    var index = Math.min(~~(p / treshold), 3)

    if (index !== this._index) {
      var children = this.children
      if (index === 0) {
        this.x = 0
      } else if (index === 1) {
        this.x = -children[0].holder.w.val - 80
      } else if (index === 2) {
        this.x = -children[0].holder.w.val - 80 - children[1].w.val - 80
      } else {
        this.x = -children[0].holder.w.val - 80 - children[1].w.val - 80 - children[2].w.val - 80
      }

      for (var i = children.length - 1, makeGone, child; i >= 0; i--) {
        child = children[i]
        if (makeGone) {
          child.opacity = 0
        } else if (i !== index) {
          child.opacity = 0.3
        } else {
          child.opacity = 1
          makeGone = true
        }
      }

      this._index = index
    }
  }
})

module.exports = new discoverPage.Class({
  css: 'second-discover',
  '!chromecast.x.animation': {
    easing: 'outCubic',
    time: 36
  },
  y: {
    val: Grid.rowHeight,
    divide: 2,
    add: 40
  },
  horizontalScroll: {
    data: 'scroll'
  },
  spotlight: new Carousel(),
  releases: new DiscoverGrid({
    title: {
      text: {
        dictionary: function () {
          var region = app.region.val
          if (region) {
            var role = app.user.role.val
            role = !role || role === 3 ? 'free' : 'premium'
            return region && 'text.discover.' + region.toLowerCase() + '.row1.' + role
          }
        },
        listen: app.user.role
      }
    },
    collection: {
      data: 'releases'
    }
  }),
  recommended: new DiscoverGrid({
    title: {
      text: {
        dictionary: function () {
          var region = app.region.val
          if (region) {
            var role = app.user.role.val
            role = !role || role === 3 ? 'free' : 'premium'
            return region && 'text.discover.' + region.toLowerCase() + '.row2.' + role
          }
        },
        listen: app.user.role
      }
    },
    collection: {
      data: 'recommended'
    }
  }),
  free: new DiscoverGrid({
    title: {
      text: {
        dictionary: function () {
          var region = app.region.val
          if (region) {
            var role = app.user.role.val
            role = !role || role === 3 ? 'free' : 'premium'
            return region && 'text.discover.' + region.toLowerCase() + '.row3.' + role
          }
        },
        listen: app.user.role
      }
    },
    collection: {
      data: 'free'
    }
  })
}).Class

},{"../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../grid":"/Users/youzi/dev/mtv-play/components/second/grid/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/discover/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/second/discover/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/episode/index.js":[function(require,module,exports){
require('./style.less')

var app = require('old-vigour-js/app/')
var Element = require('old-vigour-js/app/ui/element')
var Icon = require('../../icon')
var Img = require('../../img')
var Grid = require('../grid')

var information = new Element({
  w: {
    val: Grid.colWidth,
    add: 10,
    multiply: 2,
    sub: 10
  },
  y: {
    val: Grid.rowHeight,
    divide: 2,
    add: 40
  },
  title: {
    text: {
      data: 'show.title'
    }
  },
  holder: {
    w: {
      parent: 'w'
    },
    img: new Img({
      background: {
        data: 'media.img',
        range: 100
      },
      w: {
        parent: 'w'
      },
      h: {
        self: 'w',
        divide: 4 / 3
      }
    }),
    extratitle: {
      text: {
        data: 'media.title'
      }
    },
    opacity: {
      data: 'media.number',
      transform: function ( v, cv ) {
        if ( !cv) {
          this.css = 'dontAnimate'
          return 0
        } else {
          this.css = ''
          return 1
        }
      }
    },
    subtitle: {
      text: {
        val: {
          dictionary: 'text.season'
        },
        add: [ ' ', {
          data: 'season.number'
        }, ' ', {
          dictionary: 'text.episode'
        }, ' ', {
          data: 'media.number'
        } ]
      }
    },
    description: {
      text: {
        data: 'media.description'
      }
    }

  }
})

var cover = new Img({
  h: app.h,
  w: {
    val: app.w,
    sub: [ information.w, 160 ]
  },
  background: {
    data: 'show.img',
    range: 100
  },
  overlay: {
    message: {
      swipeicon: new Icon({
        icon: {
          val: 'cast',
          $isReceiver: 'swipeup'
        }
      }),
      text: {
        dictionary: 'text.recieveSecondScreen',
        transform: false,
        $isReceiver: {
          transform: {
            dictionary: 'text.recieveMainScreen'
          }
        }
      }
    }
  }
})

module.exports = new Element({
  css: 'second-episode',
  information: information,
  cover: cover
}).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../grid":"/Users/youzi/dev/mtv-play/components/second/grid/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/episode/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/second/episode/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/grid/index.js":[function(require,module,exports){
require( './style.less' )

var app = require( 'old-vigour-js/app/' )
var Element = require( 'old-vigour-js/app/ui/element' )
var Value = require( 'old-vigour-js/value' )
var Img = require( '../../img' )
var Grid = new Element()

var Item = new Element( {
  w: {
    parent: 'itemWidth'
  },
  h: {
    parent: 'itemHeight'
  },
  css: 'grid-item',
  img: new Img( {
    w: {
      parent: 'w'
    },
    h: {
      parent: 'h'
    },
    background: {
      range: 100
    }
  } )
} ).Class

Grid.extend( {
  itemWidth: function() {},
  itemHeight: function() {}
} )

Grid.set( {
  itemHeight: {},
  itemWidth: {
    self: 'itemHeight',
    divide: 3 / 4
  },
  collection: {
    element: new Item()
  }
} )

module.exports = exports = Grid.Class
exports.Item = Item

exports.rowHeight = new Value( {
  val: app.h,
  sub: 80,
  divide: 6
} )
exports.colWidth = new Value( {
  val: exports.rowHeight,
  divide: 3 / 4
} )

},{"../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/grid/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/components/second/grid/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var app = require( 'old-vigour-js/app/' )
var cases = require( 'old-vigour-js/browser/cases' )
var Switcher = require( './switcher' )
var Screensaver = require( './screensaver' )
var Bar = require( './bar' )

module.exports = new Element( {
  css: 'second-state',
  switcher: cases.phone ? new Screensaver() : new Switcher(),
  '!phone.bar': new Bar(),
  'phone.button.title.text.dictionary': 'text.returnTap'
} ).Class

},{"./bar":"/Users/youzi/dev/mtv-play/components/second/bar/index.js","./screensaver":"/Users/youzi/dev/mtv-play/components/second/screensaver/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/style.less","./switcher":"/Users/youzi/dev/mtv-play/components/second/switcher/index.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/second/screensaver/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require( './style.less' )

var Element = require( 'old-vigour-js/app/ui/element' )
var Switcher = require( 'old-vigour-js/app/ui/switcher' )
var app = require( 'old-vigour-js/app/' )
var cases = require( 'old-vigour-js/browser/cases' )
var Img = require( '../../img' )

var BasicImg = new Img( {
  w: app.w,
  h: app.h
} ).Class

var RandomImg = new BasicImg( {
  model: {
    subscription: {
      $: {
        img: true
      }
    },
    val: function( data ) {
      if( data._name ) {
        var keys = data.keys
        if( keys ) {
          var length = keys.length
          if( length ) {
            var randomKey = keys[ ~~( Math.random() * length ) ]
            this.model = false
            this.data = data[ randomKey ]
          }
        }
      }
    }
  }
} ).Class

module.exports = exports = new Switcher( {
  css: 'second-screensaver',
  on: {
    page: {
      defer: function( update ) { // discover / shows / channels
        var page = this.$userOrigin.val
        var parent = this._parent
        var caller = parent._caller
        var content = parent.content.from
        var imgdata

        if( page === 'discover' ) {
          imgdata = content.get( 'marquee.list' )
        } else if( page === 'shows' ) {
          imgdata = content.get( 'shows' )
        } else if( page === 'channels' ) {
          imgdata = content.get( 'channels' )
        }

        caller.transition = {
          element: RandomImg,
          $params: {
            data: imgdata
          },
          $options: {
            force: true
          }
        }

        update()
      }
    },
    show: {
      defer: function( update ) {
        var showdata = this.$userOrigin.val
        var parent = this._parent
        var caller = parent._caller

        caller.transition = {
          element: BasicImg,
          $params: {
            data: showdata
          },
          $options: {
            force: true
          }
        }

        update()
      }
    },
    media: {
      defer: function( update ) {
        var episodedata = this.$userOrigin.val
        var parent = this._parent
        var caller = parent._caller

        caller.transition = {
          element: BasicImg,
          $params: {
            data: episodedata
          },
          $options: {
            force: true
          }
        }

        update()
      }
    }
  },
  onTransition: function( current, last, direction, options ) {
    if( last ) {
      last.opacity = {
        val: 0,
        animation: {
          start: 1,
          time: 12
        }
      }
    }

    current.opacity = {
      val: 1,
      animation: {
        start: 0,
        time: 12,
        delay: 12,
        done: function() {
          if( last ) last.remove()
        }
      }
    }

    this.add( current )
  }
} ).Class

},{"../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/screensaver/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/app/ui/switcher":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/second/screensaver/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/show/index.js":[function(require,module,exports){
require('./style.less')

var app = require('old-vigour-js/app/')
var Element = require('old-vigour-js/app/ui/element')
var Grid = require('../grid')
var Img = require('../../img')
var cases = require('old-vigour-js/browser/cases')

var roll = new Element({
  x: {
    val: 0,
    add: {
      val: Grid.colWidth,
      add: 50,
      multiply: 2
    },
    animation: !cases.chromecast && {
        easing: 'outCubic',
        time: 36
    }
  },
  collection: {
    data: 'seasons',
    element: new Grid({
      itemHeight: Grid.rowHeight,
      title: {
        text: {
          val: 'season',
          add: [ ' ', {
            data: 'number'
          } ]
        }
      },
      w: {
        self: 'itemWidth',
        add: 10,
        multiply: 1
      },
      collection: {
        data: 'episodes'
      },
      model: {
        val: function ( data ) {
          if ( data.episodes) {
            var keys = data.episodes.keys,
              length = keys.length
            if ( length !== this._length) {
              this.w = {
                multiply: Math.ceil(length / 4)
              }
              this._length = length
            }
          }
        }
      }
    })
  }
})

roll.extend({
  pos: function ( val ) {
    var index = val.val | 0
    var children = this.children

    if ( children[ 1 ]) {
      if ( !index) {
        this.x.val = 0
      } else if ( children[ index - 1 ]) {
        this.x = this.x.val - ( children[ index - 1 ].node.getBoundingClientRect().right)
      }
      for ( var i = children.length - 1, makeGone, child; i >= 0; i--) {
        child = children[ i ]
        if ( makeGone ) {
          child.opacity = 0
        } else if ( i !== index) {
          child.opacity = 0.3
        } else {
          child.opacity = 1
          makeGone = true
        }
      }
    }
  }
})

module.exports = new Element({
  css: 'second-show',
  on: {
    show: {
      defer: function ( update ) {
        var caller = this._parent._caller
        caller.data = this.from.val
        update()
      }
    },
    season: {
      defer: function ( update ) {
        var caller = this._parent._caller
        var data = this.from.val

        if ( data ) {
          var seasonnr = data && data._name
          if ( !caller.data) {
            this._parent.show.val = data._parent._parent
          }
          if ( seasonnr !== void 0) caller.roll.pos.val = seasonnr
        }

        update()
      }
    }
  },
  y: {
    val: Grid.rowHeight,
    divide: 2,
    add: 40
  },
  roll: roll.set({
    pos: 0,
    model: {
      field: 'show',
      complete: function () {
        var _this = this
        window.requestAnimationFrame(function () {
          _this.pos.update()
          _this.model = false
        })
      }
    }
  }),
  information: {
    title: {
      text: {
        data: 'show.title'
      }
    },
    holder: {
      h: {
        val: Grid.rowHeight,
        add: 10,
        multiply: 4,
        sub: 10
      },
      w: {
        val: Grid.colWidth,
        add: 10,
        multiply: 2,
        sub: 10
      },
      img: new Img({
        background: {
          data: 'show.img',
          range: 100
        },
        w: {
          parent: 'w'
        },
        h: {
          self: 'w',
          divide: 4 / 3
        }
      }),
      description: {
        text: {
          data: 'show.description'
        }
      }
    }
  }
}).Class

},{"../../img":"/Users/youzi/dev/mtv-play/components/img/index.js","../grid":"/Users/youzi/dev/mtv-play/components/second/grid/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/show/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/second/show/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/shows/index.js":[function(require,module,exports){
require( './style.less' )

var app = require( 'old-vigour-js/app/' )
var Element = require( 'old-vigour-js/app/ui/element' )
var Icon = require( '../../icon' )
var Grid = require( '../grid' )
var display = require( 'old-vigour-js/browser/element/properties/collection/display' )

var grid = new Grid( {
  y: {
    translate: true,
    add: 10
  },
  '!chromecast.y.animation': {
    time: 36,
    easing: 'outCubic'
  },
  itemWidth: {
    val: app.w,
    sub: 70,
    divide: 6,
    clear: true
  },
  itemHeight: {
    self: 'itemWidth',
    divide: 4 / 3,
    clear: true
  },
  user: {},
  collection: {
    data: 'shows',
    options: display,
    element: new Grid.Item( {
      display: 'inline-block',
      img: {
        background: {
          load: function( t ) {
            if( !t.opacity || !t.opacity.val ) t.opacity = 0.3
          }
        }
      },
      model: {
        val: function( data ) {
          var name = data._name
          if( name ) {
            this.name = name
            this.model = false
          }
        }
      }
    } ),
    filter: {
      condition: {
        title: {
          $contains: ''
        }
      },
      sort: 'title'
    }
  },
  model: {
    subscription: {
      $: {
        img: true,
        title: true
      }
    }
  } //tempfix
} )

grid.user.extend( {
  highlight: function( val ) {
    var highlightString = val.val // eg '101.455.799.342.678'
    var grid = this._parent || ( this._parent = this.parent )

    if( highlightString[ 0 ] ) {
      var next = highlightString.split( '.' )
      var old = grid._old || ( grid._old = [] )
      if( next[ 0 ] ) {
        h( old, next, grid, 0.3 )
        h( next, old, grid, 1 )
        m( next[ 0 ], next[ next.length - 1 ], grid )
        grid._old = next
      }
    }
  },
  search: function( val ) {
    var string = val.val
    var grid = this._parent || ( this._parent = this.parent )
    for( var str = '', letter = 0, len = string && string.length; letter < len; letter++ ) {
      str += '\\s*' + string[ letter ]
    }
    str += '\\s*'
    if( grid.filter ) grid.filter.filter = {
      condition: {
        title: {
          $contains: str
        }
      },
      sort: 'title'
    }
  }
} )

grid.user.set( {
  highlight: {
    data: 'highlight'
  },
  search: {
    data: 'search'
  }
} )

var searchbox = new Element( {
  searchicon: new Icon( {
    icon: 'search'
  } ),
  text: {
    data: 'search',
    transform: function( v, cv ) {
      return cv
    }
  }
} )

searchbox.extend( {
  paddingRight: function( val ) {
    this.node.style.paddingRight = val.val + 'px'
  }
} )

module.exports = new Element( {
  css: 'second-shows',
  grid: grid,
  search: {
    searchholder: {
      searchbox: new searchbox.Class( {
        paddingRight: {
          self: 'text',
          transform: function( v, cv ) {
            return cv[ 0 ] ? 20 : 0
          }
        },
        opacity: {
          self: 'text',
          transform: function( v, cv ) {
            return cv[ 0 ] ? 1 : 0
          }
        }
      } )
    }
  }
} ).Class

function h( arr, compare, grid, val ) {
  for( var i = arr.length - 1, name, child; i >= 0; i-- ) {
    if( !~compare.indexOf( name = arr[ i ] ) ) {
      if( child = grid[ name ] ) {
        child.img.opacity = val
      }
    }
  }
}

function m( first, last, grid ) {
  first = grid[ first ]
  last = grid[ last ]
  if( first && last ) {
    var appHeight = app.h.val - 80 //for bar!!
    var lastBottom = last.node.getBoundingClientRect().bottom
    if( lastBottom >= appHeight ) {
      grid.y.val -= lastBottom - appHeight + 20
    } else {
      var firstTop = first.node.getBoundingClientRect().top
      if( firstTop <= 0 ) {
        grid.y.val -= firstTop
      }
    }
    if( grid.y.val > 0 ) grid.y.val = 0
  }
}

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../grid":"/Users/youzi/dev/mtv-play/components/second/grid/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/shows/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/element/properties/collection/display":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/collection/display.js"}],"/Users/youzi/dev/mtv-play/components/second/shows/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/second/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var Switcher = require('old-vigour-js/app/ui/switcher')
var cases = require('old-vigour-js/browser/cases')
var Icon = require('../../icon')
var app = require('old-vigour-js/app')
var user = app.user

module.exports = exports = new Switcher({
  css: 'second-switcher',
  on: {
    $remove: {
      defer: function (update) {
        var caller = this._parent._caller
        if (caller._timer) clearTimeout(caller._timer)
        update()
      }
    },
    page: {
      defer: function (update) { // discover / shows / channels
        var page = this.$userOrigin.val
        var parent = this._parent
        var caller = parent._caller
        var content = parent.content.from
        var pagedata
        var loadedBenchmark
        var on

        if (page) {
          if (page === 'discover') {
            if (exports[page] === void 0) {
              exports[page] = require('../discover')
            }

            var role = user.role.val
            if (!role || role === 3) {
              pagedata = {
                marquee: content.get('discover_marquee_free.list'),
                releases: loadedBenchmark = content.get('discover_row1_free.list'),
                recommended: content.get('discover_row2_free.list'),
                free: content.get('discover_row3_free.list')
              }
            } else {
              pagedata = {
                marquee: content.get('discover_marquee_premium.list'),
                releases: loadedBenchmark = content.get('discover_row1_premium.list'),
                recommended: content.get('discover_row2_premium.list'),
                free: content.get('discover_row3_premium.list')
              }
            }
            
            pagedata.channels = content.get('channels')
            pagedata.watched = parent.watched.from
            pagedata.scroll = parent.scroll.from
            pagedata.carousel = parent.carousel.from

          } else if (page === 'shows') {
            if (exports[page] === void 0) exports[page] = require('../shows')
            pagedata = {
              shows: loadedBenchmark = content.get('shows'),
              search: parent.search.from,
              highlight: parent.highlight.from
            }
          } else if (page === 'channels') {
            if (exports[page] === void 0) exports[page] = require('../channels')
            pagedata = {
              channels: loadedBenchmark = content.get('channels')
            }
          }
          if (loadedBenchmark) {
            caller.transition = {
              element: exports[page],
              $params: {
                data: pagedata,
                on:on
              },
              $options: {
                loader: loadedBenchmark.from
              }
            }
          }

          caller.current = 'page'
        }

        update()
      }
    },
    show: {
      defer: function (update) {
        var showdata = this.$userOrigin.val
        var parent = this._parent
        var caller = parent._caller
        var showname = showdata._name
        var season = parent.season
        var media = parent.media
        var usage = parent.usage
        var seasondata
        var mediadata

        if (!season.from.checkParent('_name', showname)) {
          season.$userOrigin.val = showdata.from.get('seasons.0')
        }

        if (!media.from.checkParent('_name', showname)) {
          media.$userOrigin.val = showdata.from.get('seasons.0.episodes.0')
        }

        mediadata = media.$userOrigin
        seasondata = season.$userOrigin

        caller.transition = {
          element: exports.show || (exports.show = require('../show')),
          $params: {
            on: {
              season: seasondata
            },
            data: {
              show: showdata,
              season: seasondata,
              media: mediadata,
              showusage: usage.from.get(showdata.from._contentPath),
              mediausage: usage.from.get(mediadata.from._contentPath),
              volume: parent.volume
            }
          },
          $options: {
            loader: showdata.from.seasons
          }
        }

        update()
      }
    },
    season: {
      defer: function (update, args) {
        if (args[0]) this._parent.show._update()
        update()
      }
    },
    media: {
      defer: function (update) {
        var parent = this._parent,
          caller = parent._caller,
          mediadata = this.$userOrigin.val

        if (!mediadata) mediadata = this.$userOrigin.val = this.from
        if (mediadata._parent._name === 'episodes') {

          var seasondata = mediadata._parent._parent,
            showdata = seasondata._parent._parent

          caller.transition = {
            element: exports.episode || (exports.episode = require('../episode')),
            $params: {
              data: {
                show: showdata,
                season: seasondata,
                media: mediadata
              }
            },
            $options: {
              loader: mediadata.from
            },
            direction: caller.current === 'page' ? 1 : caller.current === 'media' && -1
          }
        } else if (mediadata._parent._name === 'channels') {
          caller.transition = {
            element: exports.channel || (exports.channel = require('../channel')),
            $params: {
              data: {
                media: mediadata
              }
            },
            $options: {
              loader: mediadata.from
            },
            direction: caller.current !== 'channel' && 1
          }
        }

        update()
      }
    }
  },
  onTransition: function (current, last, direction, options) {
    if (last) {
      this.add(current, last)
      last.opacity = 0
      last.node.pointerEvents = 'none'
      if (this._timer) clearTimeout(this._timer)
      this._timer = setTimeout(function () {
        if (last) last.remove()
        this._timer = null
        if (options.done) options.done()
      }, 200)
    } else {
      this.add(current)
      if (options.done) options.done()
    }
  },
  loader: new Element({
    css: 'second-loader',
    x: {
      translate: true
    },
    loadicon: new Icon({
      icon: 'logo'
    })
  })
}).Class

},{"../../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","../channel":"/Users/youzi/dev/mtv-play/components/second/channel/index.js","../channels":"/Users/youzi/dev/mtv-play/components/second/channels/index.js","../discover":"/Users/youzi/dev/mtv-play/components/second/discover/index.js","../episode":"/Users/youzi/dev/mtv-play/components/second/episode/index.js","../show":"/Users/youzi/dev/mtv-play/components/second/show/index.js","../shows":"/Users/youzi/dev/mtv-play/components/second/shows/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/second/switcher/style.less","old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/app/ui/switcher":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/second/switcher/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/first/discover/style.less"][0].apply(exports,arguments)
},{"../../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var Switcher = require('old-vigour-js/app/ui/switcher')
var cases = require('old-vigour-js/browser/cases')
var app = require('old-vigour-js/app/')

module.exports = exports = new Switcher({
  css: 'app-switcher',
  w: {
    parent: 'w'
  },
  h: {
    parent: 'h'
  },
  on: {
    state: {
      defer: function (update) {
        var parent = this._parent
        var caller = parent._caller
        var state = this.from.val
        var content = parent.content._val
        var favourites = parent.favourites._val
        var navigation = parent.navigation._val
        var receiver = parent.receiver._val
        var highlight = parent.highlight._val
        var overlay = parent.overlay._val
        var watched = parent.watched._val
        var search = parent.search._val
        var usage = parent.usage._val
        var volume = parent.volume._val
        var scroll = parent.scroll._val
        var carousel = parent.carousel._val
        var notification = parent.notification._val
        var popup = parent.popup._val
        var play = parent.play._val
        var loading = parent.loading._val
        var activeClient = parent.activeClient._val
        var videoData
        var seasonData
        var showData
        var Class
        var params
        var reset

        if (state === 'player') {
          if (window.StatusBar && window.StatusBar.hide) window.StatusBar.hide()
        } else {
          if (window.StatusBar && window.StatusBar.show) window.StatusBar.show()
        }

        if (state === 'empty') {
          Class = new Element().Class
        } else if (state === 'first' || (state === 'player' && (cases.desktop || cases.tablet))) {
          // !cases.cast TODTODOTDTODO
          // aparte first maken voor de tv
          Class = exports.first || (exports.first = require('../first'))

          if (cases.tv) {
            // console.log('!!! lezzzgo', navigation.page.val )
            params = {
              switcher: {
                on: {
                  content: content,
                  page: navigation.page,
                  show: navigation.show,
                  media: navigation.media
                }
              }
            }
            params.sidemenu = {
              data: {
                page: navigation.page
              }
            }
          } else {
            params = {
              on: {
                overlay: overlay,
                popup: popup,
                notification: notification,
                loading: loading,
                state: this.from
              },
              section: {
                on: // stuff for miniplayer maybe move elsewhere?
                {
                  msmedia: receiver.media,
                  usage: usage,
                  play: receiver.playing,
                  volume: receiver.volume
                },
                topbar: {
                  on: {
                    page: navigation.page,
                    show: navigation.show,
                    media: navigation.media
                  }
                },
                switcher: {
                  on: {
                    content: content,
                    favourites: favourites,
                    page: navigation.page,
                    show: navigation.show,
                    season: navigation.season,
                    media: navigation.media,
                    highlight: highlight,
                    scroll: scroll,
                    search: search,
                    usage: usage,
                    volume: volume,
                    watched: watched,
                    carousel: carousel,
                    play: play,
                    ms: receiver
                  }
                }
              }
            }

            if (cases.phone) {
              params.section.topmenu = {
                data: {
                  page: navigation.page
                }
              }
            } else {
              params.sidemenu = {
                data: {
                  page: navigation.page
                }
              }
            }
          }
        } else if (state === 'second') {
          Class = exports[state] || (exports[state] = require('../second'))

          params = {
            switcher: {
              on: {
                content: parent.content,
                page: navigation.page,
                show: navigation.show,
                season: navigation.season,
                channel: navigation.channel,
                media: navigation.media,
                highlight: highlight,
                scroll: scroll,
                search: search,
                usage: usage,
                watched: watched,
                carousel: carousel
              }
            },
            bar: {
              data: {
                activeClient: activeClient
              }
            }
          }
        } else if (state === 'player') {
          Class = exports[state] || (exports[state] = require('../player'))

          videoData = this._val.video ? this._val.video.from : navigation.media.from

          if (videoData._parent._name === 'episodes') {
            seasonData = videoData._parent._parent
            showData = seasonData._parent._parent
            params = {
              data: {
                show: showData,
                season: seasonData,
                media: videoData, // navigation.media
                mediausage: usage.from.get(videoData._contentPath),
                volume: volume
              }
            }
          } else if (videoData._parent._name === 'channels') {
            params = {
              data: {
                media: videoData, // navigation.media
                mediausage: usage.from.get(videoData._contentPath),
                volume: volume
              }
            }
          }
        }

        if (Class) {
          caller.transition = {
            element: Class,
            $params: params,
            $options: {
              force: reset
            }
          }
          app.user.updateNavigation()
        }

        update()
      }
    }
  },
  onTransition: function (current, last) {
    if (last) last.remove()
    this.add(current)
  }
}).Class

},{"../first":"/Users/youzi/dev/mtv-play/components/first/index.js","../player":"/Users/youzi/dev/mtv-play/components/player/index.js","../second":"/Users/youzi/dev/mtv-play/components/second/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/switcher/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/app/ui/switcher":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/components/switcher/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/components/text/index.js":[function(require,module,exports){
var Element = require('old-vigour-js/app/ui/element')
var dictionary = require('old-vigour-js/app/dictionary')
var seasonText = dictionary.get('text.season')

var seasonsText = dictionary.get('text.seasons')
var episodeText = dictionary.get('text.episode')
var episodesText = dictionary.get('text.episodes')

exports.Title = new Element({
  text: {
    data: 'title'
  }
}).Class

exports.Subtitle = new Element({
  text: {
    data: {
      val: function (data) {
        if (data) {
          data = data.from
        }
        if (!data) {
          return ''
        }
        if (data.subtitle) {
          return data.subtitle.val || ''
        }

        if (data.number) {
          var seasondata = data._parent._parent
          var seasonnr = seasondata.number ? seasondata.number.val : (data.season && data.season.val) || ((seasondata._name | 0) + 1)

          if (data._parent._name === 'seasons') {
            return seasonText.val + ' ' + data.number.val
          }
          if (!isNaN(seasonnr)) {
            return seasonText.val + ' ' + seasonnr + ' ' + episodeText.val + ' ' + data.number.val
          }
        }

        if (data.seasonCount && data.episodeCount) {
          var seasoncnt = data.seasonCount.val
          var seasons = data.seasonCount.val > 1 ? seasonsText.val : seasonText.val
          var episodecnt = data.episodeCount.val
          var episodes = data.episodeCount.val > 1 ? episodesText.val : episodeText.val

          return seasoncnt + ' ' + seasons + ' ' + episodecnt + ' ' + episodes || ''
        }
        return ''
      },
      listen: ['seasonCount', 'episodeCount', 'subtitle', 'number', 'season'] // <---------- add on specific spots! THIS IS WRONG
    },
    listen: dictionary
  }
}).Class

exports.TitleSubtitle = new Element({
  title: new exports.Title(),
  subtitle: new exports.Subtitle()
}).Class

exports.Description = new Element({
  text: {
    data: 'media.description',
    default: {
      dictionary: 'text.noDescription'
    }
  }
}).Class

exports.highlight = function (string) {
  var firstletter = string.charAt(0),
    rest = string.slice(1),
    str = firstletter !== 'i' ? firstletter.toUpperCase() + rest : firstletter + rest.charAt(0).toUpperCase() + rest.slice(1)
  return '<span class="text-highlight">' + str + '</span>'
}

},{"old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/components/text/input.js":[function(require,module,exports){
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var Icon = require('../icon')
var app = require('old-vigour-js/app/')
var events = require('old-vigour-js/browser/events')
var cases = require('old-vigour-js/browser/cases')
var offset = require('old-vigour-js/browser/events/offset')
var ua = require('old-vigour-js/browser/ua')
var item = new Element({
  css: 'ui-item ui-input',
  lefticon: new Icon({
    icon: 'email'
  })
})
var firefox = ua.browser === 'firefox'

// --------------- extensions ---------------

// constants
item.extend({
  input: function (val) {
    var v = val.val
    var type
    var field = val && val.text && val.text.val

    if (v) {
      type = {
        user: {
          text: field || 'text.username',
          // msg: 'text.account.invalid.email'
          icon: 'profile'
        },
        email: {
          text: field || 'text.email',
          msg: 'text.account.invalid.email'
        },
        password: {
          text: field || 'text.password',
          msg: 'text.invalid.password',
          icon: 'locked'
        },
        phone: {
          text: 'text.cellphone',
          msg: 'text.invalid.phoneWord'
        }
      }

      this.txt.text = type[v] ? {
        dictionary: type[v].text
      } : v

      this.lefticon.icon = type[v].icon || v
    }

    if (v === 'phone') {
      this.txt.attr = {
        type: 'tel',
        pattern: '\d*'
      }
    } else if (v === 'age') {
      this.txt.attr = {
        type: 'tel',
        pattern: '\d*'
      }
    }
  }
}, {
  name: 'key',
  get: function () {
    return (this.input && this.input.val) || this.txt.attr && this.txt.attr.type.val
  }
// }, {
//   name: 'msg',
//   get: function () {
//     return map[this.key].msg
//   }
}, {
  name: 'val',
  get: function () {
    return this.txt.node.value
  }
})

// --------------- input ----------------

module.exports = exports = item.set({
  txt: {
    node: 'input',
    attr: {
      type: 'text',
      autocapitalize: 'off'
    },
    text: 'search',
    css: 'inactive',
    events: {
      focusin: focusIn,
      focusout: focusOut,
      keyup: firefox && focusIn,
      input: verify,
      move: function (e) {
        e.preventDefault()
      },
      click: function (e) {
        if (e) e.preventDefault()
        app.blockResize = true

        this.node.focus()
        if (firefox) focusIn.call(this)
      },
      down: function (e) {
        if (events.click.block) return
        var t = this
        var holder = t.parent.input && t.parent.input.holder
        if (cases.touch && holder && holder.val) correctY(t, holder.val)
      }
    }
  },
  events: {
    out: function (e) {
      if (e.target.tagName !== 'INPUT') this.txt.node.blur()
    }
  }
}).Class

// --------------- form ----------------

events.confirm = {
  val: {
    up: function (e, method, val) {
      e.preventDefault()
      method.call(this, e, val)
    }
  }
}

exports.Form = new Element({
  node: 'form',
  submitfix: {
    node: 'input',
    'attr.type': 'submit'
  },
  events: {
    submit: function (e) {
      e.preventDefault()
      if ((!cases.touch || this.fDown) && this.done) {
        this.done()
      }
    },
    down: function (e) {
      this.fDown = true
    }
  }
}).Class

exports.Form.base.extend({
  verify: function () {}
})

// --------------- functions ----------------

function correctY (input, holder) {
  holder.focused = input
  if (!holder.corrected) holder.corrected = app.h.val

  var y = offset.y(input)
  var h = holder.corrected - 380

  if (y > h) {
    if (!cases.ios) holder.focusing = true
    if (!holder.y.animation && !cases.ios) {
      holder.y = {
        animation: {
          time: 10,
          easing: 'outCubic',
          complete: function () {
            this.focusing = false
          }
        }
      }
    }
    holder.y = {
      sub: y - h - 10
    }
  }
}

function focusIn (e) {
  var node = this.node

  document.body.scrollTop = 0
  window.requestAnimationFrame(function () {
    document.body.scrollTop = 0
  })

  var input = this.parent.input

  app.blockResize = true

  this.parent.css = 'ui-item ui-input active focus'

  if (node.value === this.text.val) node.value = ''
  if (input && input.val === 'password') {
    node.setAttribute('type', 'password')
    node.setAttribute('autocapitalize', 'off')
  }

  if (firefox) {
    var _this = this
    var listener = function () {
      focusOut.call(_this)
      node.removeEventListener('blur', listener, true)
    }
    node.addEventListener('blur', listener, true)
  }
}

function focusOut () {
  if (this.focusing) return

  window.scrollTo(0, 0)

  app.blockResize = false

  var input = this.parent.input
  var holder

  if (cases.touch && input && input.holder) {
    holder = input.holder.val
    if (holder && !holder.focusing) {
      holder.y = {
        sub: 0
      }
    }
  }

  if (this.node.value === '') {
    this.node.value = this.text.val
    this.parent.css = 'ui-item ui-input'
    if (input && input.val === 'password') {
      this.node.setAttribute('type', 'text')
    }
  } else {
    this.parent.css = 'ui-item ui-input active'
  }
}

function verify (e) {
  var type = this.node.type
  var parent = this.parent
  var val = this.node.value
  var input

  if (type !== 'text' || parent.input) {
    input = parent.input.val
    if (input === 'password') {
      parent.verified = val.length > 3
    } else if (type === 'email' || input === 'email') {
      parent.verified = /^[a-zA-Z0-9._%+-]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,4}$/.test(val)
      this.node.value = val.trim()
    } else if (parent.input && parent.input.val === 'phone') {
      parent.verified = /^(\d){6,12}$/.test(val)
    } else if (parent.input && parent.input.verify && (parent.input.verify.__t === 1)) {
      parent.verified = val > parent.input.verify[0] && val < parent.input.verify[1]
    } else {
      parent.verified = val.length > 2
    }

    if (parent.input && parent.input.keyup && typeof parent.input.keyup._val === 'function') {
      parent.input.keyup._val.call(parent, parent.verified)
    }

    var form = this._form !== false && (this._form || (this._form = this.checkParent('verify')) || false)
    var verify = form && form.verify
    var notVerified
    var righticon
    var i

    if (verify) {
      righticon = this._righticon || (this._righticon = this.checkParent('topbar.holder.righticon', true))

      for (i = verify.length - 1; i >= 0; i--) {
        if (!form[verify[i]._val].verified) {
          notVerified = true
          form.verificationError = verify[i]
        }
      }
      righticon.css = notVerified ? 'pointer' : 'pointer verified'
      righticon.verified = !notVerified
      form.verified = !notVerified
    }
  }
}

},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/text/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js","old-vigour-js/browser/events/offset":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/offset.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js"}],"/Users/youzi/dev/mtv-play/components/text/search.js":[function(require,module,exports){
require('./style.less')

var Element = require('old-vigour-js/app/ui/element')
var Icon = require('../icon')
var dictionary = require('old-vigour-js/app/dictionary')
var events = require('old-vigour-js/browser/events')
var cases = require('old-vigour-js/browser/cases')
var app = require('old-vigour-js/app/')

module.exports = new Element({
  node: 'form',
  css: 'ui-search',
  name: 'search',
  w: {
    val: 210,
    touch: {
      val: app.w,
      sub: 30
    }
  },
  icon: new Icon({
    icon: 'search',
    h: 30,
    placeholder: {
      'text.dictionary': 'text.search'
    }
  }),
  field: {
    node: 'input',
    attr: {
      type: 'text',
      name: 'search',
      listen: dictionary.get('text.search'),
      placeholder: dictionary.get('text.search')
    },
    text: {
      data: function (data) {
        if (data) {
          var val = data.search.val

          if (!this.first && !val) {} else {
            this.first = true
          }

          if (this.first) {
            input(val, this.parent.parent)
            if (val === void 0 || val === false) {
              exit(this.parent)
            } else if (!this.parent.fromDown) {
              focus.call(this.parent, false, false, true)
            } else {
              this.parent.fromDown = false
            }
          }
          return val || ''
        }
        return ''
      }
    },
    events: {
      keydown: function (e) {
        if (e.keyCode == 13) e.preventDefault()
      },
      keyup: function (e) {
        if (e.keyCode !== 9) {
          var srch = this.node.value.length ? this.node.value.trim() : ''
          this.data.search.$userOrigin = srch
        }
      }
    }
  },
  clear: new Icon({
    node: 'form',
    icon: 'empty',
    events: {
      down: function (e) {
        e.prevent = true
        this.parent.fromDown = true
        this.parent.field.data.search.$userOrigin = ''

        if (!cases.touch) exit(this.parent, true)
        else {
          var val = '',
            field = this.parent.field.node

          field.value = val
          focus.call(this.parent)
          input(val, this.parent.parent)
        }
      }
    }
  }),
  cancel: {
    'text.dictionary': 'text.cancel',
    events: {
      down: function (e) {
        e.prevent = true
        exit(this.parent, true)
        this.parent.field.data.search.$userOrigin = ''
      }
    }
  },
  events: {
    click: focus,
    out: function (e) {
      if (this._active) exit(this)
    }
  }
})

function opacity(list, val) {
  if (cases.touch) {
    events.click.block = val === 1 ? false : true
    list.items.opacity = val
    list.favos.opacity = val
  }
}

function input(val, list) {

  if (val && val.__t === 2) {
    throw new Error('object in search')
  }

  val = val && val.trim() || ''
  if (val.length) {
    list.favos.display = 'none'
    list.search.clear.icon = 'closesmall'
  } else {

    list.favos.display = 'block' //ff die transform repareren

    list.search.clear.icon = 'empty'

    var srch = val ? val.trim() : ''
    list.search.field.data.search.$userOrigin = srch
  }
  var str = '';
  for (var letter = 0, len = val.length; letter < len; letter++) {
    var lett = val[letter]
    if (lett === '$' || lett.toUpperCase() === 'S') lett = '(\\$|s)'
    str += '\\s*' + lett
  }
  str += '\\s*'

  if (list.items.filter) list.items.filter.filter = {
    condition: {
      title: {
        $contains: str
      }
    },
    sort: 'title'
  }

}

function focus(e, events, fromModel) {
  this.css = 'ui-search focus'
  if (!fromModel) {
    app.blockResize = true
    opacity(this.parent, 0.5)
    this.field.node.focus()
    this._active = true
  }
}

function exit(form, clear) {
  var val = clear ? '' : form.field.node.value.trim()

  if (!val.length) {
    form.css = 'ui-search'
    form.clear.icon = 'empty'
    form.field.node.value = val
    input(val, form.parent)
  }

  opacity(form.parent, 1)
  form._active = false
  app.blockResize = false
}
},{"../icon":"/Users/youzi/dev/mtv-play/components/icon/index.js","./style.less":"/Users/youzi/dev/mtv-play/components/text/style.less","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/app/dictionary":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js","old-vigour-js/app/ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js"}],"/Users/youzi/dev/mtv-play/components/text/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/components/ad/style.less"][0].apply(exports,arguments)
},{"../../common.less":"/Users/youzi/dev/mtv-play/common.less"}],"/Users/youzi/dev/mtv-play/config.js":[function(require,module,exports){
window.name = 'mtvplay'

// window.package = require('./package.json')
// console.log('wtf...', window.package)

module.exports = exports = require( 'old-vigour-js/util/config' )
              .inject
              ( { 'repository.branch': 'branches' }
              , require( 'old-vigour-js/util/config/ua' )
              )

exports( function( result ) {
  for(var key in result) {
    // console.log('\n', i, result[i])
    exports[key] = result[key] 
  }
  exports.parsed = true

}, false, window.package, true )


},{"old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/util/config/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/ua.js"}],"/Users/youzi/dev/mtv-play/index.js":[function(require,module,exports){
window.package = require('package.json')

// override for testing
// window.__ua__ = { device:'tv' }

var config = require('./config'),
  remote

if (config.development && config.development.button) {
  remote = require('old-vigour-js/util/debug')
    .native(false, false, function(url) {}, 'build')
}

if (!remote) {
  var cases = require('old-vigour-js/browser/cases'),
    ua = require('old-vigour-js/browser/ua')
    // entry points

  if (~window.location.href.indexOf('$tv')) {
    cases.tv = true
    ua.device = 'tv'
  }

  if (~window.location.href.indexOf('$chromecast')) {
    cases.chromecast = true
    ua.device = 'chromecast'
  }

  if (ua.device === 'tv' && ua.platform === 'linux') {
    ua.platform = 'lg'
  }

  require('old-vigour-js/app/')

  if (cases.tv || cases.chromecast) {
    cases.$iplogin = true
  }

  if (cases.chromecast) {
    require('./platform/cast.js')
  } else if (cases.tv) {
    require('./platform/tv.js')
  } else {
    cases.phoneBrowser = ua.device === 'phone' && !(cases.native || cases.$isIosFull)
    require('./platform/all.js')
  }
}

},{"./config":"/Users/youzi/dev/mtv-play/config.js","./platform/all.js":"/Users/youzi/dev/mtv-play/platform/all.js","./platform/cast.js":"/Users/youzi/dev/mtv-play/platform/cast.js","./platform/tv.js":"/Users/youzi/dev/mtv-play/platform/tv.js","old-vigour-js/app/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/util/debug":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/debug/index.js","package.json":"package.json"}],"/Users/youzi/dev/mtv-play/node_modules/after/index.js":[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],"/Users/youzi/dev/mtv-play/node_modules/arraybuffer.slice/index.js":[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],"/Users/youzi/dev/mtv-play/node_modules/asap/asap.js":[function(require,module,exports){
(function (process){

// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// linked list of tasks (single, with head node)
var head = {task: void 0, next: null};
var tail = head;
var flushing = false;
var requestFlush = void 0;
var isNodeJS = false;

function flush() {
    /* jshint loopfunc: true */

    while (head.next) {
        head = head.next;
        var task = head.task;
        head.task = void 0;
        var domain = head.domain;

        if (domain) {
            head.domain = void 0;
            domain.enter();
        }

        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function() {
                   throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    flushing = false;
}

if (typeof process !== "undefined" && process.nextTick) {
    // Node.js before 0.9. Note that some fake-Node environments, like the
    // Mocha test runner, introduce a `process` global without a `nextTick`.
    isNodeJS = true;

    requestFlush = function () {
        process.nextTick(flush);
    };

} else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        requestFlush = setImmediate.bind(window, flush);
    } else {
        requestFlush = function () {
            setImmediate(flush);
        };
    }

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    requestFlush = function () {
        channel.port2.postMessage(0);
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
    };

    if (!flushing) {
        flushing = true;
        requestFlush();
    }
};

module.exports = asap;


}).call(this,require('_process'))
},{"_process":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/process/browser.js"}],"/Users/youzi/dev/mtv-play/node_modules/autolinker/dist/Autolinker.js":[function(require,module,exports){
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define([], function () {
      return (root['Autolinker'] = factory());
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    root['Autolinker'] = factory();
  }
}(this, function () {

/*!
 * Autolinker.js
 * 0.18.3
 *
 * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/gregjacobs/Autolinker.js
 */
/**
 * @class Autolinker
 * @extends Object
 *
 * Utility class used to process a given string of text, and wrap the matches in
 * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
 *
 * Any of the configuration options may be provided in an Object (map) provided
 * to the Autolinker constructor, which will configure how the {@link #link link()}
 * method will process the links.
 *
 * For example:
 *
 *     var autolinker = new Autolinker( {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *
 *     var html = autolinker.link( "Joe went to www.yahoo.com" );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * The {@link #static-link static link()} method may also be used to inline options into a single call, which may
 * be more convenient for one-off uses. For example:
 *
 *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * ## Custom Replacements of Links
 *
 * If the configuration options do not provide enough flexibility, a {@link #replaceFn}
 * may be provided to fully customize the output of Autolinker. This function is
 * called once for each URL/Email/Phone#/Twitter Handle/Hashtag match that is
 * encountered.
 *
 * For example:
 *
 *     var input = "...";  // string with URLs, Email Addresses, Phone #s, Twitter Handles, and Hashtags
 *
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *
 *             switch( match.getType() ) {
 *                 case 'url' :
 *                     console.log( "url: ", match.getUrl() );
 *
 *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
 *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
 *                         tag.setAttr( 'rel', 'nofollow' );
 *                         tag.addClass( 'external-link' );
 *
 *                         return tag;
 *
 *                     } else {
 *                         return true;  // let Autolinker perform its normal anchor tag replacement
 *                     }
 *
 *                 case 'email' :
 *                     var email = match.getEmail();
 *                     console.log( "email: ", email );
 *
 *                     if( email === "my@own.address" ) {
 *                         return false;  // don't auto-link this particular email address; leave as-is
 *                     } else {
 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
 *                     }
 *
 *                 case 'phone' :
 *                     var phoneNumber = match.getPhoneNumber();
 *                     console.log( phoneNumber );
 *
 *                     return '<a href="http://newplace.to.link.phone.numbers.to/">' + phoneNumber + '</a>';
 *
 *                 case 'twitter' :
 *                     var twitterHandle = match.getTwitterHandle();
 *                     console.log( twitterHandle );
 *
 *                     return '<a href="http://newplace.to.link.twitter.handles.to/">' + twitterHandle + '</a>';
 *
 *                 case 'hashtag' :
 *                     var hashtag = match.getHashtag();
 *                     console.log( hashtag );
 *
 *                     return '<a href="http://newplace.to.link.hashtag.handles.to/">' + hashtag + '</a>';
 *             }
 *         }
 *     } );
 *
 *
 * The function may return the following values:
 *
 * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.
 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
 * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for
 *   the match.
 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.
 *
 * @constructor
 * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).
 */
var Autolinker = function( cfg ) {
	Autolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.

	// Validate the value of the `hashtag` cfg.
	var hashtag = this.hashtag;
	if( hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' && hashtag !== 'instagram' ) {
		throw new Error( "invalid `hashtag` cfg - see docs" );
	}
};

Autolinker.prototype = {
	constructor : Autolinker,  // fix constructor property

	/**
	 * @cfg {Boolean} urls
	 *
	 * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.
	 */
	urls : true,

	/**
	 * @cfg {Boolean} email
	 *
	 * `true` if email addresses should be automatically linked, `false` if they should not be.
	 */
	email : true,

	/**
	 * @cfg {Boolean} twitter
	 *
	 * `true` if Twitter handles ("@example") should be automatically linked, `false` if they should not be.
	 */
	twitter : true,

	/**
	 * @cfg {Boolean} phone
	 *
	 * `true` if Phone numbers ("(555)555-5555") should be automatically linked, `false` if they should not be.
	 */
	phone: true,

	/**
	 * @cfg {Boolean/String} hashtag
	 *
	 * A string for the service name to have hashtags (ex: "#myHashtag")
	 * auto-linked to. The currently-supported values are:
	 *
	 * - 'twitter'
	 * - 'facebook'
	 * - 'instagram'
	 *
	 * Pass `false` to skip auto-linking of hashtags.
	 */
	hashtag : false,

	/**
	 * @cfg {Boolean} newWindow
	 *
	 * `true` if the links should open in a new window, `false` otherwise.
	 */
	newWindow : true,

	/**
	 * @cfg {Boolean} stripPrefix
	 *
	 * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped
	 * from the beginning of URL links' text, `false` otherwise.
	 */
	stripPrefix : true,

	/**
	 * @cfg {Number} truncate
	 *
	 * A number for how many characters long matched text should be truncated to inside the text of
	 * a link. If the matched text is over this number of characters, it will be truncated to this length by
	 * adding a two period ellipsis ('..') to the end of the string.
	 *
	 * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look
	 * something like this: 'yahoo.com/some/long/pat..'
	 */
	truncate : undefined,

	/**
	 * @cfg {String} className
	 *
	 * A CSS class name to add to the generated links. This class will be added to all links, as well as this class
	 * plus match suffixes for styling url/email/phone/twitter/hashtag links differently.
	 *
	 * For example, if this config is provided as "myLink", then:
	 *
	 * - URL links will have the CSS classes: "myLink myLink-url"
	 * - Email links will have the CSS classes: "myLink myLink-email", and
	 * - Twitter links will have the CSS classes: "myLink myLink-twitter"
	 * - Phone links will have the CSS classes: "myLink myLink-phone"
	 * - Hashtag links will have the CSS classes: "myLink myLink-hashtag"
	 */
	className : "",

	/**
	 * @cfg {Function} replaceFn
	 *
	 * A function to individually process each match found in the input string.
	 *
	 * See the class's description for usage.
	 *
	 * This function is called with the following parameters:
	 *
	 * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such
	 *   as the instance's {@link #getTagBuilder tag builder}).
	 * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the
	 *   match that the `replaceFn` is currently processing. See {@link Autolinker.match.Match} subclasses for details.
	 */


	/**
	 * @private
	 * @property {Autolinker.htmlParser.HtmlParser} htmlParser
	 *
	 * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated
	 * in the {@link #getHtmlParser} method.
	 */
	htmlParser : undefined,

	/**
	 * @private
	 * @property {Autolinker.matchParser.MatchParser} matchParser
	 *
	 * The MatchParser instance used to find matches in the text nodes of an input string passed to
	 * {@link #link}. This is lazily instantiated in the {@link #getMatchParser} method.
	 */
	matchParser : undefined,

	/**
	 * @private
	 * @property {Autolinker.AnchorTagBuilder} tagBuilder
	 *
	 * The AnchorTagBuilder instance used to build match replacement anchor tags. Note: this is lazily instantiated
	 * in the {@link #getTagBuilder} method.
	 */
	tagBuilder : undefined,

	/**
	 * Automatically links URLs, Email addresses, Phone numbers, Twitter
	 * handles, and Hashtags found in the given chunk of HTML. Does not link
	 * URLs found within HTML tags.
	 *
	 * For instance, if given the text: `You should go to http://www.yahoo.com`,
	 * then the result will be `You should go to
	 * &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 *
	 * This method finds the text around any HTML elements in the input
	 * `textOrHtml`, which will be the text that is processed. Any original HTML
	 * elements will be left as-is, as well as the text that is already wrapped
	 * in anchor (&lt;a&gt;) tags.
	 *
	 * @param {String} textOrHtml The HTML or text to autolink matches within
	 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
	 *   {@link #twitter}, and {@link #hashtag} options are enabled).
	 * @return {String} The HTML, with matches automatically linked.
	 */
	link : function( textOrHtml ) {
		if( !textOrHtml ) { return ""; }  // handle `null` and `undefined`

		var htmlParser = this.getHtmlParser(),
		    htmlNodes = htmlParser.parse( textOrHtml ),
		    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have
		    resultHtml = [];

		for( var i = 0, len = htmlNodes.length; i < len; i++ ) {
			var node = htmlNodes[ i ],
			    nodeType = node.getType(),
			    nodeText = node.getText();

			if( nodeType === 'element' ) {
				// Process HTML nodes in the input `textOrHtml`
				if( node.getTagName() === 'a' ) {
					if( !node.isClosing() ) {  // it's the start <a> tag
						anchorTagStackCount++;
					} else {   // it's the end </a> tag
						anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
					}
				}
				resultHtml.push( nodeText );  // now add the text of the tag itself verbatim

			} else if( nodeType === 'entity' || nodeType === 'comment' ) {
				resultHtml.push( nodeText );  // append HTML entity nodes (such as '&nbsp;') or HTML comments (such as '<!-- Comment -->') verbatim

			} else {
				// Process text nodes in the input `textOrHtml`
				if( anchorTagStackCount === 0 ) {
					// If we're not within an <a> tag, process the text node to linkify
					var linkifiedStr = this.linkifyStr( nodeText );
					resultHtml.push( linkifiedStr );

				} else {
					// `text` is within an <a> tag, simply append the text - we do not want to autolink anything
					// already within an <a>...</a> tag
					resultHtml.push( nodeText );
				}
			}
		}

		return resultHtml.join( "" );
	},

	/**
	 * Process the text that lies in between HTML tags, performing the anchor
	 * tag replacements for the matches, and returns the string with the
	 * replacements made.
	 *
	 * This method does the actual wrapping of matches with anchor tags.
	 *
	 * @private
	 * @param {String} str The string of text to auto-link.
	 * @return {String} The text with anchor tags auto-filled.
	 */
	linkifyStr : function( str ) {
		return this.getMatchParser().replace( str, this.createMatchReturnVal, this );
	},


	/**
	 * Creates the return string value for a given match in the input string,
	 * for the {@link #linkifyStr} method.
	 *
	 * This method handles the {@link #replaceFn}, if one was provided.
	 *
	 * @private
	 * @param {Autolinker.match.Match} match The Match object that represents the match.
	 * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but
	 *   may be the `matchStr` itself if the match is not to be replaced.
	 */
	createMatchReturnVal : function( match ) {
		// Handle a custom `replaceFn` being provided
		var replaceFnResult;
		if( this.replaceFn ) {
			replaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg
		}

		if( typeof replaceFnResult === 'string' ) {
			return replaceFnResult;  // `replaceFn` returned a string, use that

		} else if( replaceFnResult === false ) {
			return match.getMatchedText();  // no replacement for the match

		} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {
			return replaceFnResult.toAnchorString();

		} else {  // replaceFnResult === true, or no/unknown return value from function
			// Perform Autolinker's default anchor tag generation
			var tagBuilder = this.getTagBuilder(),
			    anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance

			return anchorTag.toAnchorString();
		}
	},


	/**
	 * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.htmlParser.HtmlParser}
	 */
	getHtmlParser : function() {
		var htmlParser = this.htmlParser;

		if( !htmlParser ) {
			htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();
		}

		return htmlParser;
	},


	/**
	 * Lazily instantiates and returns the {@link #matchParser} instance for this Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.matchParser.MatchParser}
	 */
	getMatchParser : function() {
		var matchParser = this.matchParser;

		if( !matchParser ) {
			matchParser = this.matchParser = new Autolinker.matchParser.MatchParser( {
				urls        : this.urls,
				email       : this.email,
				twitter     : this.twitter,
				phone       : this.phone,
				hashtag     : this.hashtag,
				stripPrefix : this.stripPrefix
			} );
		}

		return matchParser;
	},


	/**
	 * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
	 * if it does not yet exist.
	 *
	 * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that
	 * Autolinker would normally generate, and then allow for modifications before returning it. For example:
	 *
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *
	 *             return tag;
	 *         }
	 *     } );
	 *
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 *
	 * @return {Autolinker.AnchorTagBuilder}
	 */
	getTagBuilder : function() {
		var tagBuilder = this.tagBuilder;

		if( !tagBuilder ) {
			tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {
				newWindow   : this.newWindow,
				truncate    : this.truncate,
				className   : this.className
			} );
		}

		return tagBuilder;
	}

};


/**
 * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,
 * and Hashtags found in the given chunk of HTML. Does not link URLs found
 * within HTML tags.
 *
 * For instance, if given the text: `You should go to http://www.yahoo.com`,
 * then the result will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
 *
 * Example:
 *
 *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
 *     // Produces: "Go to <a href="http://google.com">google.com</a>"
 *
 * @static
 * @param {String} textOrHtml The HTML or text to find matches within (depending
 *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #twitter},
 *   and {@link #hashtag} options are enabled).
 * @param {Object} [options] Any of the configuration options for the Autolinker
 *   class, specified in an Object (map). See the class description for an
 *   example call.
 * @return {String} The HTML text, with matches automatically linked.
 */
Autolinker.link = function( textOrHtml, options ) {
	var autolinker = new Autolinker( options );
	return autolinker.link( textOrHtml );
};


// Autolinker Namespaces
Autolinker.match = {};
Autolinker.htmlParser = {};
Autolinker.matchParser = {};

/*global Autolinker */
/*jshint eqnull:true, boss:true */
/**
 * @class Autolinker.Util
 * @singleton
 *
 * A few utility methods for Autolinker.
 */
Autolinker.Util = {

	/**
	 * @property {Function} abstractMethod
	 *
	 * A function object which represents an abstract method.
	 */
	abstractMethod : function() { throw "abstract"; },


	/**
	 * @private
	 * @property {RegExp} trimRegex
	 *
	 * The regular expression used to trim the leading and trailing whitespace
	 * from a string.
	 */
	trimRegex : /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`.
	 *
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	assign : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) ) {
				dest[ prop ] = src[ prop ];
			}
		}

		return dest;
	},


	/**
	 * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
	 *
	 * @param {Function} superclass The constructor function for the superclass.
	 * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
	 *   special property `constructor`, which will be used as the new subclass's constructor function.
	 * @return {Function} The new subclass function.
	 */
	extend : function( superclass, protoProps ) {
		var superclassProto = superclass.prototype;

		var F = function() {};
		F.prototype = superclassProto;

		var subclass;
		if( protoProps.hasOwnProperty( 'constructor' ) ) {
			subclass = protoProps.constructor;
		} else {
			subclass = function() { superclassProto.constructor.apply( this, arguments ); };
		}

		var subclassProto = subclass.prototype = new F();  // set up prototype chain
		subclassProto.constructor = subclass;  // fix constructor property
		subclassProto.superclass = superclassProto;

		delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
		Autolinker.Util.assign( subclassProto, protoProps );

		return subclass;
	},


	/**
	 * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
	 * end of the string (by default, two periods: '..'). If the `str` length does not exceed
	 * `len`, the string will be returned unchanged.
	 *
	 * @param {String} str The string to truncate and add an ellipsis to.
	 * @param {Number} truncateLen The length to truncate the string at.
	 * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`
	 *   when truncated. Defaults to '..'
	 */
	ellipsis : function( str, truncateLen, ellipsisChars ) {
		if( str.length > truncateLen ) {
			ellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;
			str = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;
		}
		return str;
	},


	/**
	 * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
	 *
	 * @param {Array} arr The array to find an element of.
	 * @param {*} element The element to find in the array, and return the index of.
	 * @return {Number} The index of the `element`, or -1 if it was not found.
	 */
	indexOf : function( arr, element ) {
		if( Array.prototype.indexOf ) {
			return arr.indexOf( element );

		} else {
			for( var i = 0, len = arr.length; i < len; i++ ) {
				if( arr[ i ] === element ) return i;
			}
			return -1;
		}
	},



	/**
	 * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
	 * with a regular expression that contains capturing parenthesis.
	 *
	 * For example:
	 *
	 *     // Modern browsers:
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
	 *
	 *     // Old IE (including IE8):
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
	 *
	 * This method emulates the functionality of modern browsers for the old IE case.
	 *
	 * @param {String} str The string to split.
	 * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
	 *   character(s) will be spliced into the array, as in the "modern browsers" example in the
	 *   description of this method.
	 *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
	 *   Note #2: for simplicity's sake, the regular expression does not need
	 *   to contain capturing parenthesis - it will be assumed that any match has them.
	 * @return {String[]} The split array of strings, with the splitting character(s) included.
	 */
	splitAndCapture : function( str, splitRegex ) {
		if( !splitRegex.global ) throw new Error( "`splitRegex` must have the 'g' flag set" );

		var result = [],
		    lastIdx = 0,
		    match;

		while( match = splitRegex.exec( str ) ) {
			result.push( str.substring( lastIdx, match.index ) );
			result.push( match[ 0 ] );  // push the splitting char(s)

			lastIdx = match.index + match[ 0 ].length;
		}
		result.push( str.substring( lastIdx ) );

		return result;
	},


	/**
	 * Trims the leading and trailing whitespace from a string.
	 *
	 * @param {String} str The string to trim.
	 * @return {String}
	 */
	trim : function( str ) {
		return str.replace( this.trimRegex, '' );
	}

};
/*global Autolinker */
/*jshint boss:true */
/**
 * @class Autolinker.HtmlTag
 * @extends Object
 *
 * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
 *
 * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
 * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
 *
 * ## Examples
 *
 * Example instantiation:
 *
 *     var tag = new Autolinker.HtmlTag( {
 *         tagName : 'a',
 *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
 *         innerHtml : 'Google'
 *     } );
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *     // Individual accessor methods
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *
 * Using mutator methods (which may be used in combination with instantiation config properties):
 *
 *     var tag = new Autolinker.HtmlTag();
 *     tag.setTagName( 'a' );
 *     tag.setAttr( 'href', 'http://google.com' );
 *     tag.addClass( 'external-link' );
 *     tag.setInnerHtml( 'Google' );
 *
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *
 * ## Example use within a {@link Autolinker#replaceFn replaceFn}
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 *
 *
 * ## Example use with a new tag for the replacement
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = new Autolinker.HtmlTag( {
 *                 tagName : 'button',
 *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
 *                 innerHtml : 'Load URL: ' + match.getAnchorText()
 *             } );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
 */
Autolinker.HtmlTag = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {String} tagName
	 *
	 * The tag name. Ex: 'a', 'button', etc.
	 *
	 * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toAnchorString}
	 * is executed.
	 */

	/**
	 * @cfg {Object.<String, String>} attrs
	 *
	 * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
	 * values are the attribute values.
	 */

	/**
	 * @cfg {String} innerHtml
	 *
	 * The inner HTML for the tag.
	 *
	 * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym
	 * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
	 * if you prefer, but this one is recommended.
	 */

	/**
	 * @cfg {String} innerHTML
	 *
	 * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
	 * for acronym names.
	 */


	/**
	 * @protected
	 * @property {RegExp} whitespaceRegex
	 *
	 * Regular expression used to match whitespace in a string of CSS classes.
	 */
	whitespaceRegex : /\s+/,


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym
	},


	/**
	 * Sets the tag name that will be used to generate the tag with.
	 *
	 * @param {String} tagName
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setTagName : function( tagName ) {
		this.tagName = tagName;
		return this;
	},


	/**
	 * Retrieves the tag name.
	 *
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName || "";
	},


	/**
	 * Sets an attribute on the HtmlTag.
	 *
	 * @param {String} attrName The attribute name to set.
	 * @param {String} attrValue The attribute value to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttr : function( attrName, attrValue ) {
		var tagAttrs = this.getAttrs();
		tagAttrs[ attrName ] = attrValue;

		return this;
	},


	/**
	 * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
	 *
	 * @param {String} name The attribute name to retrieve.
	 * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
	 */
	getAttr : function( attrName ) {
		return this.getAttrs()[ attrName ];
	},


	/**
	 * Sets one or more attributes on the HtmlTag.
	 *
	 * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttrs : function( attrs ) {
		var tagAttrs = this.getAttrs();
		Autolinker.Util.assign( tagAttrs, attrs );

		return this;
	},


	/**
	 * Retrieves the attributes Object (map) for the HtmlTag.
	 *
	 * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
	 */
	getAttrs : function() {
		return this.attrs || ( this.attrs = {} );
	},


	/**
	 * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setClass : function( cssClass ) {
		return this.setAttr( 'class', cssClass );
	},


	/**
	 * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to add.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	addClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    newClasses = cssClass.split( whitespaceRegex ),
		    newClass;

		while( newClass = newClasses.shift() ) {
			if( indexOf( classes, newClass ) === -1 ) {
				classes.push( newClass );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to remove one or more CSS classes from the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to remove.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	removeClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    removeClasses = cssClass.split( whitespaceRegex ),
		    removeClass;

		while( classes.length && ( removeClass = removeClasses.shift() ) ) {
			var idx = indexOf( classes, removeClass );
			if( idx !== -1 ) {
				classes.splice( idx, 1 );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
	 * there are multiple.
	 *
	 * @return {String}
	 */
	getClass : function() {
		return this.getAttrs()[ 'class' ] || "";
	},


	/**
	 * Convenience method to check if the tag has a CSS class or not.
	 *
	 * @param {String} cssClass The CSS class to check for.
	 * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
	 */
	hasClass : function( cssClass ) {
		return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;
	},


	/**
	 * Sets the inner HTML for the tag.
	 *
	 * @param {String} html The inner HTML to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setInnerHtml : function( html ) {
		this.innerHtml = html;

		return this;
	},


	/**
	 * Retrieves the inner HTML for the tag.
	 *
	 * @return {String}
	 */
	getInnerHtml : function() {
		return this.innerHtml || "";
	},


	/**
	 * Override of superclass method used to generate the HTML string for the tag.
	 *
	 * @return {String}
	 */
	toAnchorString : function() {
		var tagName = this.getTagName(),
		    attrsStr = this.buildAttrsStr();

		attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes

		return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( "" );
	},


	/**
	 * Support method for {@link #toAnchorString}, returns the string space-separated key="value" pairs, used to populate
	 * the stringified HtmlTag.
	 *
	 * @protected
	 * @return {String} Example return: `attr1="value1" attr2="value2"`
	 */
	buildAttrsStr : function() {
		if( !this.attrs ) return "";  // no `attrs` Object (map) has been set, return empty string

		var attrs = this.getAttrs(),
		    attrsArr = [];

		for( var prop in attrs ) {
			if( attrs.hasOwnProperty( prop ) ) {
				attrsArr.push( prop + '="' + attrs[ prop ] + '"' );
			}
		}
		return attrsArr.join( " " );
	}

} );

/*global Autolinker */
/*jshint sub:true */
/**
 * @protected
 * @class Autolinker.AnchorTagBuilder
 * @extends Object
 *
 * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.
 *
 * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may
 * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances
 * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 */
Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Boolean} newWindow
	 * @inheritdoc Autolinker#newWindow
	 */

	/**
	 * @cfg {Number} truncate
	 * @inheritdoc Autolinker#truncate
	 */

	/**
	 * @cfg {String} className
	 * @inheritdoc Autolinker#className
	 */


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},


	/**
	 * Generates the actual anchor (&lt;a&gt;) tag to use in place of the
	 * matched text, via its `match` object.
	 *
	 * @param {Autolinker.match.Match} match The Match instance to generate an
	 *   anchor tag from.
	 * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
	 */
	build : function( match ) {
		var tag = new Autolinker.HtmlTag( {
			tagName   : 'a',
			attrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),
			innerHtml : this.processAnchorText( match.getAnchorText() )
		} );

		return tag;
	},


	/**
	 * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)
	 *   tag being generated.
	 *
	 * @protected
	 * @param {"url"/"email"/"phone"/"twitter"/"hashtag"} matchType The type of
	 *   match that an anchor tag is being generated for.
	 * @param {String} href The href for the anchor tag.
	 * @return {Object} A key/value Object (map) of the anchor tag's attributes.
	 */
	createAttrs : function( matchType, anchorHref ) {
		var attrs = {
			'href' : anchorHref  // we'll always have the `href` attribute
		};

		var cssClass = this.createCssClass( matchType );
		if( cssClass ) {
			attrs[ 'class' ] = cssClass;
		}
		if( this.newWindow ) {
			attrs[ 'target' ] = "_blank";
		}

		return attrs;
	},


	/**
	 * Creates the CSS class that will be used for a given anchor tag, based on
	 * the `matchType` and the {@link #className} config.
	 *
	 * @private
	 * @param {"url"/"email"/"phone"/"twitter"/"hashtag"} matchType The type of
	 *   match that an anchor tag is being generated for.
	 * @return {String} The CSS class string for the link. Example return:
	 *   "myLink myLink-url". If no {@link #className} was configured, returns
	 *   an empty string.
	 */
	createCssClass : function( matchType ) {
		var className = this.className;

		if( !className )
			return "";
		else
			return className + " " + className + "-" + matchType;  // ex: "myLink myLink-url", "myLink myLink-email", "myLink myLink-phone", "myLink myLink-twitter", or "myLink myLink-hashtag"
	},


	/**
	 * Processes the `anchorText` by truncating the text according to the
	 * {@link #truncate} config.
	 *
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be
	 *   displayed).
	 * @return {String} The processed `anchorText`.
	 */
	processAnchorText : function( anchorText ) {
		anchorText = this.doTruncate( anchorText );

		return anchorText;
	},


	/**
	 * Performs the truncation of the `anchorText`, if the `anchorText` is
	 * longer than the {@link #truncate} option. Truncates the text to 2
	 * characters fewer than the {@link #truncate} option, and adds ".." to the
	 * end.
	 *
	 * @private
	 * @param {String} text The anchor tag's text (i.e. what will be displayed).
	 * @return {String} The truncated anchor text.
	 */
	doTruncate : function( anchorText ) {
		return Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );
	}

} );
/*global Autolinker */
/**
 * @private
 * @class Autolinker.htmlParser.HtmlParser
 * @extends Object
 *
 * An HTML parser implementation which simply walks an HTML string and returns an array of
 * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.
 *
 * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / "walking
 * around" HTML tags.
 */
Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {

	/**
	 * @private
	 * @property {RegExp} htmlRegex
	 *
	 * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
	 * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
	 *
	 * Capturing groups:
	 *
	 * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
	 * 2. If it is an end tag, this group will have the '/'.
	 * 3. If it is a comment tag, this group will hold the comment text (i.e.
	 *    the text inside the `&lt;!--` and `--&gt;`.
	 * 4. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)
	 */
	htmlRegex : (function() {
		var commentTagRegex = /!--([\s\S]+?)--/,
		    tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
		    attrNameRegex = /[^\s\0"'>\/=\x01-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
		    attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, // double quoted, single quoted, or unquoted attribute values
		    nameEqualsValueRegex = attrNameRegex.source + '(?:\\s*=\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'

		return new RegExp( [
			// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
			'(?:',
				'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag

					// Zero or more attributes following the tag name
					'(?:',
						'\\s+',  // one or more whitespace chars before an attribute

						// Either:
						// A. attr="value", or
						// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
						'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',
					')*',
				'>',
			')',

			'|',

			// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
			'(?:',
				'<(/)?',  // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.
				          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.

					'(?:',
						commentTagRegex.source,  // *** Capturing Group 3 - A Comment Tag's Text

						'|',

						'(?:',

							// *** Capturing Group 4 - The tag name
							'(' + tagNameRegex.source + ')',

							// Zero or more attributes following the tag name
							'(?:',
								'\\s+',                // one or more whitespace chars before an attribute
								nameEqualsValueRegex,  // attr="value" (with optional ="value" part)
							')*',

							'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'

						')',
					')',
				'>',
			')'
		].join( "" ), 'gi' );
	} )(),

	/**
	 * @private
	 * @property {RegExp} htmlCharacterEntitiesRegex
	 *
	 * The regular expression that matches common HTML character entities.
	 *
	 * Ignoring &amp; as it could be part of a query string -- handling it separately.
	 */
	htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,


	/**
	 * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}
	 * to represent the HTML structure of the input string.
	 *
	 * @param {String} html The HTML to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]}
	 */
	parse : function( html ) {
		var htmlRegex = this.htmlRegex,
		    currentResult,
		    lastIndex = 0,
		    textAndEntityNodes,
		    nodes = [];  // will be the result of the method

		while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
			var tagText = currentResult[ 0 ],
			    commentText = currentResult[ 3 ], // if we've matched a comment
			    tagName = currentResult[ 1 ] || currentResult[ 4 ],  // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a" or "img")
			    isClosingTag = !!currentResult[ 2 ],
			    inBetweenTagsText = html.substring( lastIndex, currentResult.index );

			// Push TextNodes and EntityNodes for any text found between tags
			if( inBetweenTagsText ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( inBetweenTagsText );
				nodes.push.apply( nodes, textAndEntityNodes );
			}

			// Push the CommentNode or ElementNode
			if( commentText ) {
				nodes.push( this.createCommentNode( tagText, commentText ) );
			} else {
				nodes.push( this.createElementNode( tagText, tagName, isClosingTag ) );
			}

			lastIndex = currentResult.index + tagText.length;
		}

		// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
		if( lastIndex < html.length ) {
			var text = html.substring( lastIndex );

			// Push TextNodes and EntityNodes for any text found between tags
			if( text ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( text );
				nodes.push.apply( nodes, textAndEntityNodes );
			}
		}

		return nodes;
	},


	/**
	 * Parses text and HTML entity nodes from a given string. The input string
	 * should not have any HTML tags (elements) within it.
	 *
	 * @private
	 * @param {String} text The text to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to
	 *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and
	 *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.
	 */
	parseTextAndEntityNodes : function( text ) {
		var nodes = [],
		    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array

		// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode
		// For example: an input `text` of "Test &quot;this&quot; today" would turn into the
		//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]
		for( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {
			var textToken = textAndEntityTokens[ i ],
			    entityToken = textAndEntityTokens[ i + 1 ];

			if( textToken ) nodes.push( this.createTextNode( textToken ) );
			if( entityToken ) nodes.push( this.createEntityNode( entityToken ) );
		}
		return nodes;
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.
	 *
	 * @private
	 * @param {String} tagText The full text of the tag (comment) that was
	 *   matched, including its &lt;!-- and --&gt;.
	 * @param {String} comment The full text of the comment that was matched.
	 */
	createCommentNode : function( tagText, commentText ) {
		return new Autolinker.htmlParser.CommentNode( {
			text: tagText,
			comment: Autolinker.Util.trim( commentText )
		} );
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.
	 *
	 * @private
	 * @param {String} tagText The full text of the tag (element) that was
	 *   matched, including its attributes.
	 * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would
	 *   be passed to this method as "img".
	 * @param {Boolean} isClosingTag `true` if it's a closing tag, false
	 *   otherwise.
	 * @return {Autolinker.htmlParser.ElementNode}
	 */
	createElementNode : function( tagText, tagName, isClosingTag ) {
		return new Autolinker.htmlParser.ElementNode( {
			text    : tagText,
			tagName : tagName.toLowerCase(),
			closing : isClosingTag
		} );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.
	 *
	 * @private
	 * @param {String} text The text that was matched for the HTML entity (such
	 *   as '&amp;nbsp;').
	 * @return {Autolinker.htmlParser.EntityNode}
	 */
	createEntityNode : function( text ) {
		return new Autolinker.htmlParser.EntityNode( { text: text } );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.
	 *
	 * @private
	 * @param {String} text The text that was matched.
	 * @return {Autolinker.htmlParser.TextNode}
	 */
	createTextNode : function( text ) {
		return new Autolinker.htmlParser.TextNode( { text: text } );
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML node found in an input string. An HTML node is one of the
 * following:
 *
 * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents
 *    HTML tags.
 * 2. A {@link Autolinker.htmlParser.CommentNode CommentNode}, which represents
 *    HTML comments.
 * 3. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text
 *    outside or within HTML tags.
 * 4. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents
 *    one of the known HTML entities that Autolinker looks for. This includes
 *    common ones such as &amp;quot; and &amp;nbsp;
 */
Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {String} text (required)
	 *
	 * The original text that was matched for the HtmlNode.
	 *
	 * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode},
	 *   this will be the tag's text.
	 * - In the case of an {@link Autolinker.htmlParser.CommentNode CommentNode},
	 *   this will be the comment's text.
	 * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this
	 *   will be the text itself.
	 * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode},
	 *   this will be the text of the HTML entity.
	 */
	text : "",


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 * specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,


	/**
	 * Retrieves the {@link #text} for the HtmlNode.
	 *
	 * @return {String}
	 */
	getText : function() {
		return this.text;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.CommentNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML comment node that has been parsed by the
 * {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.CommentNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * @cfg {String} comment (required)
	 *
	 * The text inside the comment tag. This text is stripped of any leading or
	 * trailing whitespace.
	 */
	comment : '',


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'comment';
	},


	/**
	 * Returns the comment inside the comment tag.
	 *
	 * @return {String}
	 */
	getComment : function() {
		return this.comment;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.ElementNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * @cfg {String} tagName (required)
	 *
	 * The name of the tag that was matched.
	 */
	tagName : '',

	/**
	 * @cfg {Boolean} closing (required)
	 *
	 * `true` if the element (tag) is a closing tag, `false` if its an opening
	 * tag.
	 */
	closing : false,


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'element';
	},


	/**
	 * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag,
	 * returns "img".
	 *
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName;
	},


	/**
	 * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt;
	 * returns `false`, while &lt;/div&gt; returns `true`.
	 *
	 * @return {Boolean}
	 */
	isClosing : function() {
		return this.closing;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.EntityNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText}
 * method.
 *
 * Note that this class will only be returned from the HtmlParser for the set of
 * checked HTML entity nodes  defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'entity';
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.TextNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'text';
	}

} );
/*global Autolinker */
/**
 * @private
 * @class Autolinker.matchParser.MatchParser
 * @extends Object
 *
 * Used by Autolinker to parse potential matches, given an input string of text.
 *
 * The MatchParser is fed a non-HTML string in order to search for matches.
 * Autolinker first uses the {@link Autolinker.htmlParser.HtmlParser} to "walk
 * around" HTML tags, and then the text around the HTML tags is passed into the
 * MatchParser in order to find the actual matches.
 */
Autolinker.matchParser.MatchParser = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Boolean} urls
	 * @inheritdoc Autolinker#urls
	 */
	urls : true,

	/**
	 * @cfg {Boolean} email
	 * @inheritdoc Autolinker#email
	 */
	email : true,

	/**
	 * @cfg {Boolean} twitter
	 * @inheritdoc Autolinker#twitter
	 */
	twitter : true,

	/**
	 * @cfg {Boolean} phone
	 * @inheritdoc Autolinker#phone
	 */
	phone: true,

	/**
	 * @cfg {Boolean/String} hashtag
	 * @inheritdoc Autolinker#hashtag
	 */
	hashtag : false,

	/**
	 * @cfg {Boolean} stripPrefix
	 * @inheritdoc Autolinker#stripPrefix
	 */
	stripPrefix : true,


	/**
	 * @private
	 * @property {RegExp} matcherRegex
	 *
	 * The regular expression that matches URLs, email addresses, phone #s,
	 * Twitter handles, and Hashtags.
	 *
	 * This regular expression has the following capturing groups:
	 *
	 * 1.  Group that is used to determine if there is a Twitter handle match
	 *     (i.e. \@someTwitterUser). Simply check for its existence to determine
	 *     if there is a Twitter handle match. The next couple of capturing
	 *     groups give information about the Twitter handle match.
	 * 2.  The whitespace character before the \@sign in a Twitter handle. This
	 *     is needed because there are no lookbehinds in JS regular expressions,
	 *     and can be used to reconstruct the original string in a replace().
	 * 3.  The Twitter handle itself in a Twitter match. If the match is
	 *     '@someTwitterUser', the handle is 'someTwitterUser'.
	 * 4.  Group that matches an email address. Used to determine if the match
	 *     is an email address, as well as holding the full address. Ex:
	 *     'me@my.com'
	 * 5.  Group that matches a URL in the input text. Ex: 'http://google.com',
	 *     'www.google.com', or just 'google.com'. This also includes a path,
	 *     url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor
	 * 6.  Group that matches a protocol URL (i.e. 'http://google.com'). This is
	 *     used to match protocol URLs with just a single word, like 'http://localhost',
	 *     where we won't double check that the domain name has at least one '.'
	 *     in it.
	 * 7.  A protocol-relative ('//') match for the case of a 'www.' prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     We need to know the character before the '//' in order to determine
	 *     if it is a valid match or the // was in a string we don't want to
	 *     auto-link.
	 * 8.  A protocol-relative ('//') match for the case of a known TLD prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     See #6 for more info.
	 * 9.  Group that is used to determine if there is a phone number match. The
	 *     next 3 groups give segments of the phone number.
	 * 10. Group that is used to determine if there is a Hashtag match
	 *     (i.e. \#someHashtag). Simply check for its existence to determine if
	 *     there is a Hashtag match. The next couple of capturing groups give
	 *     information about the Hashtag match.
	 * 11. The whitespace character before the #sign in a Hashtag handle. This
	 *     is needed because there are no look-behinds in JS regular
	 *     expressions, and can be used to reconstruct the original string in a
	 *     replace().
	 * 12. The Hashtag itself in a Hashtag match. If the match is
	 *     '#someHashtag', the hashtag is 'someHashtag'.
	 */
	matcherRegex : (function() {
		var twitterRegex = /(^|[^\w])@(\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs

		    hashtagRegex = /(^|[^\w])#(\w{1,139})/,              // For matching a Hashtag. Ex: #games

		    emailRegex = /(?:[\-;:&=\+\$,\w\.]+@)/,             // something@ for email addresses (a.k.a. local-part)
		    phoneRegex = /(?:\+?\d{1,3}[-\s.])?\(?\d{3}\)?[-\s.]?\d{3}[-\s.]\d{4}/,  // ex: (123) 456-7890, 123 456 7890, 123-456-7890, etc.
		    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\/\/)(?!\d+\/?)(?:\/\/)?)/,  // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
		    wwwRegex = /(?:www\.)/,                             // starting with 'www.'
		    domainNameRegex = /[A-Za-z0-9\.\-]*[A-Za-z0-9\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period
		    tldRegex = /\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|press|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b/,   // match our known top level domains (TLDs)

		    // Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
		    // http://blog.codinghorror.com/the-problem-with-urls/
		    urlSuffixRegex = /[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]?!:,.;]*[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]]/;

		return new RegExp( [
			'(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace()
				// *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and
				// *** Capturing group $3, which matches the actual twitter handle
				twitterRegex.source,
			')',

			'|',

			'(',  // *** Capturing group $4, which is used to determine an email match
				emailRegex.source,
				domainNameRegex.source,
				tldRegex.source,
			')',

			'|',

			'(',  // *** Capturing group $5, which is used to match a URL
				'(?:', // parens to cover match for protocol (optional), and domain
					'(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)
						protocolRegex.source,
						domainNameRegex.source,
					')',

					'|',

					'(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)
						'(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
						wwwRegex.source,
						domainNameRegex.source,
					')',

					'|',

					'(?:',  // non-capturing paren for known a TLD url (ex: google.com)
						'(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
						domainNameRegex.source,
						tldRegex.source,
					')',
				')',

				'(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional
			')',

			'|',

			// this setup does not scale well for open extension :( Need to rethink design of autolinker...
			// ***  Capturing group $9, which matches a (USA for now) phone number
			'(',
				phoneRegex.source,
			')',

			'|',

			'(',  // *** Capturing group $10, which can be used to check for a Hashtag match. Use group $12 for the actual Hashtag though. $11 may be used to reconstruct the original string in a replace()
				// *** Capturing group $11, which matches the whitespace character before the '#' sign (needed because of no lookbehinds), and
				// *** Capturing group $12, which matches the actual Hashtag
				hashtagRegex.source,
			')'
		].join( "" ), 'gi' );
	} )(),

	/**
	 * @private
	 * @property {RegExp} charBeforeProtocolRelMatchRegex
	 *
	 * The regular expression used to retrieve the character before a
	 * protocol-relative URL match.
	 *
	 * This is used in conjunction with the {@link #matcherRegex}, which needs
	 * to grab the character before a protocol-relative '//' due to the lack of
	 * a negative look-behind in JavaScript regular expressions. The character
	 * before the match is stripped from the URL.
	 */
	charBeforeProtocolRelMatchRegex : /^(.)?\/\//,

	/**
	 * @private
	 * @property {Autolinker.MatchValidator} matchValidator
	 *
	 * The MatchValidator object, used to filter out any false positives from
	 * the {@link #matcherRegex}. See {@link Autolinker.MatchValidator} for details.
	 */


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder
	 * instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		this.matchValidator = new Autolinker.MatchValidator();
	},


	/**
	 * Parses the input `text` to search for matches, and calls the `replaceFn`
	 * to allow replacements of the matches. Returns the `text` with matches
	 * replaced.
	 *
	 * @param {String} text The text to search and repace matches in.
	 * @param {Function} replaceFn The iterator function to handle the
	 *   replacements. The function takes a single argument, a {@link Autolinker.match.Match}
	 *   object, and should return the text that should make the replacement.
	 * @param {Object} [contextObj=window] The context object ("scope") to run
	 *   the `replaceFn` in.
	 * @return {String}
	 */
	replace : function( text, replaceFn, contextObj ) {
		var me = this;  // for closure

		return text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 ) {
			var matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 );  // "match description" object

			// Return out with no changes for match types that are disabled (url,
			// email, phone, etc.), or for matches that are invalid (false
			// positives from the matcherRegex, which can't use look-behinds
			// since they are unavailable in JS).
			if( !matchDescObj ) {
				return matchStr;

			} else {
				// Generate replacement text for the match from the `replaceFn`
				var replaceStr = replaceFn.call( contextObj, matchDescObj.match );
				return matchDescObj.prefixStr + replaceStr + matchDescObj.suffixStr;
			}
		} );
	},


	/**
	 * Processes a candidate match from the {@link #matcherRegex}.
	 *
	 * Not all matches found by the regex are actual URL/Email/Phone/Twitter/Hashtag
	 * matches, as determined by the {@link #matchValidator}. In this case, the
	 * method returns `null`. Otherwise, a valid Object with `prefixStr`,
	 * `match`, and `suffixStr` is returned.
	 *
	 * @private
	 * @param {String} matchStr The full match that was found by the
	 *   {@link #matcherRegex}.
	 * @param {String} twitterMatch The matched text of a Twitter handle, if the
	 *   match is a Twitter match.
	 * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char
	 *   before the @ sign in a Twitter handle match. This is needed because of
	 *   no lookbehinds in JS regexes, and is need to re-include the character
	 *   for the anchor tag replacement.
	 * @param {String} twitterHandle The actual Twitter user (i.e the word after
	 *   the @ sign in a Twitter match).
	 * @param {String} emailAddressMatch The matched email address for an email
	 *   address match.
	 * @param {String} urlMatch The matched URL string for a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative
	 *   match from a 'www' url, with the character that comes before the '//'.
	 * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative
	 *   match from a TLD (top level domain) match, with the character that
	 *   comes before the '//'.
	 * @param {String} phoneMatch The matched text of a phone number
	 * @param {String} hashtagMatch The matched text of a Twitter
	 *   Hashtag, if the match is a Hashtag match.
	 * @param {String} hashtagPrefixWhitespaceChar The whitespace char
	 *   before the # sign in a Hashtag match. This is needed because of no
	 *   lookbehinds in JS regexes, and is need to re-include the character for
	 *   the anchor tag replacement.
	 * @param {String} hashtag The actual Hashtag (i.e the word
	 *   after the # sign in a Hashtag match).
	 *
	 * @return {Object} A "match description object". This will be `null` if the
	 *   match was invalid, or if a match type is disabled. Otherwise, this will
	 *   be an Object (map) with the following properties:
	 * @return {String} return.prefixStr The char(s) that should be prepended to
	 *   the replacement string. These are char(s) that were needed to be
	 *   included from the regex match that were ignored by processing code, and
	 *   should be re-inserted into the replacement stream.
	 * @return {String} return.suffixStr The char(s) that should be appended to
	 *   the replacement string. These are char(s) that were needed to be
	 *   included from the regex match that were ignored by processing code, and
	 *   should be re-inserted into the replacement stream.
	 * @return {Autolinker.match.Match} return.match The Match object that
	 *   represents the match that was found.
	 */
	processCandidateMatch : function(
		matchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle,
		emailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch,
		tldProtocolRelativeMatch, phoneMatch, hashtagMatch,
		hashtagPrefixWhitespaceChar, hashtag
	) {
		// Note: The `matchStr` variable wil be fixed up to remove characters that are no longer needed (which will
		// be added to `prefixStr` and `suffixStr`).

		var protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
		    match,  // Will be an Autolinker.match.Match object

		    prefixStr = "",  // A string to use to prefix the anchor tag that is created. This is needed for the Twitter and Hashtag matches.
		    suffixStr = "";  // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.

		// Return out with `null` for match types that are disabled (url, email,
		// twitter, hashtag), or for matches that are invalid (false positives
		// from the matcherRegex, which can't use look-behinds since they are
		// unavailable in JS).
		if(
			( urlMatch && !this.urls ) ||
			( emailAddressMatch && !this.email ) ||
			( phoneMatch && !this.phone ) ||
			( twitterMatch && !this.twitter ) ||
			( hashtagMatch && !this.hashtag ) ||
			!this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch )
		) {
			return null;
		}

		// Handle a closing parenthesis at the end of the match, and exclude it
		// if there is not a matching open parenthesis
		// in the match itself.
		if( this.matchHasUnbalancedClosingParen( matchStr ) ) {
			matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
			suffixStr = ")";  // this will be added after the generated <a> tag
		} else {
			// Handle an invalid character after the TLD
			var pos = this.matchHasInvalidCharAfterTld( urlMatch, protocolUrlMatch );
			if( pos > -1 ) {
				suffixStr = matchStr.substr(pos);  // this will be added after the generated <a> tag
				matchStr = matchStr.substr( 0, pos ); // remove the trailing invalid chars
			}
		}

		if( emailAddressMatch ) {
			match = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );

		} else if( twitterMatch ) {
			// fix up the `matchStr` if there was a preceding whitespace char,
			// which was needed to determine the match itself (since there are
			// no look-behinds in JS regexes)
			if( twitterHandlePrefixWhitespaceChar ) {
				prefixStr = twitterHandlePrefixWhitespaceChar;
				matchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match
			}
			match = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );

		} else if( phoneMatch ) {
			// remove non-numeric values from phone number string
			var cleanNumber = matchStr.replace( /\D/g, '' );
 			match = new Autolinker.match.Phone( { matchedText: matchStr, number: cleanNumber } );

		} else if( hashtagMatch ) {
			// fix up the `matchStr` if there was a preceding whitespace char,
			// which was needed to determine the match itself (since there are
			// no look-behinds in JS regexes)
			if( hashtagPrefixWhitespaceChar ) {
				prefixStr = hashtagPrefixWhitespaceChar;
				matchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match
			}
			match = new Autolinker.match.Hashtag( { matchedText: matchStr, serviceName: this.hashtag, hashtag: hashtag } );

		} else {  // url match
			// If it's a protocol-relative '//' match, remove the character
			// before the '//' (which the matcherRegex needed to match due to
			// the lack of a negative look-behind in JavaScript regular
			// expressions)
			if( protocolRelativeMatch ) {
				var charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || "";

				if( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)
					prefixStr = charBeforeMatch;
					matchStr = matchStr.slice( 1 );  // remove the prefixed char from the match
				}
			}

			match = new Autolinker.match.Url( {
				matchedText : matchStr,
				url : matchStr,
				protocolUrlMatch : !!protocolUrlMatch,
				protocolRelativeMatch : !!protocolRelativeMatch,
				stripPrefix : this.stripPrefix
			} );
		}

		return {
			prefixStr : prefixStr,
			suffixStr : suffixStr,
			match     : match
		};
	},


	/**
	 * Determines if a match found has an unmatched closing parenthesis. If so,
	 * this parenthesis will be removed from the match itself, and appended
	 * after the generated anchor tag in {@link #processCandidateMatch}.
	 *
	 * A match may have an extra closing parenthesis at the end of the match
	 * because the regular expression must include parenthesis for URLs such as
	 * "wikipedia.com/something_(disambiguation)", which should be auto-linked.
	 *
	 * However, an extra parenthesis *will* be included when the URL itself is
	 * wrapped in parenthesis, such as in the case of "(wikipedia.com/something_(disambiguation))".
	 * In this case, the last closing parenthesis should *not* be part of the
	 * URL itself, and this method will return `true`.
	 *
	 * @private
	 * @param {String} matchStr The full match string from the {@link #matcherRegex}.
	 * @return {Boolean} `true` if there is an unbalanced closing parenthesis at
	 *   the end of the `matchStr`, `false` otherwise.
	 */
	matchHasUnbalancedClosingParen : function( matchStr ) {
		var lastChar = matchStr.charAt( matchStr.length - 1 );

		if( lastChar === ')' ) {
			var openParensMatch = matchStr.match( /\(/g ),
			    closeParensMatch = matchStr.match( /\)/g ),
			    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
			    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;

			if( numOpenParens < numCloseParens ) {
				return true;
			}
		}

		return false;
	},


	/**
	 * Determine if there's an invalid character after the TLD in a URL. Valid
	 * characters after TLD are ':/?#'. Exclude protocol matched URLs from this
	 * check.
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Number} the position where the invalid character was found. If
	 *   no such character was found, returns -1
	 */
	matchHasInvalidCharAfterTld : function( urlMatch, protocolUrlMatch ) {
		if ( !urlMatch ) {
			return -1;
		}

		var offset = 0;
		if ( protocolUrlMatch ) {
			offset = urlMatch.indexOf(':');
			urlMatch = urlMatch.slice(offset);
		}

		var re = /^((.?\/\/)?[A-Za-z0-9\.\-]*[A-Za-z0-9\-]\.[A-Za-z]+)/;
		var res = re.exec( urlMatch );
		if ( res === null ) {
			return -1;
		}

		offset += res[1].length;
		urlMatch = urlMatch.slice(res[1].length);
		if (/^[^.A-Za-z:\/?#]/.test(urlMatch)) {
			return offset;
		}

		return -1;
	}

} );

/*global Autolinker */
/*jshint scripturl:true */
/**
 * @private
 * @class Autolinker.MatchValidator
 * @extends Object
 *
 * Used by Autolinker to filter out false positives from the
 * {@link Autolinker.matchParser.MatchParser#matcherRegex}.
 *
 * Due to the limitations of regular expressions (including the missing feature
 * of look-behinds in JS regular expressions), we cannot always determine the
 * validity of a given match. This class applies a bit of additional logic to
 * filter out any false positives that have been matched by the
 * {@link Autolinker.matchParser.MatchParser#matcherRegex}.
 */
Autolinker.MatchValidator = Autolinker.Util.extend( Object, {

	/**
	 * @private
	 * @property {RegExp} invalidProtocolRelMatchRegex
	 *
	 * The regular expression used to check a potential protocol-relative URL
	 * match, coming from the {@link Autolinker.matchParser.MatchParser#matcherRegex}.
	 * A protocol-relative URL is, for example, "//yahoo.com"
	 *
	 * This regular expression checks to see if there is a word character before
	 * the '//' match in order to determine if we should actually autolink a
	 * protocol-relative URL. This is needed because there is no negative
	 * look-behind in JavaScript regular expressions.
	 *
	 * For instance, we want to autolink something like "Go to: //google.com",
	 * but we don't want to autolink something like "abc//google.com"
	 */
	invalidProtocolRelMatchRegex : /^[\w]\/\//,

	/**
	 * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
	 *
	 * @private
	 * @property {RegExp} hasFullProtocolRegex
	 */
	hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]+:\/\//,

	/**
	 * Regex to find the URI scheme, such as 'mailto:'.
	 *
	 * This is used to filter out 'javascript:' and 'vbscript:' schemes.
	 *
	 * @private
	 * @property {RegExp} uriSchemeRegex
	 */
	uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]+:/,

	/**
	 * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
	 *
	 * @private
	 * @property {RegExp} hasWordCharAfterProtocolRegex
	 */
	hasWordCharAfterProtocolRegex : /:[^\s]*?[A-Za-z]/,


	/**
	 * Determines if a given match found by the {@link Autolinker.matchParser.MatchParser}
	 * is valid. Will return `false` for:
	 *
	 * 1) URL matches which do not have at least have one period ('.') in the
	 *    domain name (effectively skipping over matches like "abc:def").
	 *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')
	 * 2) URL matches which do not have at least one word character in the
	 *    domain name (effectively skipping over matches like "git:1.0").
	 * 3) A protocol-relative url match (a URL beginning with '//') whose
	 *    previous character is a word character (effectively skipping over
	 *    strings like "abc//google.com")
	 *
	 * Otherwise, returns `true`.
	 *
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @param {String} protocolRelativeMatch The protocol-relative string for a
	 *   URL match (i.e. '//'), possibly with a preceding character (ex, a
	 *   space, such as: ' //', or a letter, such as: 'a//'). The match is
	 *   invalid if there is a word character preceding the '//'.
	 * @return {Boolean} `true` if the match given is valid and should be
	 *   processed, or `false` if the match is invalid and/or should just not be
	 *   processed.
	 */
	isValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {
		if(
			( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||
			this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
			this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
			this.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like "abc//google.com")
		) {
			return false;
		}

		return true;
	},


	/**
	 * Determines if the URI scheme is a valid scheme to be autolinked. Returns
	 * `false` if the scheme is 'javascript:' or 'vbscript:'
	 *
	 * @private
	 * @param {String} uriSchemeMatch The match URL string for a full URI scheme
	 *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.
	 * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
	 */
	isValidUriScheme : function( uriSchemeMatch ) {
		var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();

		return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );
	},


	/**
	 * Determines if a URL match does not have either:
	 *
	 * a) a full protocol (i.e. 'http://'), or
	 * b) at least one dot ('.') in the domain name (for a non-full-protocol
	 *    match).
	 *
	 * Either situation is considered an invalid URL (ex: 'git:d' does not have
	 * either the '://' part, or at least one dot in the domain name. If the
	 * match was 'git:abc.com', we would consider this valid.)
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Boolean} `true` if the URL match does not have a full protocol,
	 *   or at least one dot ('.') in a non-full-protocol match.
	 */
	urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {
		return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );
	},


	/**
	 * Determines if a URL match does not have at least one word character after
	 * the protocol (i.e. in the domain name).
	 *
	 * At least one letter character must exist in the domain name after a
	 * protocol match. Ex: skip over something like "git:1.0"
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we
	 *   have a protocol in the URL string, in order to check for a word
	 *   character after the protocol separator (':').
	 * @return {Boolean} `true` if the URL match does not have at least one word
	 *   character in it after the protocol, `false` otherwise.
	 */
	urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {
		if( urlMatch && protocolUrlMatch ) {
			return !this.hasWordCharAfterProtocolRegex.test( urlMatch );
		} else {
			return false;
		}
	},


	/**
	 * Determines if a protocol-relative match is an invalid one. This method
	 * returns `true` if there is a `protocolRelativeMatch`, and that match
	 * contains a word character before the '//' (i.e. it must contain
	 * whitespace or nothing before the '//' in order to be considered valid).
	 *
	 * @private
	 * @param {String} protocolRelativeMatch The protocol-relative string for a
	 *   URL match (i.e. '//'), possibly with a preceding character (ex, a
	 *   space, such as: ' //', or a letter, such as: 'a//'). The match is
	 *   invalid if there is a word character preceding the '//'.
	 * @return {Boolean} `true` if it is an invalid protocol-relative match,
	 *   `false` otherwise.
	 */
	isInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {
		return ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.match.Match
 * 
 * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a 
 * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
 * 
 * For example:
 * 
 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
 *     
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *         
 *             switch( match.getType() ) {
 *                 case 'url' : 
 *                     console.log( "url: ", match.getUrl() );
 *                     
 *                 case 'email' :
 *                     console.log( "email: ", match.getEmail() );
 *                     
 *                 case 'twitter' :
 *                     console.log( "twitter: ", match.getTwitterHandle() );
 *             }
 *         }
 *     } );
 *     
 * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
 */
Autolinker.match.Match = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {String} matchedText (required)
	 * 
	 * The original text that was matched.
	 */
	
	
	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},

	
	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Returns the original text that was matched.
	 * 
	 * @return {String}
	 */
	getMatchedText : function() {
		return this.matchedText;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getAnchorHref : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getAnchorText : Autolinker.Util.abstractMethod

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Email
 * @extends Autolinker.match.Match
 * 
 * Represents a Email match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} email (required)
	 * 
	 * The email address that was matched.
	 */
	

	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'email';
	},
	
	
	/**
	 * Returns the email address that was matched.
	 * 
	 * @return {String}
	 */
	getEmail : function() {
		return this.email;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'mailto:' + this.email;
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.email;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.match.Hashtag
 * @extends Autolinker.match.Match
 *
 * Represents a Hashtag match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Hashtag = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} serviceName (required)
	 *
	 * The service to point hashtag matches to. See {@link Autolinker#hashtag}
	 * for available values.
	 */

	/**
	 * @cfg {String} hashtag (required)
	 *
	 * The Hashtag that was matched, without the '#'.
	 */


	/**
	 * Returns the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'hashtag';
	},


	/**
	 * Returns the matched hashtag.
	 *
	 * @return {String}
	 */
	getHashtag : function() {
		return this.hashtag;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		var serviceName = this.serviceName,
		    hashtag = this.hashtag;

		switch( serviceName ) {
			case 'twitter' :
				return 'https://twitter.com/hashtag/' + hashtag;
			case 'facebook' :
				return 'https://www.facebook.com/hashtag/' + hashtag;
			case 'instagram' :
				return 'https://instagram.com/explore/tags/' + hashtag;

			default :  // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.
				throw new Error( 'Unknown service name to point hashtag to: ', serviceName );
		}
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return '#' + this.hashtag;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Phone
 * @extends Autolinker.match.Match
 *
 * Represents a Phone number match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Phone = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} number (required)
	 *
	 * The phone number that was matched.
	 */


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'phone';
	},


	/**
	 * Returns the phone number that was matched.
	 *
	 * @return {String}
	 */
	getNumber: function() {
		return this.number;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'tel:' + this.number;
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.matchedText;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Twitter
 * @extends Autolinker.match.Match
 * 
 * Represents a Twitter match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} twitterHandle (required)
	 * 
	 * The Twitter handle that was matched.
	 */
	

	/**
	 * Returns the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'twitter';
	},
	
	
	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getTwitterHandle : function() {
		return this.twitterHandle;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'https://twitter.com/' + this.twitterHandle;
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		return '@' + this.twitterHandle;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.match.Url
 * @extends Autolinker.match.Match
 * 
 * Represents a Url match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} url (required)
	 * 
	 * The url that was matched.
	 */
	
	/**
	 * @cfg {Boolean} protocolUrlMatch (required)
	 * 
	 * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or
	 * known TLD match.
	 */
	
	/**
	 * @cfg {Boolean} protocolRelativeMatch (required)
	 * 
	 * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',
	 * and will be either http:// or https:// based on the protocol that the site is loaded under.
	 */
	
	/**
	 * @cfg {Boolean} stripPrefix (required)
	 * @inheritdoc Autolinker#stripPrefix
	 */
	

	/**
	 * @private
	 * @property {RegExp} urlPrefixRegex
	 * 
	 * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.
	 */
	urlPrefixRegex: /^(https?:\/\/)?(www\.)?/i,
	
	/**
	 * @private
	 * @property {RegExp} protocolRelativeRegex
	 * 
	 * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
	 * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
	 */
	protocolRelativeRegex : /^\/\//,
	
	/**
	 * @private
	 * @property {Boolean} protocolPrepended
	 * 
	 * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
	 * {@link #url} did not have a protocol)
	 */
	protocolPrepended : false,
	

	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'url';
	},
	
	
	/**
	 * Returns the url that was matched, assuming the protocol to be 'http://' if the original
	 * match was missing a protocol.
	 * 
	 * @return {String}
	 */
	getUrl : function() {
		var url = this.url;
		
		// if the url string doesn't begin with a protocol, assume 'http://'
		if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {
			url = this.url = 'http://' + url;
			
			this.protocolPrepended = true;
		}
		
		return url;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		var url = this.getUrl();
		
		return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html 
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		var anchorText = this.getUrl();
		
		if( this.protocolRelativeMatch ) {
			// Strip off any protocol-relative '//' from the anchor text
			anchorText = this.stripProtocolRelativePrefix( anchorText );
		}
		if( this.stripPrefix ) {
			anchorText = this.stripUrlPrefix( anchorText );
		}
		anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one
		
		return anchorText;
	},
	
	
	// ---------------------------------------
	
	// Utility Functionality
	
	/**
	 * Strips the URL prefix (such as "http://" or "https://") from the given text.
	 * 
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   url prefix (such as stripping off "http://")
	 * @return {String} The `anchorText`, with the prefix stripped.
	 */
	stripUrlPrefix : function( text ) {
		return text.replace( this.urlPrefixRegex, '' );
	},
	
	
	/**
	 * Strips any protocol-relative '//' from the anchor text.
	 * 
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   protocol-relative prefix (such as stripping off "//")
	 * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
	 */
	stripProtocolRelativePrefix : function( text ) {
		return text.replace( this.protocolRelativeRegex, '' );
	},
	
	
	/**
	 * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
	 * 
	 * @private
	 * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
	 *   slash ('/') that may exist.
	 * @return {String} The `anchorText`, with the trailing slash removed.
	 */
	removeTrailingSlash : function( anchorText ) {
		if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
			anchorText = anchorText.slice( 0, -1 );
		}
		return anchorText;
	}
	
} );
return Autolinker;

}));

},{}],"/Users/youzi/dev/mtv-play/node_modules/backo2/index.js":[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],"/Users/youzi/dev/mtv-play/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],"/Users/youzi/dev/mtv-play/node_modules/blob/index.js":[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/Users/youzi/dev/mtv-play/node_modules/colors/colors.js":[function(require,module,exports){
/*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var isHeadless = false;

if (typeof module !== 'undefined') {
  isHeadless = true;
}

if (!isHeadless) {
  var exports = {};
  var module = {};
  var colors = exports;
  exports.mode = "browser";
} else {
  exports.mode = "console";
}

//
// Prototypes the string object to have additional method calls that add terminal colors
//
var addProperty = function (color, func) {
  exports[color] = function (str) {
    return func.apply(str);
  };
  String.prototype.__defineGetter__(color, func);
};

function stylize(str, style) {

  var styles;

  if (exports.mode === 'console') {
    styles = {
      //styles
      'bold'      : ['\x1B[1m',  '\x1B[22m'],
      'italic'    : ['\x1B[3m',  '\x1B[23m'],
      'underline' : ['\x1B[4m',  '\x1B[24m'],
      'inverse'   : ['\x1B[7m',  '\x1B[27m'],
      'strikethrough' : ['\x1B[9m',  '\x1B[29m'],
      //text colors
      //grayscale
      'white'     : ['\x1B[37m', '\x1B[39m'],
      'grey'      : ['\x1B[90m', '\x1B[39m'],
      'black'     : ['\x1B[30m', '\x1B[39m'],
      //colors
      'blue'      : ['\x1B[34m', '\x1B[39m'],
      'cyan'      : ['\x1B[36m', '\x1B[39m'],
      'green'     : ['\x1B[32m', '\x1B[39m'],
      'magenta'   : ['\x1B[35m', '\x1B[39m'],
      'red'       : ['\x1B[31m', '\x1B[39m'],
      'yellow'    : ['\x1B[33m', '\x1B[39m'],
      //background colors
      //grayscale
      'whiteBG'     : ['\x1B[47m', '\x1B[49m'],
      'greyBG'      : ['\x1B[49;5;8m', '\x1B[49m'],
      'blackBG'     : ['\x1B[40m', '\x1B[49m'],
      //colors
      'blueBG'      : ['\x1B[44m', '\x1B[49m'],
      'cyanBG'      : ['\x1B[46m', '\x1B[49m'],
      'greenBG'     : ['\x1B[42m', '\x1B[49m'],
      'magentaBG'   : ['\x1B[45m', '\x1B[49m'],
      'redBG'       : ['\x1B[41m', '\x1B[49m'],
      'yellowBG'    : ['\x1B[43m', '\x1B[49m']
    };
  } else if (exports.mode === 'browser') {
    styles = {
      //styles
      'bold'      : ['<b>',  '</b>'],
      'italic'    : ['<i>',  '</i>'],
      'underline' : ['<u>',  '</u>'],
      'inverse'   : ['<span style="background-color:black;color:white;">',  '</span>'],
      'strikethrough' : ['<del>',  '</del>'],
      //text colors
      //grayscale
      'white'     : ['<span style="color:white;">',   '</span>'],
      'grey'      : ['<span style="color:gray;">',    '</span>'],
      'black'     : ['<span style="color:black;">',   '</span>'],
      //colors
      'blue'      : ['<span style="color:blue;">',    '</span>'],
      'cyan'      : ['<span style="color:cyan;">',    '</span>'],
      'green'     : ['<span style="color:green;">',   '</span>'],
      'magenta'   : ['<span style="color:magenta;">', '</span>'],
      'red'       : ['<span style="color:red;">',     '</span>'],
      'yellow'    : ['<span style="color:yellow;">',  '</span>'],
      //background colors
      //grayscale
      'whiteBG'     : ['<span style="background-color:white;">',   '</span>'],
      'greyBG'      : ['<span style="background-color:gray;">',    '</span>'],
      'blackBG'     : ['<span style="background-color:black;">',   '</span>'],
      //colors
      'blueBG'      : ['<span style="background-color:blue;">',    '</span>'],
      'cyanBG'      : ['<span style="background-color:cyan;">',    '</span>'],
      'greenBG'     : ['<span style="background-color:green;">',   '</span>'],
      'magentaBG'   : ['<span style="background-color:magenta;">', '</span>'],
      'redBG'       : ['<span style="background-color:red;">',     '</span>'],
      'yellowBG'    : ['<span style="background-color:yellow;">',  '</span>']
    };
  } else if (exports.mode === 'none') {
    return str + '';
  } else {
    console.log('unsupported mode, try "browser", "console" or "none"');
  }
  return styles[style][0] + str + styles[style][1];
}

function applyTheme(theme) {

  //
  // Remark: This is a list of methods that exist
  // on String that you should not overwrite.
  //
  var stringPrototypeBlacklist = [
    '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
    'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
    'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
    'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
  ];

  Object.keys(theme).forEach(function (prop) {
    if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
      console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
    }
    else {
      if (typeof(theme[prop]) === 'string') {
        addProperty(prop, function () {
          return exports[theme[prop]](this);
        });
      }
      else {
        addProperty(prop, function () {
          var ret = this;
          for (var t = 0; t < theme[prop].length; t++) {
            ret = exports[theme[prop][t]](ret);
          }
          return ret;
        });
      }
    }
  });
}


//
// Iterate through all default styles and colors
//
var x = ['bold', 'underline', 'strikethrough', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta', 'greyBG', 'blackBG', 'yellowBG', 'redBG', 'greenBG', 'blueBG', 'whiteBG', 'cyanBG', 'magentaBG'];
x.forEach(function (style) {

  // __defineGetter__ at the least works in more browsers
  // http://robertnyman.com/javascript/javascript-getters-setters.html
  // Object.defineProperty only works in Chrome
  addProperty(style, function () {
    return stylize(this, style);
  });
});

function sequencer(map) {
  return function () {
    if (!isHeadless) {
      return this.replace(/( )/, '$1');
    }
    var exploded = this.split(""), i = 0;
    exploded = exploded.map(map);
    return exploded.join("");
  };
}

var rainbowMap = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
    }
  };
})();

exports.themes = {};

exports.addSequencer = function (name, map) {
  addProperty(name, sequencer(map));
};

exports.addSequencer('rainbow', rainbowMap);
exports.addSequencer('zebra', function (letter, i, exploded) {
  return i % 2 === 0 ? letter : letter.inverse;
});

exports.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      exports.themes[theme] = require(theme);
      applyTheme(exports.themes[theme]);
      return exports.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};


addProperty('stripColors', function () {
  return ("" + this).replace(/\x1B\[\d+m/g, '');
});

// please no
function zalgo(text, options) {
  var soul = {
    "up" : [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚'
    ],
    "down" : [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣'
    ],
    "mid" : [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] = options["up"] || true;
    options["mid"] = options["mid"] || true;
    options["down"] = options["down"] || true;
    options["size"] = options["size"] || "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.min = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.min = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  return heComes(text);
}


// don't summon zalgo
addProperty('zalgo', function () {
  return zalgo(this);
});

},{}],"/Users/youzi/dev/mtv-play/node_modules/component-bind/index.js":[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],"/Users/youzi/dev/mtv-play/node_modules/component-emitter/index.js":[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],"/Users/youzi/dev/mtv-play/node_modules/component-inherit/index.js":[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js":[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":"/Users/youzi/dev/mtv-play/node_modules/debug/debug.js"}],"/Users/youzi/dev/mtv-play/node_modules/debug/debug.js":[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":"/Users/youzi/dev/mtv-play/node_modules/ms/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/index.js":[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/index.js":[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/socket.js","engine.io-parser":"/Users/youzi/dev/mtv-play/node_modules/engine.io-parser/lib/browser.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/socket.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;

  // other options for Node.js client
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }
  }

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function(){
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if('function' == typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' == typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transport.js","./transports":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/index.js","component-emitter":"/Users/youzi/dev/mtv-play/node_modules/component-emitter/index.js","debug":"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js","engine.io-parser":"/Users/youzi/dev/mtv-play/node_modules/engine.io-parser/lib/browser.js","indexof":"/Users/youzi/dev/mtv-play/node_modules/indexof/index.js","parsejson":"/Users/youzi/dev/mtv-play/node_modules/parsejson/index.js","parseqs":"/Users/youzi/dev/mtv-play/node_modules/parseqs/index.js","parseuri":"/Users/youzi/dev/mtv-play/node_modules/parseuri/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transport.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":"/Users/youzi/dev/mtv-play/node_modules/component-emitter/index.js","engine.io-parser":"/Users/youzi/dev/mtv-play/node_modules/engine.io-parser/lib/browser.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/index.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/polling-jsonp.js","./polling-xhr":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/polling-xhr.js","./websocket":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/websocket.js","xmlhttprequest-ssl":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/polling-jsonp.js":[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  }
  else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/polling.js","component-inherit":"/Users/youzi/dev/mtv-play/node_modules/component-inherit/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/polling-xhr.js":[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/polling.js","component-emitter":"/Users/youzi/dev/mtv-play/node_modules/component-emitter/index.js","component-inherit":"/Users/youzi/dev/mtv-play/node_modules/component-inherit/index.js","debug":"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js","xmlhttprequest-ssl":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/polling.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transport.js","component-inherit":"/Users/youzi/dev/mtv-play/node_modules/component-inherit/index.js","debug":"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js","engine.io-parser":"/Users/youzi/dev/mtv-play/node_modules/engine.io-parser/lib/browser.js","parseqs":"/Users/youzi/dev/mtv-play/node_modules/parseqs/index.js","xmlhttprequest-ssl":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/xmlhttprequest.js","yeast":"/Users/youzi/dev/mtv-play/node_modules/yeast/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transports/websocket.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  try {
    WebSocket = require('ws');
  } catch (e) { }
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'buffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function(packet) {
      parser.encodePacket(packet, self.supportsBinary, function(data) {
        if (!BrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        //Sometimes the websocket has already been closed but the browser didn't
        //have a chance of informing us about it yet, in that case send will
        //throw an error
        try {
          if (BrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e){
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done(){
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function(){
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../transport":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/transport.js","component-inherit":"/Users/youzi/dev/mtv-play/node_modules/component-inherit/index.js","debug":"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js","engine.io-parser":"/Users/youzi/dev/mtv-play/node_modules/engine.io-parser/lib/browser.js","parseqs":"/Users/youzi/dev/mtv-play/node_modules/parseqs/index.js","ws":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/browser-resolve/empty.js","yeast":"/Users/youzi/dev/mtv-play/node_modules/yeast/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/lib/xmlhttprequest.js":[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":"/Users/youzi/dev/mtv-play/node_modules/has-cors/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-parser/lib/browser.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":"/Users/youzi/dev/mtv-play/node_modules/engine.io-parser/lib/keys.js","after":"/Users/youzi/dev/mtv-play/node_modules/after/index.js","arraybuffer.slice":"/Users/youzi/dev/mtv-play/node_modules/arraybuffer.slice/index.js","base64-arraybuffer":"/Users/youzi/dev/mtv-play/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js","blob":"/Users/youzi/dev/mtv-play/node_modules/blob/index.js","has-binary":"/Users/youzi/dev/mtv-play/node_modules/has-binary/index.js","utf8":"/Users/youzi/dev/mtv-play/node_modules/utf8/utf8.js"}],"/Users/youzi/dev/mtv-play/node_modules/engine.io-parser/lib/keys.js":[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],"/Users/youzi/dev/mtv-play/node_modules/has-binary/index.js":[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":"/Users/youzi/dev/mtv-play/node_modules/isarray/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/has-cors/index.js":[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],"/Users/youzi/dev/mtv-play/node_modules/indexof/index.js":[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],"/Users/youzi/dev/mtv-play/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/youzi/dev/mtv-play/node_modules/jquery/dist/jquery.js":[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.2.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-04-05T19:26Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
var arr = [];

var document = window.document;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "2.2.3",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		var realStringObj = obj && obj.toString();
		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
	},

	isPlainObject: function( obj ) {
		var key;

		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Not own constructor property must be Object
		if ( obj.constructor &&
				!hasOwn.call( obj, "constructor" ) &&
				!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {

			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf( "use strict" ) === 1 ) {
				script = document.createElement( "script" );
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {

				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval

				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
/* jshint ignore: start */
if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
/* jshint ignore: end */

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, nidselect, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
					while ( i-- ) {
						groups[i] = nidselect + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[ 0 ] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

				// Always skip document fragments
				if ( cur.nodeType < 11 && ( pos ?
					pos.index( cur ) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector( cur, selectors ) ) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this === promise ? newDefer.promise() : this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add( function() {

					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 ||
				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.progress( updateFunc( i, progressContexts, progressValues ) )
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
} );


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {

	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
} );

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE9-10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	register: function( owner, initial ) {
		var value = initial || {};

		// If it is a node unlikely to be stringify-ed or looped over
		// use plain assignment
		if ( owner.nodeType ) {
			owner[ this.expando ] = value;

		// Otherwise secure it in a non-enumerable, non-writable property
		// configurability must be true to allow the property to be
		// deleted with the delete operator
		} else {
			Object.defineProperty( owner, this.expando, {
				value: value,
				writable: true,
				configurable: true
			} );
		}
		return owner[ this.expando ];
	},
	cache: function( owner ) {

		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return an empty object.
		if ( !acceptData( owner ) ) {
			return {};
		}

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ prop ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :
			owner[ this.expando ] && owner[ this.expando ][ key ];
	},
	access: function( owner, key, value ) {
		var stored;

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase( key ) );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key === undefined ) {
			this.register( owner );

		} else {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );

				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;

			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <= 35-45+
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://code.google.com/p/chromium/issues/detail?id=378607
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data, camelKey;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// with the key as-is
				data = dataUser.get( elem, key ) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

				if ( data !== undefined ) {
					return data;
				}

				camelKey = jQuery.camelCase( key );

				// Attempt to get data from the cache
				// with the key camelized
				data = dataUser.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			camelKey = jQuery.camelCase( key );
			this.each( function() {

				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = dataUser.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				dataUser.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
					dataUser.set( this, key, value );
				}
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" ||
			!jQuery.contains( elem.ownerDocument, elem );
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() { return tween.cur(); } :
			function() { return jQuery.css( elem, prop, "" ); },
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([\w:-]+)/ );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE9
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE9-11+
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0-4.3, Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE9
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support (at least): Chrome, IE9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox<=42+
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split( " " ),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
			"screenX screenY toElement" ).split( " " ),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX +
					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
					( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY +
					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
					( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {
	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName( "tbody" )[ 0 ] ||
			elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {

	// Keep domManip exposed until 3.0 (gh-2225)
	domManip: domManip,

	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );


var iframe,
	elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		display = jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
				.appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var documentElement = document.documentElement;



( function() {
	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {
		div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );
	}

	jQuery.extend( support, {
		pixelPosition: function() {

			// This test is executed only once but we still do memoizing
			// since we can use the boxSizingReliable pre-computing.
			// No need to check if the test was already performed, though.
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {

			// Support: Android 4.0-4.3
			// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
			// since that compresses better and they're computed together anyway.
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {

			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return reliableMarginLeftVal;
		},
		reliableMarginRight: function() {

			// Support: Android 2.3
			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// This support function is only executed once so no memoizing is needed.
			var ret,
				marginDiv = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" +
				"display:block;margin:0;border:0;padding:0";
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			documentElement.appendChild( container );

			ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

			documentElement.removeChild( container );
			div.removeChild( marginDiv );

			return ret;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );
	ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

	// Support: Opera 12.1x only
	// Fall back to style even without computed
	// computed is undefined for elems on document fragments
	if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
		ret = jQuery.style( elem, name );
	}

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE11 only
	// In IE 11 fullscreen elements inside of an iframe have
	// 100x too small dimensions (gh-1764).
	if ( document.msFullscreenElement && window.top !== window ) {

		// Support: IE11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = Math.round( elem.getBoundingClientRect()[ name ] * 100 );
		}
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = dataPriv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {

			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = dataPriv.access(
					elem,
					"olddisplay",
					defaultDisplay( elem.nodeName )
				);
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				dataPriv.set(
					elem,
					"olddisplay",
					hidden ? display : jQuery.css( elem, "display" )
				);
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
					elem.offsetWidth === 0 ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show
				// and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = dataPriv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done( function() {
				jQuery( elem ).hide();
			} );
		}
		anim.done( function() {
			var prop;

			dataPriv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		} );
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
		opt.duration : opt.duration in jQuery.fx.speeds ?
			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	window.clearInterval( timerId );

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {

					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g,
	rspaces = /[\x20\t\r\n\f]+/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ?
								!option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true

				// Previously, `originalEvent: {}` was set here, so stopPropagation call
				// would not be triggered on donor event, since in our own
				// jQuery.event.stopPropagation function we had a check for existence of
				// originalEvent.stopPropagation method, so, consequently it would be a noop.
				//
				// But now, this "simulate" function is used only for events
				// for which stopPropagation() is noop, so there is no need for that anymore.
				//
				// For the 1.x branch though, guard for "click" and "submit"
				// events is still used, but was moved to jQuery.event.stopPropagation function
				// because `originalEvent` should point to the original event for the constancy
				// with other events and for more focused logic
			}
		);

		jQuery.event.trigger( e, null, elem );

		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE8-11+
			// IE throws exception if url is malformed, e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE8-11+
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );

				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapAll( html.call( this, i ) );
			} );
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


jQuery.expr.filters.hidden = function( elem ) {
	return !jQuery.expr.filters.visible( elem );
};
jQuery.expr.filters.visible = function( elem ) {

	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	// Use OR instead of AND as the element is not visible if either is true
	// See tickets #10406 and #13132
	return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE9
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE9
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		box = elem.getBoundingClientRect();
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},
	size: function() {
		return this.length;
	}
} );

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}



var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}

return jQuery;
}));

},{}],"/Users/youzi/dev/mtv-play/node_modules/json3/lib/json3.js":[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/Users/youzi/dev/mtv-play/node_modules/monotonic-timestamp/index.js":[function(require,module,exports){
// If `Date.now()` is invoked twice quickly, it's possible to get two
// identical time stamps. To avoid generation duplications, subsequent
// calls are manually ordered to force uniqueness.

var _last = 0
var _count = 1
var adjusted = 0
var _adjusted = 0

module.exports =
function timestamp() {
  /**
  Returns NOT an accurate representation of the current time.
  Since js only measures time as ms, if you call `Date.now()`
  twice quickly, it's possible to get two identical time stamps.
  This function guarantees unique but maybe inaccurate results
  on each call.
  **/
  //uncomment this wen
  var time = Date.now()
  //time = ~~ (time / 1000) 
  //^^^uncomment when testing...

  /**
  If time returned is same as in last call, adjust it by
  adding a number based on the counter. 
  Counter is incremented so that next call get's adjusted properly.
  Because floats have restricted precision, 
  may need to step past some values...
  **/
  if (_last === time)  {
    do {
      adjusted = time + ((_count++) / (_count + 999))
    } while (adjusted === _adjusted)
    _adjusted = adjusted
  }
  // If last time was different reset timer back to `1`.
  else {
    _count = 1
    adjusted = time
  }
  _adjusted = adjusted
  _last = time
  return adjusted
}

},{}],"/Users/youzi/dev/mtv-play/node_modules/ms/index.js":[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/cloud.js":[function(require,module,exports){
var Cloud = require('old-vigour-js/browser/network/cloud')
    .inject(
      require('old-vigour-js/browser/network/cloud/datacloud'),
      require('old-vigour-js/browser/network/cloud/authenticate')
    ),
  Value = require('old-vigour-js/value'),
  Data = require('old-vigour-js/data'),
  util = require('old-vigour-js/util'),
  cases = require('old-vigour-js/browser/cases'),
  ua = require('old-vigour-js/browser/ua'),
  raf = require('old-vigour-js/browser/animation/raf')

// var semver = require('old-vigour-js/util/semver')

require('old-vigour-js/value/flags/process') // mustbecome injectable on object ( all these extension should be located seperately )

function setClientInfo (cloud, base) {
  // todo: move client to cloud

  var client = cloud.data.get(['clients', cloud.clientid]),
    title, device, castId

  if (cases.ios) {
    title = ua.device === 'phone' ? 'iphone' : 'ipad'
    device = ua.device === 'phone' ? title : ua.device
  } else {
    if (ua.platform === 'appletv') {
      title = 'Apple TV'
      device = 'airplay'
    } else if (cases.chromecast) {
      title = 'Chromecast'
      device = 'chromecast'
      castId = window.sessionId
    } else {
      device = ua.device
      title = cases.desktop ? ua.platform : ua.platform + ' ' + device
    }
  }

  var obj = {
    title: title,
    device: device
  }
  if (castId) {
    obj.castId = castId || false
  }


  // console.log('hey set my client info mofo!')

  client.val = obj
  cloud.client.val = client

  // DEBUG LOGS: 
  // cloud.client.on(function(val, stamp, from){
  //   // console.log('\n\n\n\nupdate kenker', val, from)
  //   var origin = from || this._updateOrigin
  //   if(val && val.token || (origin && origin._name === 'token')) {
  //     console.error('TOKENSETTOKENSETTOKENSET', val && (val.token || val) )
  //   }
  // })

  // user.clientUserToken = user.client.from.get('userToken') deze is duidelijk fucked up and has to be fixed
}

exports.extend = util.extend( require('./values'), function (base) {
  var _cloud = new Cloud(new Value())
    , _first //= true
  
  cases.$connected = new Value( _cloud.connected )

  // todo: move to cloud
  _cloud.client = new Value()

  _cloud.once('welcome', function (id) {
    setClientInfo(_cloud, base)
  })

  // _cloud.on('reconnect',)
  // console.error('>>> adding reconnect listener')
  _cloud.on('reconnect', function() {
    // console.log('>>>> reconnect set up reset client info!', _cloud.client.from.raw)
    var setObj = {}
    _cloud.client.from.each(function(i) {
      if(i !== 'key' && i !== 'type' && i !== 'ip'){
        setObj[i] = this._val
      }
    })
    _cloud.client.from.on('remove', function() {
      if(Object.keys(setObj).length) {
        // console.log('reset dat client info', setObj)
        _cloud.data.clients.set(_cloud.clientid, setObj)
      }
    })
  })

  base.define({
    cloud: {
      get: function () {
        return _cloud
      },
      set: function (val) {
        if (util.isObj(val)) {
          if (val.fastLogin) {
            _cloud.fastLogin.val = true
          }

          if (val.api) {
            _cloud.api.val = val.api
          }

          if (val.url) {
            _cloud.url.val = val.url
          }
        } else {
          _cloud.url.val = val
        }
      }
    }
  })

  var _version = new Data( _cloud.data.get('app'), { subscription: { $:true } } )

  //semvar -- APP VERSION DOES NOT WORK!
  base.versionData = new Value({
    val: _version,
    defer: function(update, args) {
      var doUpdate
      var t
      if(this.from.version) {
        console.log('hey hey hey')
        if( !window.package ) 
        {
          console.error( 'no window package', window.package )
        }
        else 
        {
          var newversion = this.from.version.val
            , oldversion = window.package.version

          if(newversion && oldversion) {
            newversion = newversion.split('.')
            oldversion = oldversion.split('.')
            newversion = Number(newversion[1])
            oldversion = Number((oldversion[1]||0))
            if( newversion > oldversion ) {
              doUpdate = true
              this.clearCache()
              window.package.version = this.from.version.val
            }
          }
        }
      } 
      update( doUpdate ? void 0 : true )
    }
  })

})


},{"./values":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/values.js","old-vigour-js/browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/network/cloud":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/index.js","old-vigour-js/browser/network/cloud/authenticate":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/authenticate.js","old-vigour-js/browser/network/cloud/datacloud":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/datacloud.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","old-vigour-js/value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/content.js":[function(require,module,exports){
var Value = require('../value')
  , CloudData = require( '../browser/network/cloud/data' )
  , util = require('../util')

util.define
( CloudData
, '_contentPath'
, { get: function() {
      var p = this._path
      for(var i in p ) {
        if( p[i] === 'shows' || p[i] === 'channels' ) {
          return p.slice( i )
        }
      }

      console.error('_contentPath used on non-content data', this, p)
      // throw new Error('_contentPath used on non-content data')
      // return this._path.slice( base.instances[0].data.from._path.length )
    }
  }
)

exports.extend = util.extend( 
  require('./values')
, require('./cloud')
, function( app ) {
    var content = app.content = new Value({})
    // var get = Value.prototype.get
    util.define(content, 'get', function(){
        if( this._val && this._val.cloud ) { 
          return this._val.get.apply(this._val, arguments) 
        } else { 
          throw new Error( 'app.content , dont have cloud data!') 
        }
      })

    app.region.on(onChange)
    app.language.on(onChange)

    onChange()

    function onChange(){
      var region = app.region.val
        , language = app.language.val

      //TODO:make this configurable in the app
      if(language==='it') {
        language = 'en'
      }

      if(region && language){
        //TODO: make mtvData configurable
        content.val = app.cloud.data.get(['mtvData', region, language])
      }
    }
    
  }
)

},{"../browser/network/cloud/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/data.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","./cloud":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/cloud.js","./values":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/values.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/dictionary/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 */
var util = require( '../../util' )
var Element = require( '../ui/element' )
var Value = require( '../../value' )
var vObject = require( '../../object' )

Value.operators._dictionary = function( val, operator ) {
  return operator === false ? val : operator
}

//TODO: replace with a networkdata type value later -- get specific translations
//packer methods on .json files
//.json?path='text.blurf'

module.exports = exports = new Value( {} )

util.define(
  exports, 'get',
  function( val ) {
    if( exports.map && exports.map[ val ] ) {
      val = exports.map[ val ]
    }
    // exports.map[]
    return typeof val === 'string' && util.path( exports, [ 'responseData' ].concat( val.split( '.' ) ), '' )
  }
)

//set and listen to _dictionary (dictionary operator)
//just sets a flag to a thing in the dictionary
Value.flags.dictionary = {
  set: function( val, stamp ) {
    //TODO: if not there add a listener to exports
    // -- listener has one array updates when nessevary
    if( typeof val !== 'string' ) {
      //dictionary addListener!
      this.set( '_dictionary', {
        val: val,
        transform: function( val, cv ) {

          if( cv && cv.text ){
          	return cv.text
          }

          var dict = exports.get( cv )
          if( dict ) {
            if( dict instanceof vObject ) {
              exports.once( function() {
                val._update()
              } )
              return dict.val
            } else {
              return dict
            }
          }
        }
      } )

    } else {
      var g = exports.get( val )
      g._clearCache = true
      this.val = g
    }
  }
}

exports._name = 'dictionary'
  //more advanced things like creating the fields , creating possible maps


/* ------------ dictionary ------------ */

/*
//TODO:make dictionary init after ready
app.dictionary.val =
{ ajax: function( ajax, val ) {
    if( this.val ) {
      if( this._cached === this.val ) return;
      this._cached = this.val
      return this.val && config.dictionary( this.val )
    }
  }
, val: user.language
}

*/

},{"../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../ui/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 *
 * could think of something so style requires are parsed optionaly
 * maybe in vigour-js use dynamic script tags and parse those /w gaston if you are using gaston
 * this will make it more usable for others in the future and makes it compatible with pure browserify
 */

require('./style.less')
require('../browser/animation/easing')

var Element = require('../browser/element')
  , cases = require('../browser/cases')
  , animation = require('../browser/animation')
  , events = require('../browser/events/advanced')
  , ua = require('../browser/ua')
  , raf = require('../browser/animation/raf')
  , eventUtils = require('../browser/events/util')
  , app
  , _ios = ua.platform==='ios'
  , _windows = ua.platform === 'windows'
  , arr = ['phone','tablet','tv','desktop','ios','android','windows','mac','touch','slow','chromecast'] //maybe make this configrable
  //ui/cases --
  , i = arr.length - 1

//hier process in requiren en added 'appStart' ofzoiets dergelijks
//add ook process aan base dingen dan word iets pas geadd na een bepaalde process update
//ultra mofo powerfull

cases.iosBrowser = _ios && ('standalone' in navigator && !navigator.standalone) && !window.cordova
cases.iosFull = (!cases.iosBrowser && _ios) || ((_ios || _windows) && !!window.cordova) || false
cases.retina = window.devicePixelRatio > 1
cases.slow = (_windows && ua.device === 'phone') || (ua.noRaf&&ua.hasTransition) || _ios && (window.screen.height === (960 / 2)) || ua.device === 'tv'
cases.native = window.cordova ? true : false
cases.windowsMobile = ua.platform === 'windows' && ua.device === 'phone' && !!window.cordova
cases.crawler = (!cases.tv && !cases.native)

//packer case voor web // native

app = module.exports = new Element({
  'x,y':{ val:0,clean:true,translate:true }
, node: document.body
, w: window.innerWidth
, h: window.innerHeight
, css: 'app'
})

app.cases = cases

//if(cases.iosFull) {
  // app.y = {add:20}
  // app.h = {sub:20}
//}

var listener = function() {
//   console.log('resize!!','w:',window.innerWidth,'h:',window.innerHeight,'block?:',app.blockResize)
  if(!app.blockResize) {
    // animation.prevent = true
    app.w.val = window.innerWidth
    app.h.val = window.innerHeight
    // animation.prevent = false
  } else {
    app.blockResize = false
  }
}

function defaultCase(str) {
  if( cases[str] === void 0 ) {
    cases[str] = ( ua.device === str || ua.platform === str ) ? true : false
  }
  app.css = { addClass: cases[str] ? str : 'not-'+str }
}

// listener = eventUtils.throttle(listener,60)
// listener =
// cases.noCalc = !util.hasCalc()
//case too see if app is running in a browser on ios (limits video capabilities)

if(cases.touch) events.document.addEvent('move',function(e) {
  if(!events._maybescroll && !events._setscroll) e.preventDefault()
},'app')

if('orientation' in window) window.addEventListener('orientationchange',listener)
if(!_ios) window.addEventListener('resize',listener)

window.requestAnimationFrame(listener)
//adding #<case> in url forces case, multiple hashes ==> multiple cases
//this is for testing purposes , add development indentifier for compiler

//this has to go
if(window.location.hash) {
  var hashCases = window.location.hash.split('#')[1]
    , x = hashCases.split(',')

  for(var j in x) {
    var y = x[j].split('=')
    ua[y[0]] = y[1]
  }

}

if(ua.device === 'tv') {
  cases.slow = true
}

for(;i >= 0;) defaultCase(arr[i--])

},{"../browser/animation":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/index.js","../browser/animation/easing":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/easing.js","../browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","../browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","../browser/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","../browser/events/advanced":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/advanced.js","../browser/events/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js","../browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","./style.less":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/style.less"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/style.less":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/common.less"][0].apply(exports,arguments)
},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Element = require('../../../browser/element')

require('../../../value/flags/parent')
require('../../../value/flags/self')
require('../../../value/flags/process')
require('../../../value/flags/util')
require('../../../browser/events')

module.exports =
  Element
  .inject
  ( require('../../../browser/element/properties/collection')
  , require('../../../browser/element/properties')
  , require('../../../browser/element/properties/scrollbar')
  , require('../../../browser/element/properties/process')
  , require('../../../value/on')
  )


},{"../../../browser/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","../../../browser/element/properties":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/index.js","../../../browser/element/properties/collection":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/collection/index.js","../../../browser/element/properties/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/process.js","../../../browser/element/properties/scrollbar":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/scrollbar.js","../../../browser/events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js","../../../value/flags/parent":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/parent.js","../../../value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js","../../../value/flags/self":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/self.js","../../../value/flags/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/util.js","../../../value/on":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/on.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/sprite/index.js":[function(require,module,exports){
var Element = require('../element')
  , util = require('../../../browser/events/util') 
  , sprite = new Element({ 
    'w,h':50,
    x:{translate:true,val:0}
  })

sprite.extend({ name: 'params' //this has to come from ui (element)
  , type: false
  , set: function(val) {
    this._params = val
    this.Class.prototype._params = val //temp?
  }
})

sprite.setSetting({
  name:'spinner',
  render:function() {
    var t = this
      , params = this._params || {}
      , start = params.start || 0
      , speed = params.frames || 3
      , rows = params.rows || 1
      , cols = params.cols || 0 //ignore
      , once = params.once
      , cnt = start
      , steps = (params.steps || (rows*cols-start) || 19)
      , curRow = 0
      , curCol = 0

    if(!t.display || !t.display._base===t) {
      t.display = t.display && t.display.val || 'block'
    }
    t.display.addListener([displayListener,t],true)

    t.node.style.backgroundSize = this.w.val*cols+'px auto'
    //remeber where it was perhaps if re-rendered
    if(t.display.val==='none') return

    t._spinner = util.interval(function() { //test interval for leaks
      t.node.style.backgroundPosition = 
        (-t.w.val*curCol)+'px '+(rows ? (-t.h.val*curRow) : 0)+'px'
      cnt++
      if(cnt === steps) {
        cnt = start
        if(once) {
          // console.error('XXXXX')
          removeRaf.call(t)
          return
        }
      }
      curRow = rows ? ~~(cnt/cols) : 0
      curCol = cnt-(curRow)*cols
    },speed)
  },
  remove:removeRaf
})

function removeRaf() {
     // alert('lets remove this badboy')

  if(this._spinner) {
    this._spinner()
    this._spinner = null
  }
}

function displayListener (val) {
  if(val.val==='none') {
    removeRaf.call(this)
  } else {
    if(!this._spinner) this.setting('render')
  }
}

module.exports = sprite.Class



},{"../../../browser/events/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js","../element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/element/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Base = require('old-vigour-js/base')
  , Element = require('old-vigour-js/browser/element')
  , Value = require('old-vigour-js/value')
  , VObject = require('old-vigour-js/object')
  , switcher = new Element()
  , cases = require('old-vigour-js/browser/cases')

function extendFactory( field ){
  return { name:field
  , type:false
  , set:function( fn ){
      if(fn instanceof Function)
      {
        var set = {}
        set['_'+field] = fn
        this.define(set)
      }
      else
      {
        console.error('property ' + field + ' needs to be a function')
      }
    }
  }
}

Value.flags.$params = {
  set:function( val ) {
    this.params = val
  }
}

Value.flags.$options = {
  set:function( val ) {
    this.options = val
  }
}

switcher.extend
( { loader:{}
  , animation:{}
  , delay:{}
  , done:{}
  , force:{}
  , backFallback:
    { cache:false
    // , set:function(){}
    }
  , onTransition:
    { cache:false
    // , set:function(){}
    }
  , transition:
    { cache:false
    , set:function( val ){
        var element = val.element && val.element._val
          , params = val.params
          , options = val.options || {}
          , force = options && options.force
          , children = this.children
          , last = this._swElem || children[0]
          , base = element && element.base
          , childrenLength = children.length
          , current
          , child
          , direction
          , _this = this

        // if there are still old pages, remove these
        if( childrenLength > 1 )
        {
          for ( i = childrenLength - 1; i >= 0; i-- ) 
          {
            child = children[i]
            if( child !== last ) child.remove()
          }
        }

        //if there are old loading listeners remove these
        if( this._loading )
        {
          this._loading[1].removeListener( this._loading[0] )
          this._loading = void 0
        }

        // if( _this._timer ){
        //   clearTimeout( _this._timer )
        //   _this._timer = null
        // }

        // console.log('options?!'.green.inverse,options)
        //is it the same , is it not the same whatup!
        if( base && base instanceof Element || element === Element )
        { 
          if( !force && this._swElem && this._swElem instanceof element )
          {
            this._swElem.set( params )
          }
          else
          {
            direction = this._direction = val.direction && val.direction._val
            if( options && options.loader && !options.loader.$loaded )
            {
              if( !this.loader )
              {
                console.error( 'no loader defined!' )
                return
              }

              var loader = new this.loader._val.Class()

              if( options.loader instanceof VObject ) //TODO: this has gotten VERY dirty > clean this up!
              {
                options.done = function(){
                  if( !current ) current = new element( params )
                  if( loader._remove )
                  {
                    options.done = void 0
                    options.delay = cases.tablet ? 400 : 200 //dit is natuurlijk absurd
                    
                    if( _this._swElem instanceof element )
                    {
                      _this._swElem.set( params )
                    }
                    else
                    {
                      _this.onTransition._val.call( _this, current, _this._swElem , 0, options )
                    }
                    options.delay = void 0
                  }
                }

                var path = options.loader._path
                this._loading = [ function() {
                  // if( _this._timer ){
                  //   clearTimeout( _this._timer )
                  //   _this._timer = null
                  // }
                  loader._remove = true
                  if( current && options.done ) options.done()

                }, options.loader ]

                // console.log('add the listener for',path)
                this._loading[1].is('loaded', this._loading[0] )
                // _this._timer = setTimeout( this._loading[0], 5000 )
              }
              else
              {
                options.done = function(){
                  if( !current ) current = new element( params )

                  options.done = void 0
                  options.delay = 200

                  if( _this._swElem instanceof element )
                  {
                    _this._swElem.set( params )
                  }
                  else
                  {
                    _this.onTransition._val.call( _this, current, _this._swElem , 0, options )
                  }

                  options.delay = void 0
                }
              }

              options.loader = void 0

              this.onTransition._val.call( this, loader, last, direction, options)
            }
            else
            {
              current = new element(params)
              options.done = void 0
              options.delay = void 0
              options.loader = void 0
              
              this.onTransition._val.call( this, current, last , direction, options )
            }

            if( options.animation !== void 0 ) options.animation = void 0
            if( options.delay ) options.delay = void 0

          }
        }
        else if(params)
        {
          console.error('only params defined!', params)
        }
        else if(params)
        {
          console.error('no params and no element defined!')
        }
      }
    }
  }
)

switcher.define
({ back:function(){ //remove back logic from switcher (you can't isolate it! ie when you land on page, what is back?)
      this.backFallback._val.call( this )
		}
  , add:function( element, previous ){
      this._swElem = element
      // try
      // {
        Element.prototype.add.apply( this, arguments )
      // }
      // catch(err)
      // {
      //   console.error('error adding the new element',err,arguments)
      // }
    }
	}
)

switcher.extend
( { name:'on'
  , set:function( val ) {
      // set history variable for all
      // val.each(function(){
      //   var from = this.$userOrigin.val
      //   if(!from) return
      //   if(!from._history) from.set('history',true)
      //   if(!this.__checked)
      //   {
      //     this.on(function(){
      //       var caller = this._parent._caller
            
      //       if(!caller._backStore)
      //       { 
      //         caller._backStore = [ this ]
      //       }
      //       else if(caller._direction === -1)
      //       {
      //         if(caller._backStore[1] !== void 0) caller._backStore.shift()
      //         else caller._backStore = [ this ]
      //       }
      //       else if(caller._direction === 1)
      //       {
      //         caller._backStore.unshift( this )
      //       }
            
      //     })
      //     this.__checked = true
      //   }
      // })
    }
  , remove:function(){ // create refs to original
      if( this._loading )
      {
        this._loading[1].removeListener(this._loading[0])
        this._loading = null
      }
      
      if( this._swTimer ) clearTimeout( this._swTimer )
      if( this._timer ) clearTimeout( this._timer )

      if( this.on.$remove ) this.on.$remove.update()
    }
  , new:function(){
      if( this.on.$new ) this.on.$new.update()
    }
  }
)

module.exports = new switcher.Class().Class
},{"old-vigour-js/base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/switcher/transitions.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var app = require('old-vigour-js/app')
  , cases = require('old-vigour-js/browser/cases')
  , util = require('old-vigour-js/util')

exports.extend = util.extend(function(base) {
  base.set(
  { onTransition:
    { defer:function( update ){ //obscure transform
        if( exports[this._val] ) this._val = exports[this._val]
        update()
      }
    }
  })
})

//slide transition
exports.slide = function( current, last, direction, options ){
  if( direction && last ) animate( this, current, last, direction, options )
  else basic( this, current, last, direction, options )
}

//fade transition
exports.fade = function( current, last, direction, options ){    
  basic( this, current, last, direction, options )
}

//basic transition
function basic( _this, current, last, direction, options ){
  var done = options.done
    , noAnimation = options.animation === false
    , delay = options.delay

  if( last )
  {
    add( _this, current, last )

    if( noAnimation )
    {
      remove( _this, last )
      add( _this, current )

      if( done )
      {
        if( delay )
        {
          timer( _this, function(){
            if( options.done ) options.done()
          }, delay)
        }
        else done()
      }
    }
    else if( delay )
    {
      timer( _this, function(){
        fade( _this, last, options )
      }, delay)
    }
    else fade( _this, last, options )
  }
  else add( _this, current, false, done )
}

//animated transition
function animate( _this, current, last, direction, options ){
  var animationTime = 20 // make this configurable
    , appWidth = app.w.val
    , currentStart
    , forward = direction === 1
    , lastEnd

  if( forward )
  {
    currentStart = appWidth
    lastEnd = appWidth/-3
  }
  else
  {
    currentStart = appWidth/-3
    lastEnd = appWidth
  }

  if( cases.windows )
  {
    current.x = 
    { translate:true
    , val:currentStart
    }
    
    last.x =
    { translate:true
    , val:0
    }
    
    window.requestAnimationFrame(function(){
      current.x = 0
      last.x = lastEnd

      timer( _this, function(){
        remove( _this, last, options.done )
      }, 210 )
    })
  }
  else
  {
    current.x =
    { val:0
    , animation:
      { start:currentStart
      , time:animationTime
      , delay:1
      , easing:'outCubic'
      , done:function(){
          remove( _this, last, options.done )
        }
      }
    }

    last.x =
    { val:lastEnd
    , animation:
      { time:animationTime
      , delay:2
      , easing:'outCubic'
      }
    }
  }

  if( !forward ) add( _this, current, last )
  else add( _this, current )

}

function add( _this, toAdd, before, done ){
  if( toAdd ) _this.add( toAdd, before )
  if( done ) done()
}

function fade( _this, last, options ){
  last.opacity = 0
  last.node.pointerEvents = 'none'
  timer( _this, function(){
    remove( _this, last, options.done )
  }, 200)
}

function remove( _this, toRemove, done ){
  if( toRemove ) toRemove.remove()
  if( done ) done()
}

function timer( _this, fn, time ){
  if( _this._swTimer )
  {
    clearTimeout( _this._swTimer )
    _this._swTimer = null
  }
  _this._swTimer = setTimeout(function(){
    fn.call( _this )
    _this._swTimer = null
  }, time)
}
},{"old-vigour-js/app":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/tv/index.js":[function(require,module,exports){
// require('./style.less')

var Element = require('../../../browser/element')
  , cases = require('../../../browser/cases')
  , animation = require('../../../browser/animation')
  , events = require('../../../browser/events/advanced')
  , ua = require('../../../browser/ua')
  , raf = require('../../../browser/animation/raf')
  , util = require('../../../util')
  , Value = require('../../../value')
  , app = require('../../')
  , url = require('../../../browser/network/url')
  , lg = ua.platform ==='lg' && ua.device==='tv' 
//check bij allemaal events.$focused.val !!!!

// var cached2
var lgFixCnt = 0

//maak een array aan hiervoor

//app.focusState
url.on( function() {
  //nog een special voor als het in het menu staat!!! dan gewoon back
  //cached2
  // console.error( url.string.val, lgFixCnt )

  //url.string.val
  var arr = url.string.val.split( '/' )
    , str = Number( arr[arr.length-1] )

  if( str < lgFixCnt ) 
  {
    // cached2 = 
    lgFixCnt = str
    var $focused = events.$focused && events.$focused.val
    if( $focused && $focused.events) {
      if( $focused.events.back ) {
        $focused.events.back._val.call( $focused, { preventDefault: function(){} } )
      }
    }
  }
})

document.addEventListener( 'keyup' , function( e ) {
  e.preventDefault()
})

document.addEventListener( 'keydown' , function( e ) {

  var $focused = events.$focused && events.$focused.val
    , _events

  if( $focused && ! $focused._node ) {
    events.$focused.val = false
  } 

  if( $focused && $focused.events ) 
  {

    var map = {
      arrowLeft: [  37, 4  ]
    , arrowRight: [  39, 5 ]
    , arrowDown: [ 40, 29461 ]
    , arrowUp: [ 38, 29460 ]
    , click: [ 13, 29443 ]
    //if not LG!
    }

    if( !lg ) {
      map.back = [  8, 88, 'VK_BACK' ]
    }

    _events = $focused.events

    for( var event in map ) 
    {

      if( _events[ event ] 
       && util.checkArray( map[ event ], e.keyCode ) !== false 
      )
      {
        if( lg ) 
        {
          cached = url.string.val
          url.val = ( lgFixCnt++ ) 
        }
        e.preventDefault()
        _events[ event ]._val.call( $focused, e )
        return;
      }
    }

  }
})

events.arrowLeft = {
  val: function(e, method, val ) {
    method.call( this, e, val )
  } 
}
events.arrowRight = {
  val: function(e, method, val ) {
    method.call( this, e, val )
  } 
}
events.arrowUp = {
  val: function(e, method, val ) {
    method.call( this, e, val )
  } 
}
events.arrowDown = {
  val: function(e, method, val ) {
    method.call( this, e, val )
  } 
}
events.back = {
  val: function(e, method, val ) {
    //sepecial!
    //[  8, 88, 'VK_BACK' ]
    method.call( this, e, val )
  } 
}

util.define
( events
, '$focused'
, { value: new Value() }
)

exports.$focused = events.$focused

events.$focus = {
  val: function( e, method, val ) {
    method.call( this, e, val )
  }
}

util.define( Element, '$focus', function( from, remove ) {
  // console.log( 'select obj!!!!!', this )
  if( this.events && this.events.$focus ) {
    if(events.$focused.val) {
      events.$focused.val._$focused = null
      if(events.$focused.val._node) {
        events.$focused.val.events.$focus._val.call(events.$focused.val, false, true ) 
      }
      events.$focused.val = false
    }
    if( !remove  ) {
      events.$focused.val = this
      var _this = this
      _this._$focused = true
      
      // if(!exports.$focused.rafId) {
      // }

      // {
        // exports.$focused.rafId = raf(function() { 
      var _this = events.$focused.val
      if( _this && _this.events && _this._node ) {
        _this.events.$focus._val.call( _this, true, from )
        // exports.$focused.rafId  = null
      }
        // })
      // }
    }
  }
})

function selectSibling( direction ) {
  var nodeDirection = direction+'Sibling'
  return function nodeSearch() {
     if( this._node ) {
      var found = this._node[ nodeDirection ]
      if( found ) found = found.base
      if( found && found.events && found.events.$focus && (!found.display || found.display.val !== 'none' ) ) {
        return found
      }
      else if( found  && found._node) {
        var field = '$' + ( direction === 'previous' ? 'prev' : direction )
        return found[field].val
      }
    }
  }
}

Element.base.extend({
  $prev:function() {
    //use custom get hiero
  }
, $next:function() {

  }
})

Element.base.set(
{ $prev: selectSibling( 'previous' )
, $next: selectSibling( 'next' )
})


},{"../../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/index.js","../../../browser/animation":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/index.js","../../../browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","../../../browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","../../../browser/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","../../../browser/events/advanced":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/advanced.js","../../../browser/network/url":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/url.js","../../../browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/id.js":[function(require,module,exports){
var util = require('../../util')

require('../../value/flags/process')

exports.extend = util.extend
( function( base ) {
    // base
    base.extend
    ( 
      { id: function(val) {
          var id = val.val

          if( id && this.cloud ) 
          {
            this.data = this.cloud.data.get([ 'users', id ])
          } 
          else if( !id ) 
          {
            // this.data = void 0
            //TODO: this works buggy in values --- void 0 does not update data, maybe just use false for now
            console.log('base.mockdata')
            this.data = base.mockdata
          }
        }
      , data: {
          //mockdata on start can break everything down
          val: base.mockdata ,
          set:function( val ) {
            var user = this

            // if(!this.first) {
              // this.first = true
            // } else {

            if(user.instances && user.instances.length) {
              // console.error ('-- tmp fix data on base switch to instance[0]' )
              //TODO: this is a hacky solution! fix later
              user = user.instances[0]
            }

            if( val.from.cloud  ) 
            {
              if( user.___c !== val.from ) 
              {
                user.initialised = null
                user.___c = val.from
                for(var key in user.on.user) {
                  user.on.user[key].call( user, key )
                }
                user.initialised = true
              }
            }
            else 
            {
              if( user.___c === false ) return
              user.___c = false
              for(var key in user.on.user) {
                user.on.mock[key].call( user, key )
              }
              user.initialised = null
            }
          }
          // }
        }
      }
    )

})

},{"../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/index.js":[function(require,module,exports){
require('../../value/flags/self')
require('../../value/flags/process')
require('../../value/flags/util')
  //TODO: clean these to work /w inject

var util = require('../../util'),
  Value = require('../../value'),
  Base = require('../../base'),
  Data = require('../../data'),
  vObject = require('../../object').inject(
    require('./origin')
  ),
  timestamp = require('monotonic-timestamp'),
  _subscriptions = {},
  MockData = require('./mockdata'),
  mockdata = new MockData({})
  // make mockdata vailable

var _extend = Base.prototype.extend

var user = new Base({
  defaultType: require('./type')
})

user.define({
  subscriptions: {
    get: function () {
      return _subscriptions
    },
    set: function (val) {
      if (val) util.merge(_subscriptions, val)
    }
  },
  mockdata: {
    get: function () {
      return mockdata
    },
    set: function (val) {
      if (val) mockdata.merge(val)
    }
  },
  on: {
    value: {
      mock: {},
      user: {}
    }
  }
, extend: function( settings ) {

    if(settings.mock) {
      this.mockdata = settings.mock
    }

    var ret = _extend.apply(this, arguments)

    if(settings.val !== void 0) {
      this[settings.name] = settings.val
    }

    if( settings.on ) {

      if( typeof settings.on === 'function' ) {
        settings.on.call( this, settings.name ) 
      } else {
        if( this.data && this.data.cloud ) {
          settings.on.user && settings.on.user.call( this, settings.name ) 
        } else {
          settings.on.mock && settings.on.mock.call( this, settings.name ) 
        }
      }    
    }

    return ret
  }
})

// user

exports.extend = util.extend(
  require('../cloud'),
  function (base) {
    var appuser = base.user = new user.Class().inject(
      require('./set'),
      require('./id')
      //inject pas op extend???
    )
    appuser.parent = base
    appuser.cases = base.cases
    appuser.cloud = base.cloud
  }
)
},{"../../base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js","../../data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../../value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js","../../value/flags/self":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/self.js","../../value/flags/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/util.js","../cloud":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/cloud.js","./id":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/id.js","./mockdata":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/mockdata.js","./origin":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/origin.js","./set":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/set.js","./type":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/type.js","monotonic-timestamp":"/Users/youzi/dev/mtv-play/node_modules/monotonic-timestamp/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/mockdata.js":[function(require,module,exports){
var util = require('../../util')
  , Data = require('../../data')

module.exports = exports = Data.new()  

util.define( exports,
'get', function( val, set, notself ) {
  return this.path
  ( (val instanceof Array) ? val : String(val).split('.')
  , set !== void 0 ? set : {}
  , false
  , false
  , false
  , false
  , true
  , !notself
  )
})


},{"../../data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/multiscreen/cast/chrome/index.js":[function(require,module,exports){
// Q: how to read app config from vigour-js?

var config = require('old-vigour-js/util/config').chromecast
var cases = require('old-vigour-js/browser/cases')
var ua = require('old-vigour-js/browser/ua')
var Value = require('old-vigour-js/value')
var VObject = require('old-vigour-js/object')
var Data = require('old-vigour-js/data')
var xData = Data.new({
  merge: true,
  mixed: 4
})
var eventDeviceOnline = 'deviceDidComeOnline'
var eventDeviceOffline = 'deviceDidGoOffline'
var eventConnected = 'didConnectToCastApplication'

var castApi

if (typeof chrome === 'undefined') var chrome = window.chrome || {}

if (cases.ios && cases.native && !window.GoogleCast) {
  var f = {}
  window.GoogleCast = {
    startScanForDevices: function (e) {
      window.cordova.exec(function () {
        console.info('initiated Chromecast API')
      }, function (e) {
        console.error('can\'t initiate Chromecast API:', e)
      }, 'Echo', 'initCast', [e])
    },
    connectToDevice: function (e, t) {
      window.cordova.exec(function (s) {
        s ? t() : window.cordova.exec(t, function (e) {
          console.error('can\'t connect to Chromecast:', e)
        }, 'Echo', 'selectDevice', [e])
      }, function () {
        window.cordova.exec(t, function (e) {
          console.error('can\'t connect to Chromecast:', e)
        }, 'Echo', 'selectDevice', [e])
      }, 'Echo', 'isDeviceConnected', [e])
    }
  }
  var h = function () {
    window.cordova.exec(function (e) {
      var t
      e || (e = {})
      for (t in e) f[t] || (window.GoogleCast.dispatchEvent('deviceDidComeOnline', {
        id: t,
        friendlyName: e[t]
      }), f[t] = e[t])
      for (t in f) e[t] || (window.GoogleCast.dispatchEvent('deviceDidGoOffline', {
        id: t,
        friendlyName: f[t]
      }), delete f[t])
    }, function (e) {
      console.error('pollChromecast error:', e)
    }, 'Echo', 'getDevices', [])
    window.setTimeout(h, 1e4)
  }
  window.setTimeout(h)
}

module.exports = exports = window.curn = new Value({
  api: {
    defer: function (update, args) {
      var api = this
      var isSender = cases.native ||
        (cases.desktop && ua.browser === 'chrome')

      if (!isSender) {
        return true
      }

      var val = args[0]

      if (val === 'error') {
        return
      }

      if (!isSender || castApi) {
        return true
      }

      if (cases.native) {
        // console.log('CHROMECAST ait shwung dat api native > init')
        setTimeout(function () {
          exports.init(config.id)
        }, 0)

        castApi = true
        update()
      } else {
        // console.log('CHROMECAST ait shwung dat api')
        var script = document.createElement('script')
        script.onerror = function () {
          console.error('!!! script.onerror !!!')
          api.type = 'script'
          api.clearCache()
          api.val = args[0] = 'error'
          update()
        }
          // console.log('CHROMECAST script', config.web)
        script.src = config.web // config.chromecast.web
        script.id = 'chromecast-script'

        window['__onGCastApiAvailable'] = function (loaded, errorInfo) {
          if (loaded) {
            exports.init(config.id)
            castApi = true
            update()
          } else {
            api.clearCache()
            api.val = args[0] = 'error'
            update()
          }
        }
        document.getElementsByTagName('head')[0].appendChild(script)
      }
    }
  },
  clients: false,
  session: false,
  apiDefer: function (update, args) {
    var _this = this
    var val = args[0]
    if (_this.session.status === 'connected') {
      update('success')
    } else if (val !== true) {

    } else {
      update(true)
    }
  }
})

exports.devices = new VObject({})
exports.available = new VObject({})

exports.setReceiver = function setReceiver(client, cb) {

  var user = exports.user
  var loading = user.parent && user.parent.loading
  user.candidates.removeListener(lookForCast)
  user.candidates.on(lookForCast)
  if (loading) {
    loading.val = true
  }
  client.set('loading', true)

  exports.connect(client, function (err, session) {
    if (loading) {
      loading.val = false
    }
    client.set('loading', false)
    if (err) {
      return console.error('CHROMECAST setReceiver connect error', err)
    }
    if (cb) {
      cb(session)
    }
  })
}

function lookForCast() {
  var candidates = this
  var user = candidates._base
  var castclient = findChromeCast(candidates)
  if (castclient) {

    user.setReceiver(castclient)
    candidates.removeListener(lookForCast)
  }
}

exports.available.on(function () {
  var names = {}
  var change
  var user = exports.user

  if (!user || !findChromeCast(user.candidates)) {
    this.each(function (name) {
      names[name] = true
      if (!exports.devices[name]) {
        change = true
        exports.devices.set(this._name, this)
      }
    })

    exports.devices.each(function (name) {
      if (!names[name]) {
        change = true
        this.remove()
      }
    })

    if (change) {

    }
  }
})

exports._name = 'chromecast'

//init cast, start finding devices!
exports.init = function (applicationID) {
  // console.log('CHROMECAST init!', applicationID)
  this._init = true
    // console.error('CHROMECAST IOS? ', window.GoogleCast)
  if (window.GoogleCast) {
    //iOS
    // console.error('CHROMECAST IOS CALLING window.GoogleCast.startScanForDevices')
    window.GoogleCast.startScanForDevices(applicationID)

  } else if (chrome.cast && chrome.cast.SessionRequest) {
    //Android or Chrome
    var receiverListener, currentDeviceIDs
    if (cases.native) { //android native
      currentDeviceIDs = []
      receiverListener = function () {
        // get list
        var castList = chrome.cast.getRouteListElement().innerHTML

        if (!castList) return

        var castItems = castList.split('><'),
          newDeviceIDs = []

        // handle additions
        for (var i = castItems.length - 1; i >= 0; i--) {
          var item = castItems[i].split('"'),
            id = item[3]
          if (!~currentDeviceIDs.indexOf(id)) exports.dispatchEvent(eventDeviceOnline, {
            id: id,
            friendlyName: item[4].split('</li>')[0].substring(1)
          })

          newDeviceIDs.push(id)
        }

        // check for removals
        for (i = currentDeviceIDs.length - 1; i >= 0; i--) {
          id = currentDeviceIDs[i]
          if (!~newDeviceIDs.indexOf(id)) exports.dispatchEvent(eventDeviceOffline, {
            id: id
          })
        }

        // set current list
        currentDeviceIDs = newDeviceIDs
      }
    } else {
      // chrome
      receiverListener = function (e) {
        if (e === 'available') {
          exports.dispatchEvent(eventDeviceOnline)
        } else {
          exports.dispatchEvent(eventDeviceOffline)
        }
      }
    }

    var capabilities = [
      chrome.cast.Capability.VIDEO_OUT,
      chrome.cast.Capability.AUDIO_OUT
    ]
    var timeout = chrome.cast.timeout.requestSession
    var sessionRequest = new chrome.cast.SessionRequest(applicationID, capabilities, timeout)
    var sessionListener = function (session) {
      exports.session = session
      exports.val = session.sessionId
    }
    var autoJoinPolicy = chrome.cast.AutoJoinPolicy.TAB_AND_ORIGIN_SCOPED
    var defaultActionPolicy = chrome.cast.DefaultActionPolicy.CREATE_SESSION
    var apiConfig = new chrome.cast.ApiConfig(
      sessionRequest, sessionListener, receiverListener, autoJoinPolicy, defaultActionPolicy
    )

    chrome.cast.initialize(
      apiConfig,
      function () {
        // console.log("CHROMECAST chrome.cast.initialize cast:onInitSuccess") 
      },
      function (message) {
        console.error("CHROMECAST cast:onError: " + JSON.stringify(message))
      }
    )
  }
}

//connect to specific cast
exports.connect = function connect(client, cb) {


  var castid = client.castid.val
  var success = function (session) {
    console.log('CHROMECAST connect success!', session)
    if (cb) cb(null, session)
  }
  var error = function (error) {
    console.log('CHROMECAST connect error!', error)
    if (cb) cb(error)
  }

  if (window.GoogleCast) { // ios
    window.GoogleCast.connectToDevice(castid, success)
  } else if (cases.native) { // android
    try {
      chrome.cast._emitConnecting()
    } catch (e) {
      console.error('CHROMECAST Error in _emitConnecting ' + e)
    }
    try {
      cordova.exec(success, error, 'Chromecast', 'selectRoute', [castid])
    } catch (e) {
      console.error('CHROMECAST cordova.exec crash', e)
    }

  } else if (chrome.cast) { // chrome
    chrome.cast.requestSession(success, error)
  }
}

//dispatch events
exports.dispatchEvent = function (eventType, args) {
  var id = args ? args.id : 'unknown'
  var name = id.split('.').join('_').split('/').join('')
  var friendlyName = args && args.friendlyName ? args.friendlyName : id
  var set = {}

  if (friendlyName === 'unknown') {
    friendlyName = 'Chromecast'
  }

  if (eventType === 'deviceDidComeOnline') {
    set[name] = {
      title: friendlyName,
      device: 'chromecast',
      cast: 'chrome',
      castid: id
    }
    exports.available.val = set

  } else if (eventType === 'deviceDidGoOffline') {
    if (exports.available[id]) {
      set[id] = null
      exports.available.val = set
    }
  } else if (eventType === 'didConnectToCastApplication') {

  }
}

if (window.GoogleCast) { // ios
  window.GoogleCast.dispatchEvent = function (eventType, args) {
    exports.dispatchEvent(eventType, args)
  }
}


function findChromeCast(obj) {
  obj = getEndpoint(obj)
  var result
  obj.each(function () {
    var client = this.from
    if (client.device.val === 'chromecast') {
      result = client
      return true
    }
  })
  return result
}

function getEndpoint(obj) {
  while (obj && obj.__t === 4 && !obj._filter) {
    obj = obj._val
  }
  return obj
}

},{"old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/multiscreen/cast/index.js":[function(require,module,exports){
/*
* injectable 
* adds and manages (through sub-modules)
*   .casts: a live list of available cast devices
*/
var util = require('old-vigour-js/util')
var chrome = require('./chrome')

exports.extend = util.extend(function (user) {

  chrome.user = user

  user.extend({
    cast: {
      type: false,
      val: {}
    }
  })

  // user.devices.on(function(val, stamp){
  //   cast.devices.
  // })

  user.cast.chrome = chrome


  user.candidates.on(function(){
    // console.log('user.candidates.on: disjoin chrome.devices')
    util.disjoin(chrome.devices, user.candidates, 'device')
    // console.error('---------- check to put available back in devices')
    if(!hasChromeCast(user.candidates)) {
      // console.error('---------- no chromecasts in user.candidates')

      chrome.available.each(function(f){
        if(!chrome.devices[f]){
          // console.error('---------- set dat burk')
          didset = true
          chrome.devices.set(f, this)
        }
      })
      // if(didset) {
      //   chrome.devices.update()
      // }
    }
    user.devices._val._update()
  })

  chrome.available.on(function(){
    // console.log('chrome.available.on: disjoin user.candidates')
    util.disjoin(chrome.devices, user.candidates, 'device')
  })

  // console.log('PUSH DAT SOURCE TO DEVICES')

  user.devices._val.$sources.push(chrome.devices)

  // user.cast.set('chrome', chrome, true)
  // user.cast.set('dial', {})





  // user.cast.dial.on(function(){
  //   throw new Error('DIAL not supported yet')
  // })  

})

function hasChromeCast(obj){
  obj = getEndpoint(obj)
  var result
  obj.each(function(){
    return result = this.from.device.val === 'chromecast'
  })
  return result
}

function getEndpoint(obj){
  while(obj && obj.__t === 4 && !obj._filter){
    obj = obj._val
  }
  return obj
}

},{"./chrome":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/multiscreen/cast/chrome/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/multiscreen/index.js":[function(require,module,exports){
var util = require('old-vigour-js/util'),
  Value = require('old-vigour-js/value'),
  cases = require('old-vigour-js/browser/cases'),
  Data = require('old-vigour-js/data').inject(
    require('old-vigour-js/data/selection')    
  ),
  Compound = require('old-vigour-js/object/compound'),
  events = require('old-vigour-js/browser/events'),
  ua = require('old-vigour-js/browser/ua'),
  raf = require('old-vigour-js/browser/animation/raf')

var VObject = require('old-vigour-js/object')
VObject.inject(
  require('old-vigour-js/value/length')
)

var deviceIsCandidate = /(desktop)|(tv)|(cast)|(tablet)|(airplay)/i
cases.$isCandidate = deviceIsCandidate.test(ua.device)

var deviceIsTvLike = /(tv)|(cast)|(airplay)/i

require('old-vigour-js/value/flags/process')

exports.extend = util.extend(function (user) {

  var content = user.parent.inject(require('../../content')).content

  content.on('self', function() {
    if( user.token.val ) {
      if(user.receiver.media.val && user.receiver.media.from !== user.receiver.media ) {
        if(user.receiver.media.from!== content.get( user.receiver.media.from._contentPath )) {
          // console.error('lets go change it!', user.receiver.media)
          user.receiver.media.$userOrigin = content.get( user.receiver.media.from._contentPath )
        }
      }
    } 
  })

  // extend basic properties
  user.extend({
    receiver: {
      mock: {
        receiver: {
          volume: 1,
          media: false,
          playing: false
        }
      },
      subscription: {
        receiver: {
          volume: true,
          playing:true,
          media: {
            $: true
          }
        }
      },
      on: {
        mock: setMock_receiver,
        user: setUser_receiver
      }
    },
    clients: {
      subscription: {
        clients: {
          $: {
            $: true
          }
        }
      },
      on: {
        mock: setClients,
        user: setClients
      }
    },
    candidates: { val: {} },
    siblings: { val: {} },
    receiverClient: {
      val: {},
      on: {
        mock: setMock_receiverClient,
        user: setUser_receiverClient
      },
      subscription: {
        receiverClient:{
          $: true  
        }
      }
    },
    activeClient: {
      val: {},
      mock: {
        activeClient: true
      },
      subscription: {
        activeClient:{
          $: true  
        }
      },
      on: {
        mock: setMock_activeClient,
        user: setUser_activeClient
      }
    }
  })
  
  // extend devices (needs siblings)
  user.extend({
    devices: {
      val: new Compound(user.siblings)
    }
  })
  
  // extend case values
  user.extend({
    hasReceiver: {
      val: {
        val: user.receiverClient,
        transform: function(val, cv) {
          var endpoint = user.receiverClient.from
          return (
            endpoint && !endpoint._removed &&
            endpoint.cloud && endpoint._path[0] === 'clients'
          ) || 0
        }
      }
    },
    isReceiver: {      
      val: {
        defer: function(update, args){
          var origin = args[2] || this._updateOrigin
          if(!origin || 
             !(origin._prop || origin._name === 'receiverClient')
            ) {
            // console.log('block update', origin)
            return true
          }
          // console.log('no block')
          var stamp = args[1]
          if(stamp !== 'cleanup') {
            if(user._handleOldIsReceiver) {
              if( user._wasReceiver && 
                  !user.hasReceiver.val &&
                  !user.isActive.val
                ) {
                // console.error('i was receiver for this guy', user.data._val.raw)
                user.setReceiver(user.cloud.client.from)
              }
              user._handleOldIsReceiver = null
            }
            this.clearCache()
            user._wasReceiver = this.val
          }
          update()
        },
        val: user.receiverClient,
        transform: function(val, cv) {
          var endpoint = user.receiverClient.from
          return (
            endpoint && !endpoint._removed &&
            endpoint.cloud && endpoint === user.cloud.client.from
          ) || 0
        }
      }
    },
    hasCandidates: { 
      val: { 
        val: user.candidates.$length,
        $convertType: 'boolean'
      }
    },
    hasDevices: {
      val: { 
        val: user.devices.$length,
        $convertType: 'boolean'
      }
    },
    isActive: {
      val: {
        defer: function(update, args){
          // console.log('----- isActive check dat!')
          var origin = args[2] || this._updateOrigin
          if(!origin || 
             !(origin._prop || origin._name === 'activeClient')
            ) {
            // console.log('no blockit', 
            //   origin._path,
            //   origin,
            //   '\nval:', args[0]
            // )
            update(true)
            // return true
          }
          var stamp = args[1]

          if(stamp) {
            if(stamp !== 'cleanup') {
              if(user._handleOldIsActive) {
                if( user._wasActive && 
                    !( user.activeClient.$userOrigin && 
                       user.activeClient.$userOrigin._val
                     )
                  ) {
                  // console.error('i was activeClient for this guy RESET')
                  user.activeClient.$userOrigin = user.cloud.client._val
                }
                user._handleOldIsActive = null
              }
              this.clearCache()
              user._wasActive = this.val
            }
            
          }
          // console.log('go update!')
          update()
        },
        val: user.activeClient,
        // $bubble: {
        //   references: 2
        // },
        transform: function (c, cv) {
          var endpoint = user.activeClient.from
          return (
            (endpoint && endpoint.val === true) ||
            endpoint === user.cloud.client.from
          ) || 0
        }
      }
    },
    setReceiver: {
      type: false,
      val: function(client) {
        var user = this
        // console.error('setReceiver called lol')
        client = client.from
        if(!client) return

        var casttype = client.cast && client.cast.val

        if(casttype) {
          // console.log('setReceiver! user.cast[casttype]', user.cast[casttype])
          // console.log('setReceiver! user.cast[casttype].setReceiver', user.cast[casttype].setReceiver)
          user.cast[casttype].setReceiver(client)
        } else {
          client.set('token', user.token.val)
          user.receiverClient.$userOrigin = client
        }
      }
    }
  })
  
  // DEBUG:
  // user.activeClient.on(function(){
  //   console.error('activeClient happenin!', this.from && this.from.toString())
  // })
  
  // user.hasReceiver.on(function(){
  //   console.error('lol hasReceiver listener fires! val:', this.val)
  // })
  // user.isReceiver.on(function(){
  //   console.error('lol isReceiver listener fires! val:', this.val)
  // })
  // user.activeClient.on(function(){
  //   console.error('lol activeClient listener fires! val:\n', this.from.toString())
  // })

  // listeners:

  // on activity: make me activeClient
  if(!cases.chromecast) {
    var activeEvent = cases.tv ? 'keydown' : 'down'
    events.document.addEvent(activeEvent, function () {
      if( user.cloud.client._val &&
          !(cases.$isFullscreen && cases.$isFullscreen.val)
        ) {
        user.activeClient.$userOrigin = user.cloud.client.from
      }
    })  
  }
  

  // re-establish old setup after reconnect
  user.cloud.on('welcome', function(){
    if(user.cloud._status > 2){
      user._handleOldIsActive = true
      user._handleOldIsReceiver = true
      user.cloud.data.once(function(){
        // console.log('ok go reset dat old situation')
        user.isActive.update()
        user.isReceiver.update()
      })
    }
  })

  /*
  * when I become active, unset myself as receiver
  * and if not iplogin > select new receiver
  */
  user.isActive.on(true, function() {
    var isReceiver = user.isReceiver.val
    // console.log('isReceiver?!', isReceiver)

    if(user.hasCandidates.val) { //  && !user.iplogin.val
      // console.log('user.hasCandidates.val', user.hasCandidates.val)
      // console.log('isReceiver', 
      //   isReceiver, 
      //   '\nuser.hasReceiver.val', user.hasReceiver.val
      //   )
      if(isReceiver || !user.hasReceiver.val) {
        // console.log('ok select receiver because i became active!')
        var newreceiver = selectReceiver(user, user.candidates)
        if(newreceiver) {
          // wait for my own isactive set
          raf(function(){
            user.setReceiver(newreceiver)
          })
        } else if(isReceiver) {
          user.receiverClient.$userOrigin = null
        }
      }
    } else if(isReceiver){
      user.receiverClient.$userOrigin = null
    }
  })  
  

  // when receiver leaves, I might have to become the new receiver
  if(cases.$isCandidate) {
    user.hasReceiver.on(0, function(val, stamp, from){
      if(stamp === user.cloud.stamp) {
        // console.log('yes update is ok')
        if(!user.isActive.val){
          // wait for all removes to finish
          raf(function(){
            // select receiver
            // console.log('ok select receiver because receiver left!')
            var newreceiver = selectReceiver(user, user.clients)
            // if its me > update user
            if(newreceiver === user.cloud.client.from) {
              user.setReceiver(newreceiver)
            } else {
              // console.log('i am not new receiver! newreceiver is', newreceiver && newreceiver.raw)
            }
          })
        }
      } else {
        // console.log('update not from the cloud')
      }
    })
  }

  // when a tv joins, I might want to grab it
  if(!user.iplogin.val){
    user.candidates.on(function(val, stamp, from, remove, added){
      // console.error('-------- check for tv joiner')
      // console.log(user.candidates.toString())
      if(user.hasCandidates.val && user.isActive.val &&
          user.initialised
        ) {
        grabTV(user)
      } else {
        // console.error('no candidates')
      }
    })
  }

  
  // make cases
  cases.$isActive = user.isActive
  // cases.$hasCandidates = user.hasCandidates
  cases.$hasDevices = user.hasDevices
  cases.$hasReceiver = user.hasReceiver
  cases.$isReceiver = user.isReceiver


})

// clients
function updateClients() {
  this.clients.update()
}

function setClients () {
  var user = this
  var linked = user.data._val

  // clients
  var linkedclients = linked.get('clients')
  // cache old, set new, and remove listener if cached old
  var oldclients = user.clients._val
  user.clients = linkedclients
  linkedclients.addListener([updateClients, user], true)
  if( oldclients ) {
    oldclients.removeListener(updateClients, user)
  }

  // candidates
  // cache previouse value
  var oldcandidates = user.candidates && user.candidates._val
  // make candidates
  var candidates = user.candidates = new Data( linkedclients, {
    condition: { 
      device: {
        $contains: '(desktop)|(tv)|(cast)|(tablet)|(airplay)'
      },
      key: {
        $exists: true,
        $ne: this.cloud.clientid
      }
    }
  })
  // add listener because of reasons
  candidates.on(function(){
    user.candidates.update()
  })
  // clean up dat old selection
  if(oldcandidates) {
    oldcandidates.remove()
  }
  
  // siblings
  // cache previouse value
  var oldsiblings = user.siblings && user.siblings._val
  // make siblings
  var siblings = user.siblings = new Data( linkedclients, {
    condition: {
      key: {
        $exists: true,
        $ne: this.cloud.clientid
      }
    }
  })
  // add listener because of reasons
  siblings.on(function(){
    // console.log('update on candidates > update user.candidates')
    user.siblings.update()
  })
  // clean up dat old selection
  if(oldsiblings) {
    oldsiblings.remove()
  }
}

// activeClient

var acRemoveTarget
var acAddedTarget

function setMock_activeClient (i) {
  // console.log('setMock_activeClient')
  var user = this

  if(acRemoveTarget) {
    acRemoveTarget.removeListener(acRemoveCheck, user)
    acRemoveTarget = null
  }
  if(acAddedTarget) {
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
  }

  var linked = user.data._val

  user.activeClient = linked.get('activeClient', {})
  user.activeClient.$userOrigin = user.cloud.client.from

}



function setUser_activeClient () {
  // console.log('---------- setUser_activeClient!')

  var user = this

  // console.log('dat activeClient:', 
  //   user.data._val.activeClient
  //   ? 'yes activeclient\n' + user.data._val.activeClient.toString()
  //   : 'no activeClient in ma new user!!\n' + user.data._val.toString()
  // )

  if(acAddedTarget) {
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
  }
  
  var linked = user.data._val
  var linkedRef = linked.get('activeClient', {})

  if(acRemoveTarget) {
    acRemoveTarget.removeListener(acRemoveCheck, user)
  }
  acRemoveTarget = linkedRef
  acRemoveTarget.addListener([acRemoveCheck, user], true)

  user.activeClient = linkedRef
  
  // console.error('USERSWITCH ACTIVECLIENT')
  if(cases.tv) {
    // console.error('IM TV USERSWITCH WAT TO DO')
    // user.activeClient.$userOrigin = user.cloud.client.from
    // TODO: fix this:
    var activeClient = linkedRef.from
    // console.error('activeClient is', activeClient)
    // console.log('i am', user.cloud.client.from.raw)
    if(!(activeClient && activeClient._name !== 'activeClient')) {
      // console.error('set maself active')
      // console.error('SET ME TO DAT activeClient (TV)')
      user.activeClient.$userOrigin = user.cloud.client.from
    }else {
      // console.log('udpate activeClient because do it')
      user.activeClient.update()
    }
  } else if(!cases.chromecast) {
    // console.error('SET ME TO DAT activeClient')
    user.activeClient.$userOrigin = user.cloud.client.from
  } else {
    user.activeClient.update()
  }

  if(user.hasCandidates.val) {
    grabTV(user)
  }

}
function acRemoveCheck (firer, val, stamp, from, remove) {
  var user = this
  if(firer._removed) {
    if(acAddedTarget) {
      acAddedTarget.removeListener(acAddedCheck, user)
    }
    acAddedTarget = firer._parent
    acAddedTarget.addListener([acAddedCheck, user], true)
  }
}
function acAddedCheck (firer, val, stamp, from, remove, added) {
  var user = this,
    linkeduser = firer

  if(linkeduser.activeClient){
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
    
    acRemoveTarget = linkeduser.activeClient
    acRemoveTarget.addListener([acRemoveCheck, user], true)

    user.activeClient = linkeduser.activeClient
  }
}

// receiverClient
var rcAddedTarget
var rcRemoveTarget

function setMock_receiverClient () {
  var user = this

  if(rcAddedTarget) {
    rcAddedTarget.removeListener(rcAddedCheck, user)
  }
  if(rcRemoveTarget) {
   rcRemoveTarget.removeListener(rcRemoveCheck, user) 
  }

  var linked = user.data._val
  user.receiverClient = linked.get('receiverClient', false)
}
function setUser_receiverClient () {
  var user = this

  if(rcAddedTarget) {
    rcAddedTarget.removeListener(rcAddedCheck, user)
    rcAddedTarget = null
  }

  var linked = user.data._val
  var linkedRef = linked.get('receiverClient', {})

  if(rcRemoveTarget) {
    rcRemoveTarget.removeListener(rcRemoveCheck, user)
  }
  rcRemoveTarget = linkedRef
  rcRemoveTarget.addListener([rcRemoveCheck, user], true)

  user.receiverClient = linkedRef

  if(cases.tv) {
    // set tv to receiver if activeclient and no receiver
    var activeClient = user.activeClient.from
    if( activeClient && activeClient.__t === 2 &&
        activeClient !== user.cloud.client.from &&
        !user.hasReceiver.val
      ) {
      user.setReceiver(user.cloud.client.from)
    }
  } else if (cases.chromecast) {
    // always set chromecast to receiver
    user.setReceiver(user.cloud.client.from)
  }

}
function rcRemoveCheck (firer, val, stamp, from, remove) {
  var user = this
  if(firer._removed) {
    if(rcAddedTarget) {
      rcAddedTarget.removeListener(rcAddedCheck, user)
    }
    rcAddedTarget = firer._parent
    rcAddedTarget.addListener([rcAddedCheck, user], true)
  }
}
function rcAddedCheck (firer, val, stamp, from, remove, added) {
  var user = this,
    linkeduser = firer

  if(linkeduser.receiverClient){
    rcAddedTarget.removeListener(rcAddedCheck, user)
    rcAddedTarget = null

    rcRemoveTarget = linkeduser.receiverClient
    rcRemoveTarget.addListener([rcRemoveCheck, user], true)

    user.receiverClient = linkeduser.receiverClient
  }
}

// receiver
function setMock_receiver () {
  var user = this
  linkReceiver(user)
}
function setUser_receiver () {
  var user = this
  linkReceiver(user)
}
function linkReceiver (user) {
  var linked = user.data._val
    , linkedreceiver = linked.get('receiver', {})

  user.receiver = {
    volume: linkedreceiver.get('volume', 1),
    media: linkedreceiver.get('media', false),
    playing: linkedreceiver.get('playing', false)
  }
}

function selectReceiver(user, list) {
  // console.error('\n\n=========================selectReceiver!!!\n\n')
  while(list && list.__t === 4 && !list._filter){
    list = list._val
  }
  if(!list) {
    return console.error('could not determine list to select from')
  }
  var winner
  list.each(function(){
    var client = this._val
    // sanity check
    if(!client || client._removed || !client.device) {
      return console.error('bad client', 
        'path:', client && client._path,
        'client:', client && client.raw || client
      )
    }
    // skip if client is the activeClient
    if(client === user.activeClient.from) {
      return
    }
    var device = client.device.val
    // skip if client is not a candidate
    if(!deviceIsCandidate.test(device)) {
      return
    }

    // skip if client is in use by other user
    if(client.token && client.token.val !== user.token.val) {
      return
    }
    // client is a possible winner
    winner = client
    // stick if client is tv-like
    if(deviceIsTvLike.test(device)) {
      return true
    }
  })
  // console.error('\n\n========================= winner:',winner,user.cloud.clientid,'\n\n')

  return winner
}

function grabTV(user){
  // console.error('============= grabTV!')
  user.candidates._val.each(function(){
    var candidate = this.from
    // console.error('candidate', 
    //   'deviceIsTvLike', deviceIsTvLike.test(candidate.device.val),
    //   '!candidate.token', !(candidate.token && candidate.token.val),
    //   'candidate.token', (candidate.token && candidate.token.val)
    // )
    if(candidate.device.val === 'tv' &&
        !(candidate.token && candidate.token.val)
      ) {
      // console.error('grab dat!')
      candidate.set('token', user.token.val)
      if(!user.hasReceiver.val) {
        user.setReceiver(candidate)
      }
    }
  })
}

// function log(){
//   console.log('--------------------\n\n\n\n')
//   console.log(window.FLAG,':')
//   console.log.apply(console, arguments)
//   console.log('\n\n\n\n--------------------')
// }
// log.start = function(flag){
//   console.log('\n\n\n====================== START',
//     window.FLAG ? window.FLAG : '', flag, '\n\n'
//   )
// }
// log.end = function(flag){
//   console.log('\n\n====================== END',
//     window.FLAG ? window.FLAG : '', flag, '\n\n'
//   )
// }

},{"../../content":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/content.js","old-vigour-js/browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/browser/events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js","old-vigour-js/browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/data/selection":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/selection.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/object/compound":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/compound.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","old-vigour-js/value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js","old-vigour-js/value/length":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/length.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/navigation.js":[function(require,module,exports){
var util = require('old-vigour-js/util')
  , vObject = require('old-vigour-js/object')
  , MockData = require('./mockdata')

require('old-vigour-js/value/flags/process')

// content en switch op content pakken
//   media
//   show
//   season
//   niet last
// ook bubble: 1 op alle dingen
// function updateNavigation

exports.extend = util.extend
( function( user ) {

  var content = user.parent.inject(require('../content')).content

  content.on('self', function() {
    var nav = user.navigation

    var content = this

    var media = nav.media.from
      , season = nav.season.from
      , show = nav.show.from

    if(media._contentPath) {
      nav.media.$userOrigin.val = content.from.get(media._contentPath) //DIT IN NAVIGATION
    }

    if(season._contentPath) {
      nav.season.$userOrigin.val = content.from.get(season._contentPath) //DIT IN NAVIGATION
    }

    if(show._contentPath) {
      nav.show.$userOrigin.val = content.from.get(show._contentPath) //DIT IN NAVIGATION
    }
  })

  user.define({
    updateNavigation: function( key ) {
      if(this.navigation.last && this.navigation.last.$userOrigin) {
        key = key || this.navigation.last.$userOrigin.get('key').val
        if( typeof key === 'string' ) {
          this.navigation[key]._update( this.navigation[key]._val._val , 'l'+Math.floor(Math.random()*9999) )
          return
        }
      }
      
      this.navigation.page.$userOrigin = 'discover'
    }
  })

  user.extend({
    navigation: {
      mock: {
        navigation: 
        { show: false
        , page: false 
        , media: false
        , season: false
        , last: { key: 'page', time: 0 }
        }
      },
      subscription: {
        navigation: 
        { show:true
        , media:true
        , season:true
        , page:true
        , last: 
          { key:true
          , time:true
          }
       }
      },
      val: 
      { page: { defer: deferNavigation }
      , show: { defer: deferNavigation, val: false }
      , season: { defer: deferNavigation, val: false }
      , media: { defer: deferNavigation, val: false }
      },
      on: {
        user: function navigationToUserData( key ) {

          resolveLastListener(this)
          
          this.navigation = {
            last: this.data._val.get( [ key, 'last' ] )
          }
          this.__first = true

          var nav = this.navigation
            , userData = this.data.$userOrigin

          this._lastupdate = function lastUpdateUser( val, stamp, from ) {
            if( this.key && nav[this.key.val] )  
            {
              nav[this.key.val].$userOrigin._update( void 0, 'l'+stamp  )
            }
          }

          nav.last.from.on(this._lastupdate)

          // console.error('KEY',key)
          // debugger

          this.navigation = 
          { page: userData.get( [ key, 'page' ], 'discover' ) 
          , show: userData.get( [ key, 'show' ] )
          , season: userData.get( [ key, 'season' ] )
          , media: userData.get( [ key, 'media' ] )
          }

          if(nav.last.from.key) {

            // debugger

            nav.last.from._update( void 0, vObject.stamp() )
          } else if(!nav.last.from.key) {
            //no page switch to default ( make a default possilbe )
            nav.page.$userOrigin = 'discover'
          }

        },
        mock: function navigationToMockData() {

          resolveLastListener(this)
    
          var nav = this.navigation

           var mock = this.mockdata.navigation
            , set = 
              { page: mock.page
              , show: mock.show
              , season: mock.season
              , media: mock.media
              // , last: mock.last 
              }

          this.navigation = { last: mock.last }

          //TODO: this is a temp fix should go back to page you logout from!
          if(this.__first) {
            mock.page.val = 'discover'
          } 
    
          this._lastupdate = function lastUpdateMock( val, stamp, from ) {
            if( nav[this.key.val] ) 
            {
              nav[this.key.val].$userOrigin._update( void 0, 'l'+stamp  )
            }
          }

          nav.last.from.on( this._lastupdate )
          // var nav = hoe kom ik hier aan mn user???
          // console.error('?????',this.token._lval, this.token.val)
          // need to use setter (not nav ref)
          this.navigation = set
        }
      }
    }
  })

  function resolveLastListener( user ) {
    if( user._lastupdate 
        && user.navigation.last 
        && user.navigation.last.from !== user.navigation.last
     ){
      user.navigation.last.from.removeListener(user._lastupdate)
      user._lastupdate = null
     }
  }      

  function deferNavigation( update, args ) {
    if( args[1] && args[1][0] === 'l' && 
      this._name === this._parent.last.from.key.val
    ) {
      this.clearCache()
      update()
    } 
    else 
    {
      update( true )
    }
  } 

})

},{"../content":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/content.js","./mockdata":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/mockdata.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/origin.js":[function(require,module,exports){
//userOrigin
var util = require('../../util')
  , MockData = require('./mockdata')
  , timestamp = require('monotonic-timestamp')

exports.extend = util.extend( function( vObject ) {

  var _coreSet = vObject.set
    , _fromUser = function( obj ) {
        var val = obj
          , nav
          , last

        while (val && !val._removed && val instanceof vObject) {

          if( val._parent && val._parent._prop && val._parent._prop.name === 'navigation' ) {
            nav = val
          } 

          if( ( val.cloud && val._path[0] === 'users' ) 
              || val instanceof MockData 
            ) {
            return [ val, nav ]
          }
          last = val;
          val = val._val;
        }

        var result = last && !last._removed && last !== obj
          ? last 
          : false

        return [ result, nav ]

      }

  util.define( vObject, 
    '$userOrigin', {
    set: function( val ) {

      var search = _fromUser(this)
        , found = search[0] //|| this
        , nav = search[1]
        , same

      if(!found) {
        var propname = this._prop && this._prop.name

        if(propname) {
          // console.error('>>>>>>>> making and linking', propname)
          var user = this._caller,
            linkeduser = user.data._val

          found = linkeduser.get(propname, {})
          this.val = found
        }
      } else {
        // console.error('FOUND', this._prop && this._prop.name, found._path, found.raw, found)
      }

      if(!found) {
        throw new Error('cannot find correct $userOrigin for '+ ( this._name || this._prop && 'propety '+this._prop.name ) )
      }

      _coreSet.call( found , val)

      if(nav && nav._name ) {
        nav._parent.last.from.val = 
        { time: timestamp()
        , key: nav._name
        }
      } 

    },
    get: function() {
      return _fromUser( this )[0] //|| this
    }
  })
})
},{"../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./mockdata":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/mockdata.js","monotonic-timestamp":"/Users/youzi/dev/mtv-play/node_modules/monotonic-timestamp/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/set.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var util = require('../../util')
  , user = require('./')
  , vObj = require('../../object')

exports.extend = util.extend( 
function( base ) {

  function setUser(i) {
    //make these 2 more defualt
    // console.log(i)
    // console.log( 'swtich to user', i, this.data._val )
    this[i] = this.data.$userOrigin.get( i, this[i]._prop.$default )
  }

  function setMock(i) {
    // console.log( 'swtich to mock', i, this.mockdata[i] )
    this[i] = this.mockdata[i]
  }

  base.define({
    _set: function(val, i ) 
    {
      if ( this[i] instanceof vObj ) 
      {
        //TODO: torough testing
        this[i].val = val[i]
      } 
      if (typeof this[i] === 'function') 
      {
        if (val[i] instanceof Array) 
        {
          this[i].apply(this,val[i])
        } else 
        {
          this[i](val[i])
        }
      } 
      else 
      {
        if ( this.isProperty( i, val ) ) {
          // console.warn('this is a property!', i , val )
          this[i] = val[i]
        } else {
          if( this[i] ) 
          {
            // merge? check ook voor cloud bijvoorbeeld
            this[i] = val[i]
          }
          else 
          {
            // console.error('NOW LETS MAKE A BASIC TYPE', i, this)

            var mock = {}

            mock[i] = val[i]

            var subscription = {}
            subscription[i] = true

            // this.mockdata = mock

            this.extend({
              name:i
            , mock: mock
            , $default: val[i]
            , subscription: subscription //maybe do this if not specified
            , on: {
                mock: setMock
              , user: setUser
              }
            })

            //dit beter---- moet namelijk niet val[i] worden maar mockdata (of meteen switchen naar userData)
            
           

          }
        }

        // console.log('hey', i, this[i] )
        
      }
    }
  })

})
},{"../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/token.js":[function(require,module,exports){
var util = require('../../util')
  , Value = require('../../value')
  , cases = require('../../browser/cases')

require('../../value/flags/process')

//TODO: url error on start up (set from cloud)
exports.extend = util.extend
( function( base ) {

  base.define({
    updateId: function( res ) {
      this.id = res instanceof Array ? res[ res.length -1 ] : res
      
      //hier ff voor navigation
      //get last?
    }
  , authenticate: function authenticate( _this, request, val, update ) {
      var user = this
        , cloud = user.cloud

      if(cloud.params.fastLogin && typeof localStorage !== "undefined"){
        var userId = localStorage.getItem('userId')
        if(userId){
          request.id = userId
        }
      }
      // console.log('go cloud.authenticate!!')
      cloud.authenticate( request, function( res ) {
        
        if(res.error && typeof localStorage !== "undefined"){
          localStorage.removeItem('userId')
        }
        _this.clearCache()

        if(val !== _this.val){
          // console.error('\n\n\ndid a fast re-login! -- double check')
        }

        if( res.error || !_this.val ){
          _this.val = false
          user.id = false
          update()
          if( res.error ){
            console.error('authenticate error:', res.error)
          }else{
            if(! (user.iplogin && user.iplogin.val) ){
              user.cloud.emit('logout', res )

              if(typeof localStorage !== "undefined" ){
                localStorage.removeItem('userId')
              }
            } 
            // console.error('token is set to false while authenticating (logout! -- need to get a method to break it while in progress)')
          }
        }else{
          // console.log('AUTH SUC6', user, res )
          //dit is ook wrong completely! -- dit alleen doen met een usertoken!!!!
          // anders wachten tot een overtake actie
          if( _this.val !== true ) {
            user.updateId( res )
          }

          if(cloud.params.fastLogin && typeof localStorage !== "undefined"){
            var userId
            if(res instanceof Array)
              userId = res[res.length-1]
            else
              userId = res
            localStorage.setItem('userId', userId)  
          }

          if(user.iplogin && user.iplogin.val) {
            // console.log('TV LOGIN SUCCESS! maybe go make maself dat user')
            // console.log('>>> token', user.token.val)
            
          }
          
          update()
        }
      })
    }
  })
  
  // console.log('????????????? set iplogin', cases.tv || cases.chromecast)
  // base.iplogin = cases.tv || cases.chromecast
  
  base.extend(
  { //primary
    iplogin: { val: cases.tv || cases.chromecast },
    token:{
      // TODO: when IP based connectivity is fixed this is not needed
      subscription: {
        token: true
      },
      val:{
        transform: function( val, cv ) {
          return ( cv instanceof Object ) ? false : cv
        },
        defer:function( update, args, tempdefer ) {

          if(args[0] && args[0].defer) return true

          var token = this
          var user = token._caller

          // console.error('TOKEN SET!xxx', token)

          user.cloud.connected.is(true, function() {
            var oldval = args
              , val = token.val
              , userId = user.id && user.id.val
              , iplogin = user.iplogin && user.iplogin.val

            // if( user.iplogin && user.iplogin.val ){
            //   iplogin = true
            // }
            //DOUBLE CHECK --- this was in there to allways make sure this stuff did not happen...
            // if( user.activeClient && user.activeClient.$userOrigin && user.activeClient.from === user.client.from  ) {
              // console.log('mc dirty lets fix this here! on logout set false to be certain', user.activeClient.$userOrigin )
              // user.activeClient.$userOrigin = false
            // }

            token.clearCache()

            // console.error('token is set!', val)
            // console.log('token is set!', iplogin)

            if( userId && !iplogin ){
              // console.log('LOGOUT ---> EMIT'.red.inverse, userId )
              var _last = user.cloud.logout( userId )
              if(typeof localStorage !== "undefined"){
                localStorage.removeItem('userId')
              }
            }

            if( val ){

              var url = user.cloud.api.get('auth')

              if( !url ) {
                throw new Error('could not determine auth url (got: ' + url + ')')
              }

              var request = 
              { url: user.cloud.api.auth.val
              , subs: user.subscriptions
              , token: val
              //TODO: also add tv
              }
              , auth = user.__authenticated__

              if( iplogin ){
                // this is all tv vibes
                if( val === true ) {
                  delete request.token
                }
                request.tv = true

                if( !auth ){
                  // console.log('IPLOGIN FIRST TIME POP DAT AUTHENTICATE')
                  user._authrequest = request
                  user.authenticate( token, request, val, update )
                  user.__authenticated__ = true
                }else{
                  var users = user.cloud.data.get('users')
                    , set

                  // console.error('IPLOGIN USERSWITCH')
                  // find the user I should switch to
                  users.each(function( key ) {

                    // console.log('>> HAVE USER', this)
                    var clouduser = this

                    if(clouduser.token && clouduser.token.val === token.val) {
                      // im switching to this user
                      set = clouduser._name
                      // console.log('switch to this usert!')
                    } else {
                      if(
                        clouduser.receiverClient && 
                        clouduser.receiverClient.from === user.cloud.client.from
                        ){
                        // console.error('this other user has me as receiverClient, better remove')
                        clouduser.receiverClient.$userOrigin = null
                      }
                      if(clouduser.activeClient && 
                        clouduser.activeClient.from === user.cloud.client.from
                        ){
                        // console.error('this other user has me as receiverClient, better remove')
                        clouduser.activeClient.$userOrigin = null
                      }
                    }
                  })
                  if(!set) {
                    user.id = false
                  }else{
                    user.id = set

                  }
                  update() 
                }

              }else{
                user._authrequest = request
                user.authenticate( token, request, val, update )
              }
            }else{
              user.id = false
              update() 
            }
          })
        }
      }
    },
    localStorageToken: {
      val: {
        defer:function(update, args) {
          var user = this._caller
          if(!user._readLocalStorage && typeof this.val === 'string') {
            user._readLocalStorage = this.val
            var token = localStorage.getItem(user._readLocalStorage)
            if(token && token !== 'true') {
              // console.error('TOKEN SET!', token)
              user.token = token
            }
            user.token.on(function() {
              var tokenval = this.val
              if(typeof tokenval === 'string') {
                localStorage.setItem(user._readLocalStorage, tokenval)
              } else {
                localStorage.removeItem(user._readLocalStorage)
              }
            })
            update()
          } else {
            update(true)
          }
        }
      }
    }
  })

  // base.token = false

  base.cases.$isLoggedIn = new Value(
  { val: base.token
  , transform:function(val, cv) {
      if(cv === true) return 0
    }
  })

  var myclient = base.cloud.client

  myclient.on(function(val, stamp, from){
    // console.log('something happened on my cloud client!')
    origin = from || this._updateOrigin
    if(stamp === base.cloud.stamp) {
      var cloudclient = myclient.from
      if(cloudclient.token){
        // console.log('-------- token on user is now', base.token.val, 'set with', cloudclient.token.val)
        base.token.val = base._authrequest.token = cloudclient.token.val

        // console.log('-------- did set token on user')
      }
    }
  })

  base.token._name = 'token'

})




},{"../../browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../../value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/type.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../../base')
  , Value = require('../../value')//.new()
  , objectSet = require('../../object').set
  , util = require('../../util')

// Value.inject(require('./listen_fix'))

module.exports = {
  type: Value,
  create: function(val, prop, settings, noupdate) {

    // console.log('create it', val, settings )
    var v = new Value()
    v._base = this
    v._caller = v._base
    v._prop = settings
    // console.log('set')
    objectSet.call(v, val, false, false, true)
    // console.log('done setting')
    if (this._class) this._class.prototype._[settings.name] = v
    if (settings) {

      if (!settings._vset) {

        //can also add a thing to set on get by default?

        if(settings.mock) {
          //if not set add some efficiency plz
          this.mockdata = settings.mock
        }

        if(settings.subscription) {
          this.subscriptions = settings.subscription
        }

        if(settings.on) {
          if( typeof settings.on === 'function' ) {
            this.on.mock[settings.name] = settings.on
            this.on.user[settings.name] = settings.on
          } else {
            if(settings.on.mock && !this.on.mock[settings.name]) {
              // console.log(base, base.on)
              this.on.mock[settings.name] = settings.on.mock
            }
            if(settings.on.user && !this.on.user[settings.name]) {
              this.on.user[settings.name] = settings.on.user
            }
          }
        }

        settings._vset = function(stamp, from, remove, cval) {
          
          var base = this._caller
                || this._base
                || this


          //if !base --
          // if(!base.)

          if(settings.set) {
            settings.set.call(
              base, this, stamp, from, remove, cval
            )
          }
        }
      }

      if (!noupdate) {
        // console.log('UPDATE creation')
        v._update(val)
      }
    }
    return v
  },
  set: function(val, prop, settings) {
    // console.error('set it', val )
    this._caller = this
    return val
  },
  get: function(prop, settings) {
    if (prop) prop._caller = this
    if (settings.get) return settings.get.call(this, prop)
    return prop
  }
}
},{"../../base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js","../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/url.js":[function(require,module,exports){
var util = require('old-vigour-js/util')

require('old-vigour-js/value/flags/process')

//TODO: url error on start up (set from cloud)
exports.extend = util.extend
( function( base ) {

  //TODO: add remove setting
  base.extend(
  { url: function( val ) {
      if( !val.urlset && val.__t === 4 )
      {
        val.urlset = true
        var _this = this

        _this.navigation.page.on( function(e) {
          val.from.val = _this.navigation.page.val
        })

        _this.navigation.show.on( function(e) {
          val.from.val = _this.$parse( this ).url
        })

        _this.navigation.media.on( function() {
          val.from.val = _this.$parse( this ).url
        })

        val.from
          .on( function( ) {
            //urlMap ook reparse setup
            // console.log('update from url!'.gree.inverse)
            _this.$execUrl()
          })

      } else {
        // console.warn( 'ui.user: no url!' )
        //console.log() use deze voor updates?
      }
    }
  })

  base.define({
    $execUrl: function( defaultUrl ) {
      var _this = this

     var url = _this.url.from.string.val
       , nav = _this.navigation
       , data = _this.parent.content
       , urlArray
       , show
       , season
       , media
       , channel

      if(!url || url === '$tv') url = defaultUrl

      if( !~url.indexOf( '/' ) )
      {
       nav.page.$userOrigin = url
      }
      else if( url.indexOf( 'shows' ) === 0 )
      {

       urlArray = url.split( '/' )
       show = Number( urlArray[1].split( '-' )[0] )
       if( urlArray[2] ) season = Number( urlArray[2] )
       if( urlArray[3] ) media = Number( urlArray[3].split('-')[0] )

       if( show ) {
          show = data.from.get( [ 'shows', show ] )
          nav.show.$userOrigin = show
       }

      if( media ) {
        media = data.from.get( nav.show.from._path.slice(3).concat( [ 'seasons', String( season-1 )  ,'episodes', String( media-1 ) ] ) )
        nav.media.$userOrigin = media
      }

      }
      else if( url.indexOf('channels') === 0 )
      {
      urlArray = url.split( '/' )
      channel = Number( urlArray[1].split( '-' )[0] )
      // console.error('channel')
      // debugger
      nav.page.$userOrigin = 'channels'
      }
    },
    $parse: function( data ) {

      var old = this.url.val

      var type =  data.from._parent && data.from._parent._name
        , parsed = {}

      if( data.from ) {
        parsed.title = data.from.get( 'title', false).val
        if( type === 'episodes' ) {
          parsed.season = Number( data.from._parent._parent._name )+1
          parsed.media = Number( data.from._name )+1
          parsed.show = data.from._parent._parent._parent._parent
        }
        if( type && this.urlMap[ type ] ) {
          parsed.url = this.urlMap[ type ]( data, parsed )
        } else {
        }
      }

      // if( old ) {
      //   var x = old+'/'
      //   if(x.replace(/-[a-z0-9+]+\//g, '/') === parsed.url+'/') {
      //     parsed.url = old
      //   }
      // } else {
      //   console.warn('block url update! DOUBLE CHECK THIS -- should not happen ( too fast url settings prop in shows)')
      //   parsed.url = window.location.href
      //               .replace(String(window.location.origin) + '/', '')
      //               .replace(/^#\//, '')
      // }

      return parsed
    }
  , urlMap: {
      value: {
        episodes: function( data, parsed ) {
          var title = parsed.title
            , str = this.shows( parsed.show )
                  + '/'+parsed.season
                  + '/'+parsed.media
          if( title ) str += '-'+title
          return str && str.replace(/ /g, '+').replace('?', '')
        }
      , shows: function( data, parsed ) {
          var title = parsed
              ? parsed.title
              : data.get('title', false).val
          , id = data.from._name
          , str = 'shows/'+id
          if( title ) str += '-'+title
          return str && str.replace(/ /g, '+').replace('?', '')
        }
      }
    }
  })

})

},{"old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/usage.js":[function(require,module,exports){
var util = require('old-vigour-js/util')

var vObject = require('old-vigour-js/object')

var MockData = require('./mockdata')

var cases = require('old-vigour-js/browser/cases')

var Data = require('old-vigour-js/data')
      .inject( require('old-vigour-js/data/selection') )


require('old-vigour-js/value/flags/process')

exports.extend = util.extend
( function( user ) {

  var content = user.parent.inject(require('../content')).content

  user.extend({
    usage: {
      mock: {
        usage:{}
      },
      subscription: {
        usage: {
          shows: {
            $: {
              media:{
                //dit moet sowieso niet title worden! liever gewoon true of id ofzo
                $:true
              },
              favourite:true,
              timestamp:true
            }
          }
        }
      },
      on: {
        mock:function() {
          this.usage = this.mockdata.usage
        },
        user:function() {
          this.usage = this.data.from.get('usage',{})
        }
      }
    },

    watched:{
      on: {
        //mischien eigen , nieuwe selection maken alvast
        mock: function() {
          if(this.__watched) {
            this.__watched.remove()
            this.__watched = null
          }
          if(this.watched) this.watched.$empty()
          this.watched = {}
        },
        user:function() {
          var user = this
          if(this.__watched) {
            this.__watched.remove()
            this.__watched = null
          }

          var selection = this.__watched = new Data( user.usage.from.get('shows') , {
            condition: { 
              media: {
                title: {
                  $exists: true
                }
              }
            }
          })

          user.watched = {}

          selection.on(function() {
            var sets = {}

            selection.each(function(i) {
              var bla =  content.get(this._path.slice(-2))
              var obj = {}
              
              util.path(obj, bla._path, {
                img:true,
                title:true
              })

             var _cloud =  user.parent.cloud
             _cloud.subscribe(obj)

              user.watched.set(this._name, 
              { show: bla
              , media: this.media.from
              })

              user.watched[this._name].once('remove', function() {
                _cloud.unsubscribe(obj)
              })

              sets[this._name] = true
            })

            user.watched.each(function(name) {
              if(!sets[name]) {
                if(user.watched)
                this.remove()
              }
            })

            sets = false

            user.watched.update()
          })
          selection._update()

        }
      } 
    },

    favourites:{
      on: {
        //mischien eigen , nieuwe selection maken alvast
        mock: function() {
          if(this.__favourites) {
            this.__favourites.remove()
            this.__favourites = null
          }
          if(this.favourites) this.favourites.$empty()
          this.favourites = {}
        },
        user:function() {
          var user = this
          if(user.__favourites) {
            user.__favourites.remove()
            user.__favourites = null
          }
          this.favourites.$empty()
          var selection = user.__favourites = new Data( user.usage.from.get('shows') , {
            condition: { 
              favourite: true
            }
          })

          user.favourites = {}

          selection.on(function() {
            var sets = {}

            selection.each(function(i) {
              var bla =  content.get(this._path.slice(-2))

              user.favourites.set(this._name,bla)
              sets[this._name] = true
            })

            user.favourites.each(function(name) {
              if(!sets[name]  ) {
                this.remove()
              }
            })

            sets = false

            user.favourites.update()
          })
          selection._update()

        }
      } 
    }
  })

  user.extend({
    hasWatched: {
      val: {
        val: user.watched,
        transform: hasTransform
      }
    },
    hasFavourites: {
      val: {
        val: user.favourites,
        transform: hasTransform
      }
    }
  })

  var oldContent = content._val

  content.on('self', function() {
    // console.log('content is changing from', oldContent && oldContent._path, 'to', this._val._path)
    if( user.token.val ) {
      resolveWatchedMedia( user )
      user.favourites._prop.on.user.call(user)
      user.watched._prop.on.user.call(user)
    } else {
      resolveWatchedMedia( user )
      user.favourites._prop.on.mock.call(user)
      user.watched._prop.on.user.call(user)
    }
  })

  cases.$hasFavourites = user.hasFavourites
  cases.$hasWatched = user.hasWatched

})

function resolveWatchedMedia( user ) {
  user.watched.from.each(function() {
    var media = this.media && this.media.from
    if(media) {

      var newPath = user.parent.content.from._path.concat( media._contentPath )       
      var oldPath = media._path

      if( !util.compareArrays( oldPath, newPath ) ) {
        console.log('resolve', oldPath, newPath)
        this.media.val = user.parent.content.get( newPath )
      }
    }
  })
}

function hasTransform( c, cv) {
  var selection = c._parent._val
  if(selection) {
    if(selection.$length.val>0) {
      return true
    }
  }
  return 0
}
  
},{"../content":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/content.js","./mockdata":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/user/mockdata.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","old-vigour-js/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","old-vigour-js/data/selection":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/selection.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/values.js":[function(require,module,exports){
var config = require('../util/config')
var languages = config.languages
var util = require('../util')
var Value = require('../value')
var url = require('../browser/network/url')
var ua = require('../browser/ua')

require('../value/flags/process')

//---------------------------------------


//---------------------------------------

exports.extend = util.extend(function(app) {

  //use cases reference on app
  var cases = app.cases || (app.cases = equire('../browser/cases'))

  app.initialised = new Value(false)

  app.overlay = new Value(false)

  app.focusState = new Value('menu')

  app.region = new Value({
      init: app.initialised
    })
    //browser
    //ua.browser

  app.url = ua.device === 'tv' && ua.platform === 'lg' ? new Value({
      defer: function() {},
      params: {},
      string: ''
    }) : url
    //ook pas op app initilised!

  app.ready = new Value()

  app.menu = new Value({
    init: app.ready
  })

  //TODO:network
  //move network api file to here perhaps
  app.network = new Value()

  //TODO: double check this is efficient
  app.loading = new Value({
    init: app.ready,
    defer: function(update, args) {
        //TODO: cached updatePath ?
        var id = this.updatePath.join('.')
        if (args[0] === false && ((id && id === this.id) || !this.id)) {
          this.val = args[0]
          this.id = false
        } else if (args[0] === true) {
          this.id = id
          this.val = true
        }
        update()
      }
      //add defered later (maybe dont show a loader for less then xxx sec)
  })

  // '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
  //add localstorage

  var guessLanguage = app.guessLanguage = function guessLanguage() {
    //TODO: cordova language
    var language = window.navigator.userLanguage || window.navigator.language
    var guess = (language && language[1]) ? language : app.region.val
    if (guess) {
      if (guess === 'nb' || guess === 'nb-no') {guess = 'no'}
      guess = guess.slice(0, 2).toLowerCase()
      if (languages && util.checkArray(languages, guess) === false) {
        guess = 'en'
      }
      return guess
    }
    return 'en'
  }

  app.language = new Value({
    transform: function(val, cv) {
      if (!cv || typeof cv !== 'string') {
        cv = guessLanguage()
      }
      return cv ? cv.slice(0, 2).toLowerCase() : false
    },
    init: app.initialised
  })

  app.fullscreen = new Value({
    force: true
  })

  app.loader = new Value()

  app.volume = new Value({
    val: 1,
    transform: function(v, cv) {
      // console.log('volume?',cv,isNaN(cv) ? 1 : cv)
      //TODO: use loDash for isNan
      return isNaN(cv) ? 1 : cv
    }
  })

  app.popup = new Value({
    init: app.ready
  })

  app.state = new Value({
    init: app.ready
  })

  app.notification = new Value({
    init: app.ready,
    force: true //TODO: make this better
  })

  app.playing = new Value({
    init: app.ready,
    val: false
  })

  app.restrictPlayback = new Value()

  //make injectable
  app.wifiOnly = new Value(
    localStorage ? {
      val: localStorage.getItem('wifiOnly') || false,
      defer: function(update) {
        if (this._val) localStorage.setItem('wifiOnly', true)
        else localStorage.removeItem('wifiOnly')
        update()
      }
    } : false
  )

  app.restrictPlayback.val = {
    val: app.wifiOnly,
    transform: function(v, cv) {
      return (cv && cases.native && api.network.val !== 'wifi') ? true : false
    }
  }

  cases.$playing = app.playing

  cases.$storeAvailable = new Value(
    cases.native && (cases.ios || cases.android || cases.windowsMobile) //&& window.Store
  )

})

},{"../browser/network/url":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/url.js","../browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('../')
  , util = require('../util')
  , inject = require('../util/inject')
// , raf = require('../browser/animation/raf')


/*
  util.define( extend, 'extensions',{val:[], setClass:true} )
*/

/**
 * Base is used as a class constructor.
 * @constructor V.Base
 * @param  {*} [val] Startvalue for new V.Base
 */
var base = V.Base = module.exports = exports = function(val) {
  this._from = this.constructor
  if (val) this.set(val)
}

exports.settings = require('./settings')

/**
 * Sets properties defined in an object.
 * Define a _set method on a base instance to get custom method per set.
 * @function _set
 * @param  {*} val         Any value
 * @param  {*} [params]    Added parameters
 * @param {Boolean} noset  When true returns a parsed val object but set nothing
 * @return {Object}        return self for chaining
 */
var _set = exports.set = function(val, params, noset) {
  for (var i in val) {
    if (~i.indexOf(',')) {
      for (var arr = i.split(','), multiobj = {}, m = 0, ml = arr.length; m < ml; m++) {
        multiobj[arr[m]] = util.clone(val[i])
      }
      if (!noset) {
        _set.call(this, multiobj, params, noset)
      } else {
        delete val[i]
        for (var n in multiobj) {
          val[n] = multiobj[n]
        }
      }
    } else {
      i = util.dotField(val, i)

      // console.error( 'SET', this, this._set)

      if (this._set && !noset) {
        this._set.call(this, val, i, params)
      } else {
        //TODO: check for property move from element set to here
        // if( V.Object && this.isProperty( i, val ) && this[i] instanceof V.Object )
        // {
        //   console.log('??', i, val, this.isProperty( i, val ) )
        //   this[i].val = val[i]
        // }
        // else
        // {
          this[i] = val[i]
        // }
      }
    }
  }
  return noset ? val : this
};

util.define(base,
  /**
   * When a Base is extended without defining the type this is the default type.
   * @property defaultType
   */
  'isProperty', function( i, val) {
    var t = this
      , result = 

      
    // val[i] instanceof Object  //THIS MAY GO AWAY LATER
           //TODO: check if this is really nesseracy ( void 0 )
           // && 

      //SUPER DANGERGOUS THING

          !( t._[i] === void 0 //--- danger resolve when define _ is fixed
           && !util.lookup.call(t, i) 
           && typeof t[i]!=='function' 
          )

    // console.log( val[i] instanceof Object, t._[i] === void 0, 'val:',t._[i], !util.lookup.call(t, i), typeof t[i]!=='function'  )

    // console.log( 'IS PROPERTY', i, result )

    return result
  },
  'defaultType', false,
  'extensions', false,
  'define', function(val) {
    for(var i in val) {
      util.define( this, i, val[i] )
      util.define( this.Class, i, val[i] )
    }
  },
  /**
   * Extend is used to add properties to base.
   * Settings are similar to standard defineProperty.
   * @method extend
   * @param   {Object}   settings        Define the following fields: name, type, set, new, remove.
   * @param   {String}   settings.name   Define the name of the property
   * @param   {Object}   [settings.type] Define the type of object e.g. V.Value, set type to false if you want to use standard defineProperty
   * @param   {Function} settings.set    Define a function on set
   * @param   {Function} settings.new    Define a function on construct
   * @param   {Function} settings.remove Define a function on remove
   * @return  {[type]}                   [description]
   */
  'extend', function(settings) {

    //TODO: add to instance as well , have a dictionary of extenstions -- get to orginal easyly
    var args = util.arg(arguments)
      , l = args.length
      , i

    if (l > 1) {
      for (i = 0; i < l; this.extend( args[i++] ));
    } else if (!settings.name) {
      for (i in settings) {

        if( typeof settings[i] === 'function' ) 
        {
          this.extend( { name: i, set: settings[i] } )
        }
        else
        {
          settings[i].name = i
          this.extend( settings[i] )
        }

      }
    } else {

      if( settings === true ){
        alert()
      }


      if (!settings.def && settings.def !== 0) settings.def = false;
  
      if (this.Class.prototype._settings) {
        exports.settings.parse.call(this, settings)
        if (settings._settings) exports.settings.create.call(this, settings)
      }
      //1. normal extensions
      if (settings.type === false || ( !settings.type && !this.defaultType ) ) {

        //TODO: test if double define is actually ok!
        // util.define(this, settings.name, settings)

        util.define(this.Class, settings.name, settings)

      } else {
        //2. V.Values
        if (!settings.type) settings.type = this.defaultType
          //a type has fields type, set ,get, create
        var get =  function(prop) {
            //custom get
            return settings.type.get 
              ? settings.type.get.call(this, prop, settings)
              : prop
          }
          , set =  function(val) {

            var prop = this[settings.name]
            if(prop===null) return
            if (prop===settings.def) { //(prop instanceof V.Object)
              //return is hier mischien niet nodig;
              return settings.type.create.call(this, val, prop, settings)
            } else {
              // console.log('????????????', this, val, prop, settings)
              
              val = settings.type.set.call(this, val, prop, settings)
              if (val!== null) prop.val = val
            }
          }

        //TODO: test if double define is actually ok!
        util.define(
          this,
          settings.name,
          settings.def,
          set,
          get,
          true
        )
        //dit breaked wat shit

        //or on value ? value.prop

        //make extended prototype object perhaps
        // this.Class.prototype['__'+settings.name+'__'] = settings

        util.define(
          this.Class,
          settings.name,
          settings.def,
          set,
          get
        )
      }
    }
  },
  /**
   * Removes this Base. Also removes all listeners added to extensions.
   * Instances true will remove all instances as well.
   * @method remove
   * @param  {[type]} instances  [description]
   * @param  {[type]} fromremove [description]
   * @param  {[type]} params     [description]
   */
  'remove', function(instances, fromremove, params) {

    // this._removing = true

    if(!this._from) return

    this.setting('remove', [params]);

    if (!fromremove) {
      var ins = this._from.base.instances
      if(ins) {
        for (var n = 0, l = ins.length; ins[n] !== this || !ins.splice(n, 1); n++);
      }
    }

    for (var i in this.__) {
      if (this.__[i] instanceof V.Object) {
        //nested, blacklist, not (fields in object), from, stamp, noupdate
//         console.log('---------', i, this.__[i], this.__[i]._path )
        this.__[i].remove(false, false, false, false, false, true);
        this.__[i] = null
      } else {
        this.__[i] = null
      }
    }
    this.__ = null

    if (instances && this.instances) {
      for (j = this.instances.length - 1; j >= 0; this.instances[j--].remove(true, true));
    }

    for (var j in this) {
      // if(this[j] instanceof V.Base) {
      //   this[j].remove()
      // } 
      this[j] = null;
    }

    this._settings = null
    this._ = null
    delete this._settings
    delete this._
    delete this.__
    // delete this._class; may not be nessecary
  },
  /*set on prototype*/
  'set', _set,
  'get', function( path, self ) {
    return util.get( this, path, self )
  },

  'inject', inject,
  /**
   * Passes field parameter only for instances matching a field
   * @method
   * @param  {Function} fn    [description]
   * @param  {String}   field [description]
   * @param  {*}        val   [description]
   * @param  {*}        p     [description]
   * @return {Boolean}        [description]
   */
  'eachInstance', function(fn, field, val, p) {
    var instances = this.instances;
    if (instances) {
      for (var i = 0, l = instances.length, instance; i < l; i++) {
        instance = instances[i];


//problem! has to correct for missing instances!!!
//   console.log(instance, instances)

          

        if (instance && (!field || !instance.__ || !instance.__[field])) {
          if (fn.call(instance, val, p)) {
            return true;
          }
          if (instance.eachInstance(fn, field, val)) {
            return true;
          }
        } else if(!instance) {
          console.error('\n\n\n\ninstance in base gone?', i , instances)
          // debugger
        }
      }
    }
  },
  /**
   * Creates a class from the current Base instance
   * @constructor Class
   * @return {Object}
   */
  'Class', {
    get: function() {
      if (!this._class) {
        this.instances = [];
        this._class = function(val, proto, setting) {
          if (!proto) {
            var from = this._from.base;
            from.instances.push(this);
            if (this.setting) {
              this.setting('new', [from, setting]);
            }
            if (val) {
              this.set(val);
            }
          }
        };
        this._class.base = this;
        this._class.prototype = new this._from(false, true);
        this._class.prototype.__ = null;
        util.setstore.call(this);
        var i, _proto = this._class.prototype._ = {};
        for (i in this.__) {
          _proto[i] = this.__[i];
        }
        for (i in this._) {
          if (_proto[i] === void 0) {
            _proto[i] = this._[i];
          }
        }
        this._class.prototype._from = this._class;
        this._class.inject = inject
      }
      return this._class;
    }
  });
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../util/inject":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/inject.js","./settings":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/settings.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/settings.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('./'),
  util = require('../util');

/**
 * Settings are used for special cases e.g. onRemove or onNew instance
 * @property
 */
util.define(base, '_settings');

base.prototype._._settings = {};

/**
 * Set settings on Base
 * @function _set
 * @param  {Object}  set      Object to set
 * @param  {Boolean} [remove]
 * @param  {Boolean} [force]  True/false
 */
var _set = function(set, remove, force) {
  var _s = set._settings //e.g. node , remove and parent
    , t = this
    , __t = t._._settings
    , setting
    , i
    , _t

  util.setstore.call(t)

  if (!t.__._settings) {
    // console.log('create my own settings')
    t.__._settings = {}
    for (var j in __t) {
      t._settings[j] = __t[j]
    }
  }

  _t = t.__._settings

  // console.log('SETTINGS?'.inverse, set, __t)

  for (i in _s) {
    setting = _s[i]
    //efficient memory management only make own if absolutely nessecary
    if ((remove && _t[setting][set.name]) || (!remove && !_t[setting][set.name]) || force) {
      
      if (_t[setting] === __t[setting]) {
        _t[setting] = {}
        for (var n in __t[setting]) {
          _t[setting][n] = __t[setting][n]
        }
      }

      if (remove) {
        this.eachInstance(function() {
          if (this[set.name] !== t[set.name]) {
            if (this._setting !== _t && this._settings[setting] === _t[setting]) {
              // console.log('found that the settings are the same and not the same property make my own');
              // console.log('------ SETTING')
              _set.call(this, _t[setting][set.name], false, true);
            }
          } else {
            if (this._setting !== _t && this._settings[setting] !== _t[setting]) {
              // console.log('------ REMOVE SETTING')

              // console.log(this.name,set.name,'found that the property is the same but settings are not!');
              this.removeSetting(set.name, setting);
            }
          }
        });
        _t[setting][set.name] = null;
        delete _t[setting][set.name]; //delete is kut!;
        if (util.empty(_t[setting])) {
          // console.log('lets put this to true!')
          _t[setting] = true;
        }
      } else {
        // console.log('------ DO SETTING', set, _t, setting, set.name)
        if(_t[setting]===true) {
          _t[setting]={}
        }
        _t[setting][set.name] = set;
        // console.log('RESULT?', setting, _t[setting])
      }
    }
  }

  // console.log('SETTINGS? -- result'.inverse, _t, this._settings===_t, this.BLUXEN)

};

/**
 * Creates a setting
 * @method create
 * @param  {[type]} set [description]
 * @return {[type]}     [description]
 */
exports.create = function(set) {
  set._set = set.set;
  set.set = function(val, prop) {
    _set.call(this, set)
    set._set.apply(this, arguments)
  }
}

/**
 * Extracts settings from settingsobject and stores them in an array.
 * @method parse
 * @param  {Object} settings Settingobject
 * @param  {Object} object   Settingsobject
 */
exports.parse = function(settings, object) {
  if (!object) {
    object = this._settings
  }
  for (var i in object) {
    if (settings[i]) {
      if (!settings._settings) {
        settings._settings = [];
      }
      settings._settings.push(i);
    }
  }
};

/**
 * Adds setting(s) to Base prototype
 * @method add
 * @param  {String[]}    name  Array of settingnames
 * @param  {Prototype}   proto Prototype eg. myBase class
 */
exports.add = function(name, proto) { //start using this sometimes!;
  if (name instanceof Array) {
    for (var i in name) {
      if (proto) {
        this.add(name[i], proto);
      } else {
        this.addSetting(name[i], false);
      }
    }
  } else {
    if (!proto) {
      util.setstore.call(this);
      if (!this.__._settings) {
        this.__._settings = {};
      }
      for (var j in this._._settings) {
        this._settings[j] = this._._settings[j];
      }
      this._settings[name] = true;
    } else {
      proto.prototype._settings[name] = true;
    }
  }
};

/**
 * Add settings to instances of Base
 * settings only work for instances of the added Basesettings
 * @method
 */
util.define(base,
  'addSetting', function(name) {
    exports.add.call(this, name);
    if (this._class) {
      this._class.prototype._._settings = this._settings;
    }
  },
  /**
   * Simple implementation of setting.create
   * @method setSetting
   * @param  {Object} set Settingobject
   */
  'setSetting', function(set) {
    //eerst checken of ie al bestaat anders kan het voorkomen dat het teveel is
    exports.parse.call(this, set);

    // console.log('SET SETTING'.yellow.inverse, set, this._settings )

    //get gebruiken --- object is een check op meerdere fields returns true of false // bij get ook mogelijk om field mee te geven
    _set.call(this, set);

    // console.log('SET SETTING -- result'.yellow.inverse, this._settings )

  },
  /**
   * [description]
   * @method removeSetting
   * @param  {String}       name     Name of the setting to remove
   * @param  {Array|Object} settings Settingobject
   */
  'removeSetting', function(name, settings) {

    // if(!settings) {
    //   //this may all be not nessecary!
    //   for(var i in this._settings) {
    //     for(var j in this._settings[i]) {
    //       if(this._settings[i][j].name===name) {
    //         settings=this._settings[i][j]
    //         break;
    //       }
    //     }
    //   }
    // }

    if (!(settings instanceof Array)) {
      //this may all be not nessecary!
      // if(settings instanceof Object) {
      //   settings = settings._settings
      // } else {
        settings = [settings];
      // }
    }

    for (var i = settings.length - 1, found, _settings = this._settings; i >= 0; i--) {
      if (_settings && _settings[settings[i]] && _settings[settings[i]][name]) {
        found = true;
        break;
      }
    }
    if (found) {
      _set.call(this, {
        name: name,
        _settings: settings
      }, true);
    }
  },

  /**
   * Checks if object has settings and executes them. Arguments are passed to settings.
   * @method setting
   * @param  {String}    name Name of the setting
   * @param  {Arguments} arg  Arguments to pass to settings
   */
  'setting', function(name, arg) { //misschien arg
    var _s = this._settings;
    if (_s && _s[name] && _s[name] !== true) {
      for (var i in _s[name]) {
        _s[name][i][name].apply(this, arg);
      }
    }
  });

/**
 * Base has two default settings
 * new is invoked on construction , remove on removal;
 * @settings
 */
exports.add(['new', 'remove'], base)

},{"../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/easing.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var animation = require('./');
animation.easing = exports;
// t: current time, b: beginning value, c: change In value, d: duration
// courtesy of Robert Penner
exports.inCubic = function(t, b, c, d) {
  return c * (t /= d) * t * t + b;
};

exports.outCubic = function(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
};

exports.outBack = function(t, b, c, d, s) {
  var s = 1.70158;
  return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
};
},{"./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/frame.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var Value = require('../../value')
  , frame = new Value(1)
  , util = require('../../util')
  , _on = function() {
    // console.group()
    // console.log('\n\n----RAF----'.magenta.bold)
    exports.rafId = window.requestAnimationFrame(_on)
    frame.val++
    // console.groupEnd()
  }

frame.done = new Value(true)

util.define(frame,
  'addListener', function(val, mark, remove) {
    if (!this._listeners){
      this.done.val = false
      _on()
    }
    Value.prototype.addListener.call(this, val, mark, remove)
  }
, 'removeListener', function(val, mark, remove) {
    var t = this
    Value.prototype.removeListener.call(t, val, mark, remove)
    if (!this._listeners) {
      window.cancelAnimationFrame(exports.rafId)
      this.val = 1
      this.done.val = true
    }
  }
)

module.exports = frame
},{"../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var element = require('../element').inject(require('../element/properties')) //element added (extend) //call extend on flags (make buffer if already extended)
  , object = require('../../object')
  , util = require('../../util')
  , flags = require('../../value/flags/util')
  , operators = require('../../value/operators')
  , frame = require('./frame')
  , _linear = function(t, b, c, d) {
    return c * t / d + b
  }
//-------------------------------------------------------------------
operators._a = function (val, operator) {
  return operator
}

function preventSet(val) {
  this._p = true
  this.val = val
  this._p = false
}

operators._a.order = 2

flags.animation = {
  set: function (val) {
    
    var thisObject = this
      , _p = thisObject.checkParent('_prop')

    if (val) {

      if (!thisObject._val) thisObject.val = 0

      var name = _p._prop.name
        , element = _p._caller
        , noListener = val.noListener
        , path = thisObject._path
        , id = name.concat(path.join(''))
        , skip = val.skip
        , easing = val.easing 
          && exports.easing[val.easing] 
          || val.easing 
          || _linear
        , time, start, ready

      if(!_p._animListen) _p._animListen = function (val) {
        var tn = this[name]
        if(tn) tn.update(this, true)
        else {
          var FORTESTING = frame._listeners && frame._listeners.length
          console.log('_animListen setting',frame._listeners && frame._listeners.length)
          frame.removeListener(void 0, this)
          console.log('>> _animListen setting',frame._listeners && frame._listeners.length)
          if(FORTESTING && FORTESTING === (frame._listeners && frame._listeners.length))
          {
            console.error('this >>',this)
            // debugger
          }
        }
      }

      element.setSetting({
        name:'animation',
        remove:function() {
          var FORTESTING = frame._listeners && frame._listeners.length
          // console.log('remove setting',frame._listeners && frame._listeners.length)
          

          frame.removeListener( void 0, this)


          if(frame._listeners && FORTESTING && FORTESTING === (frame._listeners && frame._listeners.length))
          {
            for(var i in frame._listeners ) {
              if( frame._listeners[i] instanceof Array ) {
//                 console.log('COMPARE',frame._listeners[i][1]===this, frame._listeners[i][1], 'vs', this )
                if( frame._listeners[i][1]===this, frame._listeners[i][1] ) {
                    // frame._listeners.splice(i,1)
//                     console.error('this >>',this.node)
                    // debugger
                }
              }
            }
          }


        }
      })

      _p.preventSet = preventSet

      _p.set('translate', true)

      thisObject.set('_a', {
        time: val.time || 60,
        val: function(v, cv, b) {
          
          var t = this
            , a
            , prop = _p //t[name] ||
            , pr = t[name]

          if (!t._a) t._a = {}
        
          if (!t._a[id]) {

            start = val.start === void 0 
              ? t.rendered && (thisObject.__lval !== void 0)
                ? thisObject.__lval
                : cv
              : val.start instanceof object 
                ? val.start.val
                : val.start

            t._a[id] = {
              _start: start,
              _end: start,
              _current: start,
              _count: 0
            }

            if (!t.rendered) return start
          }

          if (t.rendered) {
            if(skip) {
              t._a[id]._current = cv
              skip = false
              return cv
            }

            a = t._a[id]
            if (pr._p || exports.prevent) {
              a._frame = 0
//               console.log('remove prevent',frame._listeners && frame._listeners.length)
              frame.removeListener(prop._animListen, this, true)
//               console.log('>> remove prevent',frame._listeners && frame._listeners.length)
              if (pr._p !== 1) {
                a._current = a._end = cv
                if (val.complete) noListener = val.complete.call(t, cv)
                if (val.done) setTimeout( function() { val.done.call(t,cv) }, 0)
                if (val.once) {
                  setTimeout( function() { 
                    if(val.once) val.once.call(t,cv) 
                    val.once = null
                  }, 0)
                }
              }
            } else if (a._frame !== frame.val) {
              if (a._frame || (cv !== void 0 && a._current !== cv)) { //checking a.frame faster than comparing a.current to cv
                if (a._end !== cv) {

                  if (val.init) val.init.call(t, a._current)
                  if(!noListener) {
                    frame.addListener([prop._animListen, this, name]
                      , function (listenArray, listeners) {
                        for(var i in listeners) {
                          if(listeners[i].pop) {
                            if(listeners[i].pop && listeners[i][1]===t && listeners[i][2]===name) {
                              return false
                            }
                          }
                        }
                       return true 
                      }
                    )
                  }
                  a._start = a._current
                  a._end = cv
                  a._count = 0
                  time = ~~v.time.val
                }
                a._frame = frame.val

                if(val.delay){
                  val.delay--
                  return a._start
                }

                var cnt = ++a._count
                a._current = easing.call(t, cnt, a._start, a._end - a._start, time || (time = ~~v.time.val))
                if(val[cnt]) val[cnt].call(this,a._current,cv)
              }
              if (a._count === time) {              
                a._current = cv
                a._frame = 0
                a._count = 0

                if (val.complete) noListener = val.complete.call(t, cv)
                if (val.done) setTimeout( function() { val.done.call(t,cv) }, 0)
                if (val.once) {
                  setTimeout( function() { 
                    if(val.once) val.once.call(t,cv) 
                    val.once = null
                  }, 0)
                }

                if(!noListener)
                {
//                   console.log('remove nolistener',frame._listeners && frame._listeners.length)
                  frame.removeListener(prop._animListen, this, true)
//                   console.log('>> remove nolistener',frame._listeners && frame._listeners.length)
                }
              }
            }
            return a._current
          } 
        }
      })
            
      _p._skip = true
      thisObject._skip = true
      
      if (val.start !== void 0) {
        var caller = this._caller
        if(!caller) caller = this.checkParent('_prop')._caller
        caller.setRender(name, function(parent) {
          this.update(name)
        })
      }
    } 
    else {
      thisObject.remove('_a')
      thisObject._skip = void 0
      _p._skip = void 0
      _remove(_p)
    }

  }
}
},{"../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value/flags/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/util.js","../../value/operators":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/operators.js","../element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","../element/properties":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/index.js","./frame":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/frame.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var ua = require('../ua'),
  RAF = 'equestAnimationFrame',
  CAP = 'R' + RAF,
  util = require('../../util')
  lastFrame = 0;

util.define(ua, 'hasTransition', {
  get:function() {
    if(!ua._hasTransition) {
       var b = document.body || document.documentElement
        , s = b.style
        , p = 'ransition';
      ua._hasTransition = typeof s['t'+p] === 'string'
        || typeof s[ua.prefix + 'T'+p] === 'string'
    }
    return ua._hasTransition
  }
})

RAF = 'r' + RAF;
if (!window || (window && !window[RAF])) { 

  ua.noRaf = true

  //window[ua.prefix + CAP] ||

  window[RAF] = function(callback) {
    return setTimeout(callback, 20);
  };
  window.cancelAnimationFrame = function(id) {
    clearTimeout(id);
  };
}



module.exports = exports = window[RAF]

exports.timer = function( fn, frames, repeat ){
  if( --frames ){
    exports(function(){
      if( repeat ) fn()
      exports.timer( fn, frames, repeat )
    })
  } else {
    exports( fn )
  }
}

exports.repeat = function( fn, frames ){
  exports.timer( fn, frames, true )
}

//check ios 6 paul irish says stuff goes wrong there...

},{"../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var cases = require('./'),
  element = require('../element'),
  setFlags = require('../element/set'),
  base = require('../../base'),
  util = require('../../util');

//------------------CASES FOR SET-------------------------------
var _css = function(t, name, invert, remove) {
    if (!invert) {
      if(!t.css) { t.css = '' }
      t.css.set( remove ? 'removeClass' : 'addClass', name ) 
      t.css.update(t)
                  // console.error('\n\n\nset css!!!!!xxx', name, t.node)

      t.eachInstance(function() {
            console.error('\n\n\ninstance! set css!!!!!', name, t.node)

        // if(this.css !== t.css) {
          this.css.set( remove ? 'removeClass' : 'addClass', name ) 
          this.css.update(this)
        // }
      })
    }
  },
  methods = cases.methods;

setFlags.remove = function(i, val, copy, top) {
  //this could become a seperate module since remove may be usefull for different purposes
  if (val && val.__remove__) {
    if (this[i] instanceof base) {
      top[i] = false;
    } else if (util.lookup.call(this, i)) {
      delete val.__remove__;
    } else {
      delete val[i];
      return true;
    }
  }
};

setFlags.cases = methods.reader(function caseReaderBase(name, val, dynamic, invert) {
  var t = this,
    f = function(obj) {
      obj = base.set(obj, false, true);
      for (var i in obj) {
        if (util.isObj(obj[i])) {
          obj[i] = f(obj[i]);
        }
      }
      return obj;
    },
    method,
    parsed,
    set,
    sVal,
    original;
  val = f(val);

  if (dynamic) {
    if (!t._cases) {
      t._cases = {};
    }
    if (val === null) {
      if (t._cases[name].method) {
        // console.error(name, 'case === null , remove it');
        cases[name].removeListener(t._cases[name].method);
      }
      if (cases[name].val) {
        t.css = {
          removeClass: name
        };
         t.eachInstance(function() {
            this.css = {
              removeClass: name
            };
         })
      }
      delete t._cases[name]; //removes case orginal
    } else {
      // console.error('SET CASE',name,t._cases[name]&&t._cases[name].method);
      parsed = methods.original(t, true, val, t._cases, true, name);
      t._cases[name] = {
        val: val,
        orig: parsed[0],
        nested: parsed[1]
      };

      if (!t._cases[name].method) {
        // console.error('this is what i have set for original', t._cases);
        method = t._cases[name].method = function() {

          // console.log('LETS TRY TO RUN METHOD',name,val);

          if (val) {
            set = methods.merge(true, name, val, t._cases); //arg no val;
            sVal = set [0];
            original = set[1];
            delete sVal.val;
            delete original.val;
            if (cases[name].val) {
              _css(t, name, invert);
              t.set(sVal, true);
            } else {
              _css(t, name, invert, true);
              t.set(original, true);
            }
          }
        };
        // console.error('ADD LISTENER TO',name,  t._cases[name]);
        cases[name].addListener(method);
        //remove setting on remove (saves memory)
        t.setSetting({
          name: '_c' + name,
          remove: function() {
            if(this === t ) {
              cases[name].removeListener(method); //if(!this.css === this._from.base.css) 
              this._cases[name].method = null
            }
          }
        });
        // } else {
        // console.log(name, 'already got listeners for case',name);
      }
      if (cases[name].val) {
        _css(t, name, invert);
        t.set(val, true);
      }
    }
  } else {
    _css(t, name, invert);
    t.set(val); //maybe copy args?
  }
  return true;
});
},{"../../base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","../element/set":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/set.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var object = require('../../object'),
  util = require('../../util'),
  element = require('../element'), //element /w extend
  value = require('../../value'),
  flags = require('../../value/flags');

/**
 * cases
 * cases are used to set one or more values when a specific case is true
 * there are 2 types of cases , static and dynamic ,
 * static cases are set at initialization of the application , usefull for things such as device type (phone, desktop, tv)
 * dynamic cases can be changed dynamicly and Objects or Bases that use the case will be changed dynamicly as well
 */

util.define(exports, 'methods', {});
//multiple, recursive and original have to become extensions on V.Object.convert so it's possible to use the same for data and events

var _isObj = util.isObj,
  /*
    _recur
    special merge that adds __remove__ if a field has to be removed
  */
  _recur = function(original, merge, fieldExists) {

    // console.log(original, merge, fieldExists)

    var keys, i, key, originalChild, mergeChild;
    if (fieldExists) {
      keys = {};
      for (key in original) {
        keys[key] = true; //keys can be undefined -- code can become shorter
      }
    }
    for (i in merge) {
      if (!fieldExists || keys[i]) {
        originalChild = original[i];
        mergeChild = merge[i];
        if (originalChild instanceof Object) {
          if (originalChild.__remove__ && (mergeChild && !mergeChild.__remove__)) {
            delete originalChild.__remove__;
          }
          if (!(mergeChild instanceof Object)) {
            merge[i] = {
              val: mergeChild
            };
          }
          _recur(originalChild, mergeChild, fieldExists);
        } else {
          original[i] = mergeChild;
          originalChild = 'burn';
        }
      }
    }
  },
  /*
          _multiple
          merge multiple orginals into a new orginal object also resolve nested cases
      */
  _multiple = function(t, nested, cases, currentObj, currentVal, base, name, path, orig) {

    if (!path) {
      orig = t;
      path = [];
    }
    var j, _case, cvChild;

    if((currentVal instanceof object) && !base) {

      // currentObj.val = t._val
      // console.error('VOBJ', currentObj)


    } else if (currentVal instanceof Object) {
      for (j in currentVal) {
        cvChild = currentVal[j];
        if (exports[j]) {
          _case = exports[j];
          if (_case instanceof object) {
            if (!base || !element.set.lookup.call(orig, path[path.length - 1])) { //element is required in cases.base, make this part extendable
              nested[j] = true;
            }
          }
          if (!_isObj(cvChild)) {
            currentObj.val = t && (t._val !== void 0 ? t._val : void 0);
          } else {
            path.push(j);
            //should be possible to use nested for current nested case;
            _multiple(t, nested, cases, currentObj, cvChild, base, name, path, orig);
          }
          currentObj[j] = null;
        } else {
          if (_isObj(cvChild)) {
            if (!currentObj[j]) {
              currentObj[j] = (t && t[j] && t[j].convert && t[j].convert(cvChild)) || (cvChild instanceof Array ? [] : {});
            }
            path.push(j);
            _multiple(t && t[j], nested, cases, currentObj[j], cvChild, base, name, path, orig);
            if (base && (!t || !t[j])) {
              currentObj[j].__remove__ = true;
            }
          } else {
            if (t && currentObj && !currentObj[j]) {
              if (flags[j]) {
                delete currentObj[j];
                currentObj.val = t._val !== void 0 ? t._val : void 0;
              } else {
                currentObj[j] = j === 'val' 
                  ? (t._val !== void 0 ? t._val : void 0) 
                  : (t[j]!==void 0 && t[j].convert && t[j].convert())
              }
            }
          }
        }
      }
    }
  };

/*
      original
      create a orginal store for a new case
    */
exports.methods.original = function(t, isObj, val, cases, base, name) {



  var obj = isObj ? t.convert(val) : t._val,
    i, cflag, nested = {};

  _multiple(t, nested, cases, obj, val, base, name);

  // for(var i in nested) {
  //   console.error('NESTED:::',i);
  // }
  // console.log(base ? 'BASE:': 'PROPERTY:' , name,'ORIGINAL GENERATION','\nval:',val,'\nobj:',obj,'\nnested:',nested,'\ncases:',cases);

  for (i in cases) {
    if (!nested[i]) {
      cflag = cases[i].orig;
      if (!isObj) {
        if (_isObj(cflag)) {
          if (cflag.val) {
            obj = cflag.val;
          }
        } else {
          obj = cflag;
        }
      } else {
        if (_isObj(cflag)) {
          if (!cases[i].nested[name]) {
            _recur(obj, cflag, name);
          }
        } else if (obj.val) {
          obj.val = cflag;
        }
      }
    }
  }



  return [obj, nested];
};
/*
  merge
  merge dynamic cases (overwrite /w cases that are true and further in the order of cases)
*/
exports.methods.merge = function(isObj, name, val, cases) {
  var original = util.clone(cases[name].orig),
    sVal = val,
    overwrite,
    i,
    merge,
    originalChild;
  for (i in cases) {
    if (i !== name && !cases[name].nested[i]) {
      if (exports[i].val) {
        merge = cases[i].val;
        if (_isObj(original) || _isObj(merge)) {
          if (!_isObj(original)) {
            original = {
              val: original
            };
          }
          if (!_isObj(merge)) {
            merge = {
              val: merge
            };
          }
          _recur(original, merge, true);
          for (i in exports) {
            originalChild = original[i];
            if (originalChild !== null && originalChild !== void 0) {
              delete original[i]; //delete is pretty slow
            }
          }
          if (overwrite) {
            if (isObj) {
              if (sVal === val) {
                sVal = util.clone(sVal);
              }
              merge = util.clone(merge);
              for (i in exports) {
                if (merge[i] !== null && merge[i] !== void 0) {
                  // console.error('REMOVE FIX', i);
                  delete merge[i]; //delete is pretty slow
                }
              }
              _recur(sVal, merge, true);
            } else {
              if (merge.val) {
                sVal = merge.val;
              }
            }
          }
        } else {
          original = merge;
        }
      }
    } else {
      overwrite = true;
    }
  }
  return [sVal, original];
};
/*
  reader
  abstraction for use in cases.object and cases.base
*/
exports.methods.reader = function(fn, dynamic, _static) {
  return function reader(name, val) {
    var invert = (name[0] === '!'),
      vCase = invert ? exports[(name.slice(1))] : exports[name],
      ret;
    if (vCase) {
      if (vCase instanceof object) {
        if (invert && !exports[name]) {
          exports[name] = new value({
            val: function() {
              return !vCase.val;
            },
            listen: vCase
          });
        }
        ret = fn ? fn.call(this, name, val, true, invert) : dynamic;
      } else {
        ret = invert ? !!fn : fn ? fn.call(this, name, val) : _static
      }
    } else if (invert) {
      ret = fn ? fn.call(this, name, val, false, invert) : _static;
    }
    if (vCase === false && fn) {
      ret = true;
    }
    return ret;
  };
};

require('./object');
require('./base');
},{"../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../../value/flags":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/index.js","../element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","./base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/base.js","./object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/object.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = require('../../value/flags'),
  Cases = require('./'),
  object = require('../../object'),
  util = require('../../util'),
  methods = Cases.methods,
  dynamic = {
    set: function(val, stamp, reset, name) {

      if(!this._flag) this._flag = {}

      var t = this,
          //selection for t._flag easy maken
          
          
        flags = t._flag.case || (t._flag.case = [
          'case',
          t._val,
          false, {},
          dynamic
        ]),
        cases = flags[3],
        isObj = util.isObj(val),
        setVal = (isObj && !val.val) ? false : true;
      if (val === null) {
        if (cases[name]) {
          Cases[name].removeListener(cases[name].method);
        }
        delete cases[name];
      } else {
        flags[5] = true;
        if (!cases[name]) {
          var x = methods.original(t, isObj, val, cases, false, name);
          cases[name] = {
            val: val,
            orig: x[0],
            nested: x[1],
            method: function() {
              var set = methods.merge(isObj, name, val, cases),
              sVal = set[0],
              original = set[1];
              // console.log(name)
              // if(name === '$isActive' )console.error('boeloe boeloe boeloe!!!',sVal,original)

              flags[5] = true; //the closures here are not really nessecary better to avoid
              if (Cases[name].val) {

                if(!sVal) console.warn(name,'wrong in cases!', sVal, Cases, flags)
                if (setVal && sVal) {
                  // if(name === '$isActive' )console.log('yee its true')
                  flags[1] = sVal.val || sVal;
                }
                t.val = sVal;
              } else {
                                  // if(name === '$isActive' )console.log('no way gozee')

                if (setVal) flags[1] = original && original.val || original

                if(name === '$isActive' )console.log('no way gozee 2',original, t)

                t.val = original;
              }
              flags[5] = null;
            }
          };
          Cases[name].addListener(flags[3][name].method);
        }
        if (Cases[name].val) {
          if (setVal) {
            flags[1] = val.val || val;
          }
          object.set.call(t, val, stamp, false, true);
          //not always
          t._ignorefornow = true

        }
        flags[5] = null;
      }
    },
    // reset:function() {
      // console.error('reset')
    // },
    //add reset later
    remove: function(flags, name) {
      // console.log(flags, name)
      var cnt = 0
      for (var i in flags[3]) {
        // if(flags[3])
        cnt++
        if(!this._ignorefornow && !name || i===name) {
          cnt --
          Cases[i].removeListener(flags[3][i].method);
        } else {
          delete this._ignorefornow
        }
      }
      if(cnt) {
        // console.log('CASE OBJECT REMOVAL --- IT IS NOT EMPY')
        return true
      }
    },
    stack: 'case'
  },
  _static = {
    set: function(val, stamp, reset, name) {
      if (val !== null) {
        object.set.call(this, val, stamp, false, true);
      }
    }
  };

flags.dynamic.cases = methods.reader(false, dynamic, _static);
},{"../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value/flags":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/css.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

/*
  gets and caches values for css classes, also possible to change styles of classes
  return an array of multiple css objects corresponding to the class name
  when you pass field it searches the field trough all the classes selected, always takes first argument
  maybe have to make this for things such as div selectors / nested stuff --- will be cpu intensive!;
*/
var selector = 'cssRules',
  parseclass = function(slctr) {
    slctr = '.' + slctr.replace(/\./g, ' .').toLowerCase();
    for (var robj, select = document.styleSheets, length = select.length, i = 0, selectItem; i < length; i++) {
      selectItem = select[i][selector] || select[i][(selector = 'rules')]; //location of this polyfill can be improved
      if(selectItem) {
        for (var j = 0, l = selectItem.length, item; selectItem, j < l; item = selectItem[j++], item.selectorText === slctr && (robj = item.style));
      }
    }
    return robj;
  },
  c = function(cssClass, cache) {
    var t = exports;
    cache.push(t[cssClass] || (t[cssClass] = parseclass(cssClass)) || {});
    return cssClass;
  };

module.exports = function(slctr, field) {
  if (slctr) {
    var cache = this[slctr];
    if (!cache) {
      cache = [];
      for (var selectarray = slctr.split(' '), i = 0, l = selectarray.length, cssClass; i < l; i++) {
        if ((cssClass = c(selectarray[i], cache).split('.')) instanceof Array) {
          c(cssClass[cssClass.length - 1], cache);
        }
      }
      this[slctr] = cache;
    }
    if (field) {
      if(!(cache instanceof Array))
        return
      for (var ret, i = cache.length - 1; !ret && i >= 0; ret = cache[i--][field]);
      cache = ret;  
    }
    return cache;
  }
};
},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../../base')
  , valueBase = require('../../value/base')
  , vigour = require('../../')
  , util = require('../../util')
  , elementBase = new base()

elementBase.defaultType = valueBase.type

module.exports = exports = vigour.Element = elementBase.Class
exports.base = elementBase

var _doc = typeof document !== 'undefined' ? document : 'no document', //reference to document is faster than using window.document;
  /**
   * Removes children from parent node
   * @method _removeChildren
   */
  _removeChildren = function() {
    for (var c = this._node.childNodes, i = 0, l = c.length; i < l; i++) {
      if (c[i].base) {
        // console.log
        c[i].base.remove(false, false, true);
      }
    }
  };

/**
 * node
 * adds and clones html nodes;
 * @attribute
 */
exports.base.extend({
    name: 'node',
    type: false ,
    /**
     * Defines what happens when node is set
     * @method set
     * @param  {*} val Defines the value of this._node
     */
    set: function(val) {
      //changing node bugs /w conversions
      //iframe selectors dont evaluate to a string
      if (val instanceof Object || !val.length) {
        this._node = val;
      } else {
        this._node = _doc.createElement(val);
      }
      this._node.base = this;
    },
    /**
     * Defines what happens when you get node
     * @method get
     */
    get: function() {
      if (!this._node) {
        this.node = _doc.createElement('div');
      }
      return this._node;
    },
    /**
     * Defines what happens when you create a new node
     * @method new
     * @param  {Object} from    Target
     * @param  {[type]} newnode [description]
     */
    "new": function(from, newnode) {
      if (!newnode) {
        var node = from._node;
        if (node) {
          this._node = node.cloneNode(true); //especialy good to do for memory (also saves 20% on cpu)
          this._node.base = this;
        }
      } else {
        this._node = newnode;
      }
      if (from._node && from._node.hasChildNodes()) {
        var i, c = this._node.childNodes,
          cf = from._node.childNodes,
          l = c.length,
          ci, cfb;
        for (i = 0; i < l; i++) {
          cfb = cf[i].base;
          if (cfb) {
            c[i].base = new cfb.Class(false, false, c[i]);
            //maybe call children new stuff with a custom setting as well?
            if (cfb._name) {
              c[i].base._name = cfb._name;
              this[cfb._name] = c[i].base;
            }
            c[i].base.setting('parent', [this]);
          }
        }
      }
    },
    /**
     * Defines what happens when you remove a node
     * @method remove
     * @param  {*}  [param] If param doesn't remove node from parent
     */
    remove: function(param) {
      _removeChildren.call(this);
      if(this._node) this._node.base = null //little slow optimize later
      if (!param) {
        var _p = this._node.parentNode;
        if (_p) {
          _p.removeChild(this._node);
          if (this._name && _p.base) {
            _p.base[this._name] = null;
          }
        }
      }
    }
  },
  /**
   * Set css class of a div
   * Use addClass or removeClass to add/remove a class
   * @attribute css
   * @param  {Object} val [description]
   * warning: the add operator in css is currently used by .name,
   * and will be replaced when you try to build a string
   * using {val: .... add: ....}
   */
  {
    // __$css: function(val) {
      // this.css
    // }
    css: function(val) {
      var _val = val.val || '';
      val._skip = true; //_skip is an ugly name
      if(val.addClass){
        if (!~_val.indexOf(val.addClass.val)) {
          val._val = ((_val.length > 0 ? _val + ' ' : '') + val.addClass.val);
          if(val.add) val._val = val._val.replace(val.add.val,'')
          val._lval = false;
          val.__lval = false;
          val.___lval = false;
          _val = val.val;
        }
        val.addClass.remove();
      }

      if(val.removeClass){
        if (_val && val._val) {
          val._val = val._val.replace(new RegExp(' ?' + val.removeClass.val), '');
          val._lval = false;
          val.__lval = false;
          val.___lval = false;
          _val = val.val;
        }
        val.removeClass.remove();
      }

      if( _val ) {
        this.node.className = _val.replace('$','')
      } else {
        this.node.className = ''
      }
    }
  },
  /**
   * Makes it possible to reference a child by name
   * Setting on a class does not update names of instances
   * Element[NAME]
   * @attribute name
   */
  {
    name: 'name',
    type: false,
    set: function(val) {
      var _p = this.parent;
      if (this._name) {
        if (_p) {
          _p[this._name] = null;
        }
      }
      this._name = val;
      if (!this._node || val !== this.node.nodeName.toLowerCase()) {
        //name does not inherit, beware!
        // console.log('WHATS THIS?',val);
        // this.css = {addClass:val};
        // this.className = this._name;
        if(!this.css || this.css._val!==val)this.css = { add: ' ' + val }
        //special name field?
      }
      if (_p) {
        _p[val] = this;
      }
    },
    get: function() {
      return this._name;
    }
  },
  /**
   * Returns parent base element
   * @attribute parent
   */
  {
    name: 'parent',
    type: false,
    get: function() {
      if (this._node) {
        var _p = this._node.parentNode || this._p;
        return _p ? _p.base || _p._p : false;
      }
    }
  },
  /**
   * Returns childNodes /w base classes array slow, cache if possible
   * @attribute children
   */
  {
    name: 'children',
    type: false,
    get: function() {
      if(!this._node) return []
      var c = this._node.childNodes,
        l = c.length,
        _c = new Array(l),
        i;
      for (i = 0; i < l; i++) {
        _c[i] = c[i].base || c[i];
      }
      return _c;
    }
  });

var recurRender = function(parent) {

  if (!this.lastindex) this.setting('render', [parent]) //execute render settings

  if (this.renders) {

    // console.error('RENDER ---', this.name, this.renders)

    for (var p
      , c = this.node.childNodes
      , cl
      , arr = this.renders
      , obj
      , i = this.lastindex || 0, l = arr.length; i < l; i++) {
      obj = arr[i]

     if(obj) {
        p = util.checkArray(c, obj, 'base')
        if (p !== false) {
          recurRender.call(obj, this)
        } else if(obj._from) {

          // console.log('CLASS!',obj, obj.name && this[obj.name] && this[obj.name] === cl)

          cl = obj.Class

          if(obj.name && this[obj.name] && this[obj.name] === cl) {
            recurRender.call(this[obj.name], this)
          } else {
           for (var j in c) {
             if (c[j].base && c[j].base instanceof cl) {
               recurRender.call(c[j].base, this)
               break;
             }
            }
          }
        }
      }
      // arr.splice(i,1)
    }
  }

  this.lastindex = l
},

setRender = function() {
  var p, pp;
  if (this.parent) {
    p = this.parent;
    if (p.renders) {
      p.renders.push(this);
    } else {
      p.renders = [this];
      pp = p.parent;
      if (pp && !(pp._settings && pp._settings.render !== true)) {
        setRender.call(p);
      }
    }
  }
},

valRender = function(val) {
  var _settings = (val.__ && val.__._settings || val._._settings)
  if (val._.renders || val.__ && val.__.renders || _settings.render !== true) {
    if (!this.renders) this.renders = []
    if (!(this.__ && this.__.renders)) this.renders = util.clone(this.renders)
    // console.log(this.renders===this.__.renders, this.__.renders, this._.renders)

    // console.log(util.checkArray(this.renders,val._from))
    // console.log('XXXXXX',val)
    // if(util.checkArray(this.renders,val._from._from,'_from._from')===false&&util.checkArray(this.renders,val._from,'_from')===false) {
      this.renders.push(val)
    // }
    // console.log('renders push --- creates leaks!')
  }
}

//define vanuit base (korter!)
util.define(exports,
   'append', function(arr) {

    // alert('APPEND')
    // console.log('APPEND'.inverse,arr)

      var args = arguments

      if(arguments.length>1) {
        arr = util.arg(arguments)
      } //else if(arr )

      var insertbefore
      if(!arr.length && !(arr instanceof exports) && arr.val) {
        insertbefore = arr.before
        arr = arr.val
      }
      var Class = arr[0]
      , i = 0
      , l = arr.length
      if(!arr.length) {
        this.add(arr, insertbefore)
      } else if(typeof Class === 'function') {
        for(var i=1, l = arr.length;i<l;i++) {
          this.add(new Class(arr[i]), insertbefore)
        }
      } else {
        for(;i<l;i++) {
          this.add(arr[i], insertbefore)
        }
      }
  },
  'checkRender', function(val, notRendered) {
    if (val) valRender.call(this, val)
    if (!notRendered) {
      var _renders = (this.__ && this.__.renders || this._.renders)
      if ( ( (_renders  || ((this.__ && this.__._settings)  || this._._settings).render !== true)
          && (!this.lastindex || (_renders && this.lastindex < _renders.length))
        ) && this.rendered) {
        recurRender.call(this, this)
      } else {
        if(this.parent) valRender.call(this.parent, this)
      }
    }
  },
  'checkParent', util.checkParentFactory('parent'),
  'get',function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },
  'find', function(get, match, level) {
    if(level === void 0) level = true
    var children = this.node.childNodes
      , i = 0
      , found
      , child
      , len = children.length
      , passOn = level===true ? true : level-1
    for(;i<len;i++) {
      child = children[i].base
      if(child) {
        if(child.get(get, true)==match) {
          return child
        } else if(level) {
          found = child.find(get, match, passOn)
          if(found) return found
        }
      }
    }
  },
  'setRender', function(name, val) {
    this.setSetting({
      name: name,
      render: val
    });
    setRender.call(this);
    this.eachInstance(function() { //look for current caller instance perhaps?
      setRender.call(this)
    }, name);
  },
  'renders', false,
  /**
   * Add element as child
   * @method
   * @param  {Object}  val  Object to be added
   * @return {Object}       Returns the V.element
   */
  'add', function(val, insertbefore) {
    
    if(insertbefore) {
      if(typeof insertbefore === 'string') insertbefore = this[insertbefore]
      if(insertbefore) {
        this.node.insertBefore(val.node, insertbefore.node || insertbefore)
      } else {
        console.error('cannot find insertbefore')
      }
    } else {
              // console.error(val)

      this.node.appendChild(val.node)
    }

    val.setting('parent', [this]) //execute parent settings
    if (val.name) this[val.name] = val
    //--------------------
    //needs cleaning costs 3% now...
    this.checkRender(val)
    //--------------------
    return this
  },
  /**
   * Removes all children
   * @method empty
   * @param  {Boolean} instances True will remove all instances of children removed
   */
  'empty',
  function(instances) {
    var c = this.node.childNodes
      , i
    this.node.innerHtml = ''
    for (i = c.length - 1; i >= 0; i--) {
      if (c[i].base) c[i].base.remove(instances)
    }
  });

exports.base.addSetting('parent')
exports.base.addSetting('render')
require('./set')
},{"../../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../../base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../value/base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/base.js","./set":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/set.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/collection/display.js":[function(require,module,exports){
var collection = require('./util')

exports.prepare = function(el) {
  if(!el.display) el.display = 'block'
}

exports.newElement = function(data, element, t) {
  var c = collection.children(t)
  for(var i in c) {
    if(c[i]._d && c[i]._d===data) {
      c[i].display = element.display.val
      return true
    }
  }
}
 
exports.rem = function (el, t, hasFilter, noResolve) {
 el.display = 'none'
 return true
}

exports.fragment = function(a,b,exclude,i) {
  //since it never removes excludes should never be applied
  //exclude is normally used to not add things again if they already exist
  if(exclude) exclude[i]=null
}

},{"./util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/collection/util.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/collection/index.js":[function(require,module,exports){

var collection = require('./util')
  , util = require('../../../../util')

/**
 * collection
 * links arrays or object to elements
 * use filter if you want to convert
 * @attribute
 */

exports.extend = util.extend(
  require('../data'),
  function(base){

    base.extend({
      name:'collection',
      // render:function() {
      //   this.update('collection') 
      // },
      remove:function() {
        if(this._colElem) this._colElem.remove()
      },
      set: function(val, stamp, from, remove, change, added) {

        val._skip = true

        var hasFilter = collection.filter(val, this)
          , data = this.filter || val.val
          , options = this._colOptions || val.options 
              && (this._colOptions = val.options.convert())
          , orig =  val.element
          , el = this._colElem 
              || (orig && orig._val) && (this._colElem = new (orig._val.Class || orig._val)())
          , firstRun = !this._colInit
          , slStamp
          , elVal
          , colElem = this._colElem

          // console.log('!!!OPTIONS!', options)

        //dirty block! clean it FAST

        // || !this.rendered 

        if(!(data && el)) return //||!this.rendered
        
        slStamp = orig._slStamp
        elVal = orig._val

        if(slStamp) {
          orig._slStamp = stamp
        } else if(colElem && orig._slStamp !== stamp) {
          if(!(elVal.Class && (colElem instanceof elVal.Class)) 
            && !(!elVal.Class && (colElem instanceof elVal))) {
            el = this._colElem = new (elVal.Class || elVal)()
            orig._slStamp = stamp
          }
        }



        // console.log('ook leuk ff update', val, stamp, from, remove, change, added)
          // console.log('pass!')
          
        if(firstRun) {

          options && options.prepare && options.prepare(el)

          this._colInit = true
          this.node.appendChild(collection.fragment( data, el, this, false, options
            , hasFilter ))

        } else {

          if(from && from._parent === data.from) {
            if(remove) {
              var r = util.checkArray(collection.children(this),from,'_d',true)
              if(r) {
                if(!(options && options.rem && options.rem(r, this, hasFilter))) {
                  r.remove()
                }
              }
            } else if(util.checkArray(collection.children(this),from,'_d')===false) {

              collection.element( from, el, this, true, this.node, options, hasFilter, true )
            } else if(hasFilter && options && options.indexChange) {

                options.indexChange(
                  util.checkArray(collection.children(this),from,'_d',true)
                  , this, hasFilter )
            }
            
          } else {
            
            // console.log('122XXXXX', from, hasFilter, collection.filter(val, this)) //try to fix order by name better

            if(!from) {

              if(remove) {
                collection.clear(this, options)
              } else {

                var c = collection.children(this)
                  , exclude = {}
                  , name
                  , fField
                  , keys
                  , child

                // console.log('XXXXX',hasFilter) //try to fix order by name better
                if(hasFilter===true) {
                  keys = data.keys
                }

                for(var j in c) {
                  child = c[j]
                  name = c[j]._d._name

                  // console.log(c[j], hasFilter, keys, util.checkArray(data,child._d) === false)

                  if(hasFilter && !keys ? util.checkArray(data,child._d) === false : !data[name] || data[name]!==child._d ) {

                    // console.log('CHECK!---',j)

                    if(!(options && options.rem && options.rem(child, this, hasFilter, hasFilter))) {
                      child.remove()
                    }
                  } else {
                    //this is more efficient
                    // if(data[name]!==c[j]._d) c[j].data = data[name] 
                    exclude[name]=true
                    if(hasFilter) {
                      if(options && options.indexChange) {
                        if(child._d._indexCache[hasFilter][0]!==child.i) {
                          options.indexChange(child, this, hasFilter, true)
                        }
                      } else if(hasFilter===true) {
                        if(j!=util.checkArray(keys,name,true)) {
                          delete exclude[name]
                          if(!(options && options.rem && options.rem(c[j], this, hasFilter, hasFilter))) {
                            child.remove()
                          }
                        } 
                      }
                    }
                  }
                }

                this.node.appendChild(
                  collection.fragment(data, el, this, exclude, options, hasFilter)
                )
              }

            }
          }
        }
      }
    })
})
},{"../../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/data.js","./util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/collection/util.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/collection/util.js":[function(require,module,exports){
var element = require('../')
  , Data = require('../../../../data').inject(require('../../../../data/selection'))
  , util = require('../../../../util')

var r = function() {
  return String(~~(Math.random()*9))+''
}

exports.element = function (data, element, t, update, node, options, hasFilter, resolve) {
  var elem
  if(options && options.newElement) {
    elem = options.newElement.apply(this,arguments)
    if(elem===true) return
  }
  elem = elem || new element.Class()
  
  elem._col = true

//   console.log( '---->', data )

  if (data !== void 0) elem._dSet(data)
  if (node) node.appendChild(elem.node)
  elem.setting('parent', [t])
  ;options&&options.element&&options.element(elem, t, hasFilter, resolve)
  if (update && data !== void 0) elem.updateData()
  t.checkRender(elem, true)
  return elem
}

exports.fragment = function (data, element, t, exclude, options, hasFilter) {
  var frag = document.createDocumentFragment()
    , item = function(i) {
        //if you use the passed i it is a different value for selections
        if(this._name) i = this._name
        if(!(options&&options.fragment&&options.fragment(t,this,exclude,i))
          && (!exclude || !exclude[i]) ) {
          var elem = exports.element( this || null, element, t, false, frag, options
              , hasFilter)
          if(elem) frag.appendChild( elem.node )
        }
      }
  frag._p = t

  if(data.each) {
    data.each(item)
  } else {
    //normal data
    for(var i in data) {
      item.call( data[i] ,i )
    }
  }

  element.updateData(true)
  return frag
}

exports.children = function (t, options) {
  if(!t) return
  var ch = []
  for(var i in t.node.childNodes) {
    var child = t.node.childNodes[i].base
    if(child && child._col) {
      ch.push(child)
    }
  }
  ;options&&options.children&&options.children(ch)
  return ch
}

exports.clear = function (t, options) {
  t.colInit = null
  var c = exports.children(t)
  for(var i in c) { c[i].remove() }
  ;options&&options.clear&&options.clear(t)
}

exports.filter = function (val,t) {


  var data = val.val


  // console.log('DO I HAVE FULTER!>?',data,  val, t)


  if(val.filter && val.filter.val===true) {
    // console.log('sort by name') moet beter
        // console.log('got it!DATAx!')

    return true
    //different vibes
  }

  if (data && val.filter && !t.filter) {

    // console.log('MAKE NEW STYUFFF')

    var a = val.filter.raw
    //dit is kapot
    data = t.filter = new Data(data, a)

    // console.log('FILTERSSSS!', a, t)
    // debugger

    a._col = true
    
    data.addListener(function (val, stamp, from, remove) {
      t.collection._update(val, stamp, from, remove)
    })
    
    t.setSetting({
      // name: 'collecitonfilter',
      remove: function () {
        t.filter.remove()
        t.filter = null
      }
    })

    // console.log('DATAx!')
    return data._uid
    // return t.filter._uid//data is filter
  } else if(data && data._filter) {
        // console.log('DxxxATAx!')

    return data._uid
  } 
  else if(t.filter) {

    return t.filter._uid
  }

    // console.log('NO DATAX! FILTER', t)

}

// exports.indexChange = function(el, t, hasFilter, noResolve) {
// var oldIndex = el._d._indexCache[hasFilter][1]
//     , newIndex = el._d._indexCache[hasFilter][0]
//     , ch = !noResolve && collection.children(t,exports)
//     , l


//   exports.xy(el)

//   if(noResolve) return

//   l = ch.length
  
  
//   var clone = el.node.cloneNode(true)
//   t.node.removeChild(el)
//   el._node = clone


   
//   // t.h = t.node.scrollHeight
// }
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/index.js","../../../../data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","../../../../data/selection":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/selection.js","../../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var data = require('../../../data/base')
  , util = require('../../../util')
  , flags = require('../../../value/flags')

/**
  * extends updateData to take childNodes into account
  * may need to add extra argument for go deep
  * @method
*/
exports.extend = util.extend([ data, {
  updateData: function ( instances, data, fmodel ) {

    // console.log('????----------->>>>>')
    if (this._d) {
      this._subscribed = false
      data = this._d
    }

    var ffmodel = false

    // console.log(fmodel, this.model)
    //dit is omdat er geen model property is op het ding waar data op wordt gebinded dan default ie naar models die er wel zijn
    //oplossing maak model aan altijd als data en niet dfrom

    if (!fmodel && !this.model && !this._fmodel) ffmodel = true
    //fmodel is first model
    for (var children = this.node.childNodes
      , i = children.length - 1
      , base; i >= 0; i--) {
      base = children[i].base
      if (base
      && (!(base.model && base.model.inherit && base.model.inherit.val===false))
      && (base._d === void 0 || base._dfrom)) {
        if (base.model && data) {
          if (ffmodel) base._fmodel = true

          // console.log('FMODEL! -- dSet', data)
          // console.log('------ XXXXXXXXXXXXXXXXX', ffmodel, base._name, '\n', base, data )
          base._dSet(data, true)
        }
        base.updateData(instances, data, base._fmodel || fmodel)
      }
    }
  }
}])

},{"../../../data/base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/base.js","../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../../value/flags":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    here some basic html properties are added to V.Element.Nessecary
    for values that you want to be able to bind to V.Objects
    Uses base.extend -- see core.base for more information
  */

var ua = require('../../ua')
  , css = require('../../css')
  , Value = require('../../../value')
  , util = require('../../../util')
  , hash = require('../../../util/hash')
  , raf = require('../../animation/raf')
  , _load = require('../').images = {}
  , _transform = ua.prefix + 'Transform'
  , _cssTransform = ua.prefix + '-transform'
  , body = document.body.style
    //think about doc ready event or fallback if no body
  , _translate = body.perspectiveProperty != void 0
                 || body.WebkitPerspective != void 0
                    ? ['translate3d(', ',0px)']
                    : ['translate(', ')']
  , _coordinate = function(style) {
      var margin = 'margin' + (style[0].toUpperCase() + style.slice(1));
      return function(val) {
        if(val.clean) {
          _cleanCoordinate.call(this,style,margin)
          val.clean = null
        }
        if (val.translate) {
          this.translate(val)
        } else {
          this.node.style[this.relative ? margin : style] = val.val + 'px'
        }
      }
    }
  , _clearTransform = new RegExp(_cssTransform+'(.*?);')
  , _clear =
    { x: /(margin-left(.*?);)|(left(.*?);)/g
    , y: /(margin-top(.*?);)|(top(.*?);)/g
    }
  , _cleanCoordinate = function( check ) {
      var t = this._t
      , keep = false
      , val = this[check]
      , cssText = this.node.style.cssText.replace( _clear[check], '' )

    if( val && val.translate && val.translate.val===false) val.translate = null

    if(this.node.style[_transform] && !val.translate) {
      if(t) {
        if(!this[check].translate) {
          for(var i = 2 ; i < 6 ; i++) {
            if(t[i])keep=true
          }
        } else {
          keep=true
        }
      }
      if(!keep) cssText = cssText.replace(_clearTransform,'')
    }
    this.node.style.cssText = cssText
  }

exports.extend = util.extend(function(base) {
  util.define(base.Class,
    'cleanCoordinates', function(coord) {
       if(this._node) {
        if(!coord) {
          _cleanCoordinate.call(this,'x')
          _cleanCoordinate.call(this,'y')
        } else {
          _cleanCoordinate.call(this,coord)
        }
      }
    },
    'translate', function(val) {
    var _x
      , _y
      , _val =  val.val
      , _scale
      , _rotate
      , _rotateY
      , _rotateX
      , _str = ''
      , _name = val && val._prop.name
      , _t = this._t = this._t || []
      , nope = false

    //cirtical performance point hence use of | 0
    if (_name === 'x') {
      _x = _val | 0
      if (_x === _t[0]) nope = true
    } else if (_name === 'y') {
      _y = _val | 0
      if (_y === _t[1]) nope = true
    } else if (_name === 'rotate') {
      _rotate = _val
      if (_rotate === _t[2]) nope = true
    } else if (_name === 'scale') {
      _scale = _val
      if (_scale === _t[3]) nope = true
    } else if (_name === 'rotateY') {
      _rotateY = _val
      if (_rotateY === _t[4]) nope = true
    } else if (_name === 'rotateX') {
      _rotateX = _val
      if (_rotateX === _t[4]) nope = true
    }

    if (!nope) {
      _t[0] =  _x || (this.x.translate && this.x.val | 0) || 0
      _t[1] =  _y || (this.y.translate && this.y.val | 0) || 0
      _t[2] = _rotate || this.rotate.val
      _t[3] = _scale || this.scale.val
      _t[4] = _rotateY || this.rotateY.val
      _t[5] = _rotateX || this.rotateX.val
      if (_t[0] || _t[1]) {
        _str = _str
          .concat(
            _translate[0]
          + _t[0] + 'px,'
          + _t[1] + 'px'
          + _translate[1]
          )
      }
      if (_t[2]) { _str = _str.concat(' rotate(' + _t[2] + 'deg)') }
      if (_t[3]) { _str = _str.concat(' scale(' + _t[3] + ')') }
      if (_t[4]) { _str = _str.concat(' rotateY(' + _t[4] + 'deg)') }
      if (_t[5]) { _str = _str.concat(' rotateX(' + _t[5] + 'deg)') }
      this.node.style[_transform] = _str
    }
    return this
  }, 'update', function() {
    for (var i = 0, _args = util.arg(arguments), l = _args.length, p; i < l; i++ ) {
      if (_args[i] instanceof Array) {
        this.update.apply(this, _args[i]);
      } else {
        p = util.get(this, _args[i]);
        if (p) {
          p.update(this);
        }
      }
    }
    return this;
  });

  function createScroll(dir){
    var s = 'scroll'
      , sdir = s + dir //scrollLeft or scrollTop

    return {
      name:sdir,
      set:function(val) {
        var v = val.val
          , self = this
        if(v !== void 0) self.node[sdir] = v
        if(!self.__sT){
          self.__sT = true
          self.addEvent(s,function(){
            if(val._listeners !== void 0) val.val = self.node[sdir]
            else self[sdir].__lval = void 0
          })
        }

      },
      get:function(val){
        if(val.__lval === void 0) val.val = this.node[sdir]
        return val
      },
      render:function() {
        var self = this
          , val = self[sdir].__lval
        if(val){
          raf(function(){
            self.node[sdir] = val
          })
        }
      }
    }

  }

  base.extend({
    name: 'relative',
    type: false,
    get: function() {
      var s = this.position !== false ? this.position.val : (this.position = {
        css: true,
        val: css(this.css.val, 'position')
      })
      return s !== 'absolute'
    }
  },
  {
    type: false,
    name: 'rendered',
    get: function() {
      var ret = this._rendered || (this.node === document.body),
        parent;
      if (!ret) {
        parent = this.node.parentNode;
        while (!ret && parent) {
          if (parent.base && parent._rendered) {
            ret = true;
          }
          if (parent == document.body) {
            ret = true;
          }
          parent = parent.parentNode;
        }
        if (ret) {
          this._rendered = true;
        }
      }
      return ret;
    }
  },
  createScroll('Left'),
  createScroll('Top'),
  {
    position: function(val) {
      // console.log('?????',val.css.val)
      // if (!val.css) { //check when ignoring this becomes a problem
        this.node.style.position = val.val;
      // }
    },
    // scrollTop:function(val) {
    //   console.error(val.val)
    //   this.node.scrollTop = val.val
    // },
    rotate: function(val) {
      this.translate(val);
    },
    rotateY: function(val) {
      this.translate(val);
    },
    rotateX: function(val) {
      this.translate(val);
    },
    scale: function(val) {
      this.translate(val);
    },
    src: function(val) {
      var v = val.val;
      if (v && v[v.length - 1] !== '/') {
        this.node.src = v;
      }
    },
    attr:function(val) {
      var t = this
      val.each(function(i) {
        t.node.setAttribute(i,this.val)
      })
    },
    backgroundPos: function(val) {
      this.node.style.backgroundPosition = val.val
    },
    backgroundBatch: function(val) {


    },
    background: function(val) { //optional maybe in a seperate module
      var v = val.val
        , t = this
        , style = this.node.style
        , url
        , hashed
        , parentBatch
        , batch

      if(val.gone && val.gone.val) {
        val._skip = true
        style.backgroundImage = ''
      } else if (v && v[v.length - 1] !== '/') {
        url = 'url(' + v + ')'
        if(style.backgroundImage===url) return

        //Value
        if (val.size) style.backgroundSize = val.size.val

        if (val.load) {

          hashed = hash(v)
          parentBatch = this.checkParent('backgroundBatch')
          if(parentBatch) batch = parentBatch.backgroundBatch

          if(!_load[hashed]) {
            this._loaded = null
            //also remove setting

            if(batch) {
              window.cancelAnimationFrame(batch._raf)
              if(!batch.batch) batch.batch = []
              batch.batch.push(hash)
            }

            _load[hashed]=new Value(false)
            var img = document.createElement('img')
            img.onload = function() {

             if(batch) {
               batch.batch.splice(util.checkArray(batch.batch,hashed),1)
               if(batch.batch.length===0) {
                batch.batch = null
                batch._raf = raf(function() {
                  if(parentBatch._node) batch._val.call(parentBatch)
                })
               }
             }

              _load[hashed].val = true
              img.onload = null
              img = null
              _load[hashed].remove(false,false,false,false,false,true)
              _load[hashed] = true
            }
            img.src = v
          }

          if(_load[hashed]!==true) {
             this._loaded = null

            _load[hashed].addListener([function() {
              if(val.load && val.load.val!==true) val.load._val.call(this, t);
            },val._base], true)
          } else {

            this._loaded = true

            if(batch) {
              if((!batch.batch) || batch.batch.length===0) {
                batch.batch = null
                window.cancelAnimationFrame(batch._raf)
                batch._raf = raf(function() {
                   if(parentBatch._node) batch._val.call(parentBatch)
                })
              }
            }

            if(val.load.val!==true) val.load._val.call(this, t);

          }
        }

        style.backgroundImage = url

      }
    },
    padding: function(val) {
      this.node.style.padding = val.val + 'px';
    },
    y: _coordinate('top'),
    x: _coordinate('left'),
    display: function(val) {
      this.node.style.display = val.val;
    },
    w: function(val) {
      // console.log('w');
      var v = val.val
      this.node.style.width = (v > -1 ? (v | 0)  + 'px' : v ) || '100%' 
    },
    h: function(val) {
      // var v = val.val | 0 typo or bug?
      var v = val.val
      this.node.style.height = (v > -1 ? (v | 0)  + 'px' : v ) || '100%'
    },
    opacity: function(val) {
      var v = val.val;
      this.node.style.opacity = v > -1 ? v : 1;
    },
    html: function(val) {
      var v = val.val || ''
      if( v.replace )
      {
        //add some injection prevention as option? (no script etc)
        v = v.replace(/\t/g, '    ')
             .replace(/\r\n|\n|\r/g, '<br/>')
             .replace(/  /g, '&nbsp; ')
             .replace(/  /g, ' &nbsp;') // second pass
                                        // handles odd number of spaces, where we
                                        // end up with "&nbsp;" + " " + " "
        this.node.innerHTML = v
      }

    },
    href: function(val) {
      this.node.href = val.val;
    },
    text: function(val) {

      // console.log('SETTING TEXT'.green.inverse. val.val, val)

      var node = this.node
        , nodes = node.childNodes
        , v = val.val || ''

      if(v instanceof Object) v = ''

      if (/text/.test(node.type)) {
        node.value = v;
        return;
      }

      if (nodes) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (nodes[i].nodeType === 3) {
            // console.log('BLABLA'.inverse,v)
            nodes[i].nodeValue = v;
            return;
          }
        }
      }
      node.appendChild(document.createTextNode(v));
    }
  });
});
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../../util/hash":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/hash.js","../../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../../animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","../../css":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/css.js","../../ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../../../util')

exports.extend = util.extend(function(base) {
  var proto = base.Class.prototype
    , add = proto.add

  util.define
  ( proto
  , 'add'
  ,  function(val) {
       if( !val.process )
       {
          add.apply( this, arguments )
       } else
       {
          val.__tempAdd = util.arg( arguments )
          val.__tempAdd.unshift(this)
       }
     }
  )

  base.extend({
    process: function(val) {
      console.log('xxxx___xxxx')
      if(this.__tempAdd && !this.parent) {
        add.apply(this.__tempAdd[0], this.__tempAdd.slice(1))
        this.__tempAdd = null
      }
    }
  })

})

//process wordt mischien meer een operator?
//soort field eigenlijk
},{"../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/scrollbar.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = require('../../events')
  , cases = require('../../cases')
  , ua = require('../../ua')
  , global = false
  , NONE = 'none'
  , _ios = ua.platform==='ios'
  , _android = ua.platform==='android'
  , VISIBLE = 'visible'
  , extend = require('../../../util').extend
  , doc = events.document
  , timer
  , fn

if(cases.touch){

  function blur (e){
    if(!document.activeElement){
      doc.removeEvent(false,'blur')
    }else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM'){
      document.activeElement.blur()
      doc.removeEvent(false,'blur')
    }
  }

  events.preventDown = 
  { val:
    { down:function(e,method) {
        if(document.activeElement) doc.addEvent('up',blur,'blur')
        else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM' && !events._maybescroll) e.preventDefault()
      }
    }
  }

  events.scrollbar = 
  { val: 
    { down:function(e,method,val) {

        var scrollStart
          , t = this
          , scrollStr
          , xAxis = (val._val === 'x')
          , axis
          , otheraxis
          , move
          , d
          , bottomPrevent
          
        if(xAxis) {
          axis = 'x'
          otheraxis = 'y'
          scrollStr = 'scrollLeft'
          d = t.node.scrollWidth - t.node.offsetWidth
        }else{
          axis = 'y'
          otheraxis = 'x'
          scrollStr = 'scrollTop'
          d = t.node.scrollHeight - t.node.offsetHeight
        }

        scrollStart = t.node[scrollStr] //<======== less efficient but more predictable for compensation

        if(d > 0){
          events[axis] = true
          events._maybescroll = true
          if(!xAxis){
            if (!scrollStart){
              scrollStart = t.node[scrollStr] =  1
            }else if(scrollStart===d) {
              scrollStart = t.node[scrollStr] = d - 1
            }else if(scrollStart > d){
              bottomPrevent = true
            }
          }

          var y = e.y
            , x = e.x
            , moveid = scrollStr + axis
          
          doc.addEvent('move',function(e){
            var dx = Math.abs(x-e.x)
              , dY = y-e.y
              , dy = Math.abs(dY)

            if(xAxis){
              if(dy > dx){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
            }else{
              if(dx > dy){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
              if(bottomPrevent && dY > 0){
                e.preventDefault()
              }
            }
            console.log('move')
            move = true
            blur(e)
            doc.removeEvent(false,moveid)
          },moveid)

          doc.addEvent('up',function(e) {
            var ms = events._maybescroll, msl, arr

            if(!move){
              var scrll = t.node[scrollStr]
              move = !(scrll === scrollStart) || scrll < 0 || ( scrll > d && !bottomPrevent )
            }

            if(!move && !events[otheraxis] && !events.click.block && ms && ms.length){
              msl = ms.length
              while(msl--) if(!e.prevent){
                arr = ms[msl]
                arr[0].call(arr[1],e)
              }
            }

            if(!events[otheraxis] || move) events._maybescroll = false

            events[axis] = false
            doc.removeEvent(false,scrollStr)

            window.requestAnimationFrame(function(){
              document.body.scrollTop = 0
            })
          },scrollStr)
        }
      }
    }
  }

  fn = function (val) {
      
    var style = this.node.style

    if (val.val === 'x') {
      style.msTouchAction = 'pan-x'
      style.touchAction = 'pan-x'
      style.overflowY = 'hidden'
      // style.overflowX = 'scroll'
    }else if (val.val === 'y') {
      style.msTouchAction = 'pan-y'
      style.touchAction = 'pan-y'
      style.overflowX = 'hidden'
      // style.overflowY = 'scroll'
    }

    style.overflow = 'scroll'

    style.webkitOverflowScrolling = 'touch'
    style.msTouchAction = 'auto'
    style.touchAction = 'auto'

    this.events = { scrollbar:val.val }
    if(!global) {
      global = true
      doc.events = { preventDown:true }
    }
  }

}else{
  fn = function (val) {
    var style = this.node.style;
    style.overflow = 'auto';
    style.overflowY = val.val !== 'x' ? 'scroll' : 'hidden';
    style.overflowX = val.val !== 'y' ? 'scroll' : 'hidden';
  }
}

exports.extend = extend(function(base) {
  base.extend({ scrollbar:fn })
})  
},{"../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","../../events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js","../../ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/util.js":[function(require,module,exports){
var ua = require('../../ua')
  , _prefix = '-'+ua.prefix.toLowerCase()
  , _transform = _prefix + '-transform'

exports.getMatrix = function(node) {
  if(node.style[_transform]) {
    var arr = window.getComputedStyle(node, null)
      .getPropertyValue(_transform).replace('matrix(', '').split(',')
    return arr
  }
}

// exports.hasCalc = function() {
//   var dummy = document.createElement('div')
//     , props = [ _prefix+'-calc', 'calc' ]
//     , i = props.length
//   while(i-1) {
//     dummy.style.cssText = 'width:' + props[i-1] + '(1px);'
//     if (dummy.style.length) return props[i-1]
//     i--
//   }
// }
},{"../../ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/set.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var util = require('../../util')
  , element = require('./')
  , object = require('../../object')

/**
 * flags
 * add keywords to set objects which are checked using a function in flags
 * simply add fields to the set module
 */
var flags = exports
  /**
   * _flag
   * function that calls flag functions on element.set.flags
   */
  , _flag = function(name, val, copy, top) {
      var f;
      for (var i in flags) {
        f = flags[i].call(this, name, val, copy, top);
        if (f) {
          return f;
        }
      }
    }

util.define(element,
  /**
   * set
   * adds children for non existing attributes
   * _original are original values changed by cases and events
   * instances - add or remove children from instances;
   */
  '_set', function(val, i, instances) {
    //this
    if (!_flag.call(this, i, val[i], instances, val)) {

      if ( !this.isProperty( i, val ) ) {

        if (val[i] instanceof element) {
          var before
          if (this[i]) {
            for(var c=this.node.childNodes,node$=0,len=c.length;node$<len;node$++) {
              if(c[node$]===this[i].node) {
                before = c[(node$+1)]
                break;
              }
            }
            this[i].remove && this[i].remove();
          }
          //replace element if its already there
          // console.error(add, instances, val[i])
          var add = instances ? new val[i].Class : val[i];
          add.name = i;
          this.add(add, before);
          if (instances) {
            this.eachInstance(function() {
              var a = new add.Class();
              a._name = i;
              this.add(a);
            });
          }
        } else {
          
          if( this[i] instanceof object ) 
          {
            //TODO: torough testing
            this[i].val = val[i]
          } 
          else if( val[i] instanceof object ) 
          {
            console.warn('are you sure you want to set using a vObject? maybe require some stuff (e.g. data)')
            this[i] = val[i]
          } 
          else if( this[i] instanceof element ) 
          {
            if( val[i] ) {
              this[i].set(val[i], instances)
            } else if( val[i] === false ){
              if ( instances ) {
                this.eachInstance(function() {
                  if (this[i]) this[i].remove()
                })
              }
              this[i].remove()
              this[i] = null
            }
          } 
          else 
          {
            if(val[i] instanceof Object ) {
              var add = new element().set(val[i], instances)
              add.name = i;
              this.add(add)
              if (instances)
              {
                this.eachInstance( function() {
                  var a = new add.Class()
                  a._name = i
                  this.add(a)
                })
              }
            } else {
              console.warn('"' + i + '" is not an existing property. "' + val[i] + '" is a primitive. Adding as primitive.' )
              this[i] = val[i]
            }

          }
        }
      } else {
        if(typeof this[i] === 'function') {
          if(val[i] instanceof Array) {
            this[i].apply(this,val[i])
          } else {
            this[i](val[i])
          }
        } else {
          this[i] = val[i]
        }
      }
      //dynamic changes to the _original set object pool
      //if (!copy && this._original) {
      //this._original[i] = val[i]; //check if stuff /w classes is nessecary;
      //}
    }
  },
  /**
   * convert
   * for each fields in val convert back to a setObject;
   */
  'convert', function(val) {
    var setObj = {},
      isObj;
    for (var i in val) {
      isObj = util.isObj(val[i])
      if (this[i] instanceof element) {
        setObj[i] = isObj ? this[i].convert(val[i]) : this[i]
      } else if (this[i] instanceof object) {
        setObj[i] = this[i].convert(isObj && val[i])
      } else if (this[i] === void 0 || (util.lookup.call(this, i) && this[i] === false)) {
        setObj[i] = false
      } else {
        setObj[i] = this[i]
      }
    }
    return setObj
  })
},{"../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/video/html5.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
//duration in a V.Value --> update if nessecary?
var ua = require('../../ua')
  , video = require('./')
  , postpone = require('../../../browser/events/util').postpone
  , _winPhone = ua.platform === 'windows' && ua.device === 'phone'
  , _ios = ua.platform === 'ios'
  , _android = ua.platform === 'android'
  , _canplay = 'canplay' 

function createListener () {
  var a = arguments
    , l = a.length
  return function(val) {
    for (var i = 0, t = this; i < l; this.video.addEventListener(a[i++]
      , function(e) { val._val.call(t,e) }));
  }
}

function _canplayListener () {
  if (!this._canplay && !_winPhone) { //later versions (if fixedin 9)
    this._canplay = true
    var t = this
    
    function canPlay() {
      if (t.time) {
        if (!t.time.val) this._firstT = true
          //fixes for phonegap! windowsmobile
        if (_android && ua.browser !== 'chrome') { 
          //and special browser!; check firefox; //identify more browsers that do not need this crap
          var tries = 0
          clearInterval( t._timeFixInterval )
          t._timeFixInterval = setInterval(function() {
                t.updateTime()
                if (tries === 3) {
                  t._canplay = null
                  clearInterval(t._timeFixInterval)
                }
                if (t.video.duration !== 1) { //android sets duration to 1 as default instead of 0
                  tries++
                  if (t.playing) t.video.play()
                }
              }, 200)
        } else {
          if (t.time.val) {
            if (_ios) {
              setTimeout(function() { t.updateTime() }, 0)
            } else {
              t.updateTime()
            }
          } else {
            t._forceTime = true 
          }
          t._canplay = null
        }
      }
      if(t.video) t.video.removeEventListener(_canplay, canPlay)
    }

    this._canPlay = canPlay
   
    if(this.video) this.video.addEventListener(_canplay, canPlay)
  }
}

function setTime (val) {
  if (this.video.readyState) {
    this.video.currentTime = val
    if (_ios) this._correctTime = val
  } else {
    _canplayListener.call(this)
  }
}


module.exports =  
{ progress: {
    set: function() {
      var t = this;
      if(t.video) t.video.addEventListener('end', (t._prEnd = function() {
        t.clearProgress()
      }))
    },
    remove: function() {
      if(this.video)
      {
        this.video.removeEventListener('canplay',this._canPlay)
        this.video.removeEventListener('end', this._prEnd) //maybe no play and pause!;
      }
    }
  }
, buffer: function(val) {
    if (this.video && this.video.buffered) {
      var l = this.video.buffered.length
        , piv = -1
        , t = this.video.currentTime || 0
        , ls
        , tt
        , i = 0
      
      for (; i < l; i++) {
        ls = this.video.buffered.start(i)
        if (ls > piv && ls < t) {
          piv = i
          tt = ls
        } else {
          break
        }
      }
      if (piv > -1) {
        piv = this.video.buffered.end(piv)
        return piv < t ? 0 : piv / this.duration.val
      } else {
        return 0
      }
    }
    return 0
  }
, play: function(val) {
    if (val) {
      this.video.play()
    } else {
      this.video.pause()
    }
  }
, time: 
  //tests for android , winphone, firefoxphone (seeking on winphone is not possible anyways)
  { set: _ios  || _android //ua.device === 'phone' || ua.device === 'tablet'
      ? postpone(setTime)
      : setTime
  , get: function(val) {
      var time = this.video && this.video.currentTime
      if (this._correctTime) {
        if (this._correctTime > time - 2 && this._correctTime < time + 2) { //|| this.cnt
          time = this._correctTime
          if (!this.cnt) {
            this.cnt = 3
          } else if (this._cnt < 2) {
            this._correctTime = false
            this._cnt = false
          } else {
            this._correctTime+=0.5 //should be interval of progress updates
            this._cnt--
          }
        } else {
          time = this._correctTime
        }
      }
      return time / this.duration.val || val.val
    }
  }
, duration: function(val) {
    if ( this.video && this.video.readyState ) {
      return this.video.duration
    } else {
      return val && val.val
    }
  }
, autoplay: function(val) {
    if( this.video ) this.video.autoplay = val.val
  }
, volume: function(val) {
    var volume = val.val
    if(this.video && !isNaN(volume)) this.video.volume = volume
  }

, "new": function() {
    // this.addEvent('down',function(e){ e.preventDefault() })
    _canplayListener.call(this)
    if (this.volume) this.volume.update(this)
  }
, events: {
    pause:function(val) {
      var t = this
      if(_ios && t.video) { 
       t.video.addEventListener('pause', function(e) {
         if(!t.ignoreevents) t.pause()     
       })
      }
    }
  , progress: video.progress
  , ready: createListener('loadedmetadata')
  , canplay: function(val) {
      var t = this
      if(t.video) t.video.addEventListener(_canplay, function(e) {
        if(t.video && t.video.readyState===4) {
          t._stalled = false
          val._val.call(t,e)
        }
      })
    }
  , stalled: function(val) {
      var t = this
        , listen = function(e) {
          var time = t.getTime()
          if(!(t.getBuffer(time)-time > 0.05)) {
            t._stalled = true
            val._val.call(t,e)
          }
        }
      if(t.video){
        t.video.addEventListener('stalled', listen )
        t.video.addEventListener('waiting', listen )
      }
    }
  , play: 
    { play: function() {
        if (this.events.play) this.events.play._val.call(this)
      }
    , set: false
    }
  , end: createListener('ended')
  }
, src: function(val) {
    if (this.video && ( this.video.src !== val || val || !val && this.video.src)) this.video.src = val.val
  }
}

if (!video.player) video.player = module.exports
},{"../../../browser/events/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js","../../ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/video/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/video/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var element = require('../').inject(require('../properties'))
  , events = require('../../events')
  , util = require('../../../util')
  , base = new element({
      node: 'video'
  })
  
module.exports = exports = base.Class
var video = exports
exports.base = base

base.setSetting(
{ name: '_videoSettings'
, new: function() {
    if (this.player.new) this.player.new.call(this)
  }
, remove:function() {
    if (this.player.remove) this.player.remove.call(this)
  }
, render:function() {
     if (this.player.render) this.player.render.call(this)
  }
})
//proxy adden --> should be an extension on src
base.node.setAttribute('webkit-playsinline', '')

//cloud shorten these 3 functions
function _vidEvents (val) {

  this._readyForEvents = true

//   console.log('\n\n\n\n\nn\n\n\nSET VIDEVENTS')

  var t = this
    , e = (this.player || video.player).events
  val.each(function(i) {
    if (e[i] && e[i].set !== false) (e[i].set || e[i]).call(t, this, i)
  })
  return e
}

function _removeVidEvents (val) {
  var t = this
    , e = (this.player || video.player).events

  val.each(function(i) {
    if (e[i] && e[i].remove) e[i].remove.call(t, this, i)
  })
}

function _playHook (param) {
  var val = this.events
  if (val) {
    var t = this
      , e = (this.player || video.player).events
    val.each(function(i) {
      if (e[i] && e[i].play) e[i].play.call(t, this, i, param)
    })
  }
}

function _progress(val) {

  // console.error('SET progress',this._progress)

  if (!this._progress) {

      // console.error('SET progress for REAL',this._progress)

    //maybe do this with requestAnimationFrame -- danger lies in incosistency with timing
    var params = val
      , interval = params.interval && params.interval.val || 500 
      , fn = params._val
      , t = this
      , pr = (this.player || video.player).progress

    if (pr && pr.set) pr.set.call(t)

    t._progress = setInterval(function() {

      // console.log('before progress call!',t.src.val)
      // if(t.playing&&!t.__paused) {
      //   // t.play()
      //   // no src!
      // }

      var p = Number(t.getTime())
        , b = t.getBuffer(p)
        , d = Number(t.duration.val)

      if(d===1) d=0 //android fix -- maybe remove

      if (p >= 1 && d) {
        // console.log('--->PAUSE!')
        // t.pause()
        // t.playing = false //should this be removed an go to end? 
        // //call pause and set time in here?
        t.clearProgress()
      } else {

        if(t._stalled && d) { //just to make sure buffering always dissapaers    
          if(b>0.85 || (t.__lp && t.events.canplay && (p > t.__lp+(1/d)))) { //in seconds
            t._stalled = false
            t.events.canplay._val.call(t)
            t.__lp = null
          } else if( (!t.__lp) && p>-1) {
            t.__lp = p
          } 
        }

        if(!t.ignoreevents) fn.call(t, p, b)
      }
    }, interval)
  }
}

this._progress = _progress

exports.progress = 
{ play: function(i, p, pa) {
    if (pa) {
      _progress.call(this, this.events.progress)
    } else {
      this.clearProgress()
    }
  }
, set: function(val) {
    if (this.playing) _progress.call(this, val)
  }
, remove: function() {
    this.clearProgress()
  }
}

util.define(exports
, 'setEvents', function() {
    _vidEvents.call(this, this.events)
  }
, 'play', function(clear, ignore) {
    if (clear) delete this.ignoreevents
    if (!ignore && !this.ignoreevents && this.playing !== true) {
        this.playing = true
        _playHook.call(this, true)
    } else if(this.__paused && this.events.progress) {
      this.playing = true
      _progress.call(this,this.events.progress)
    }
    this.__paused = null
    ;(this.player || video.player).play.call(this, true)
  }
, 'pause', function(ignore) {
    if(ignore) this.ignoreevents = true

    if (!this.ignoreevents && this.playing !== false) {
      this.playing = false
      _playHook.call(this, false)
      if(this.events.pause) {
        this.events.pause._val.call(this)
      }
    } else {
      this.clearProgress()
      // _playHook.call(this, false)
    }

    this.__paused = true
    ;(this.player || video.player).play.call(this, false)
  }
, 'toggle', function(val) {
    if (this.playing) {
      this.pause()
    } else {
      this.play()
    }
  }
, 'updateTime', function() {
    this._firstT = false
    exports.setTime.call(this, this.time)
  }
, 'getTime', function() {
    return (this.rendered && this.player || video.player).time.get.call(this, this.time) || 0
  }
, 'getBuffer', function(val) {
    return (this.rendered && this.player || video.player).buffer.call(this, val || 0)
  }
, 'clearProgress', function() {
    if (this._progress) {
      clearInterval(this._progress)
      this._progress = null
      var pr = (this.player || video.player).progress
      if (pr && pr.remove) pr.remove.call(this)
    }
  }
)

base.extend(
{ name: 'player'
, type: false
, set: function(val) {
    util.setstore.call(this)
    this.__.player = val
    if (val.element) this.node = val.element
    if (this._class) this._class.prototype._.player = val
  }
, get: function(val) {
    return util.getStore.call(this, 'player') || video.player || {}
  }
}
, 
{ name: 'duration'
, set: function(val) {}
, get: function(val) {
    val._overwrite = (this.player || video.player).duration.call(this, val)
    return val
  }
}
,
{
  name:'$play'
, set:function( val ) {
    if( this.rendered )
    {
      if( val.val )
      {
        this.play()
      }
      else
      {
        this.pause()
      }
    }
  }
}
, 
{ name: 'time'
, set: (exports.setTime = function(val) {
    if (!this._ignore) {

      val._overwrite = null
    
      var v = val.val
        , i = false

      if (v !== void 0) {
        if (!this._firstT || this._forceTime === true) { 
          v = Math.abs(v)
          i = true;
          this._firstT = true
          this._forceTime = null
        }

        if (v >= 0 && this.duration) {
          if(this.__lp) this.__lp = null
          ;(this.player || video.player).time.set.call(this, v * this.duration.val)
          if(this.events.seeking && !i)  this.events.seeking._val.call(this,v)
        }
      }
    }
  })
}
, 
{ autoplay: function(val) {
    (this.player || video.player).autoplay.call(this, val)
  }
, volume: function(val) {
    (this.player || video.player).volume.call(this, val)
  }
, src: function(val) {
    if(val.val!==this.___Src) {
      this.___Src = val.val
      if(this.events.src)  this.events.src._val.call(this,val)
      ;(this.player || video.player).src.call(this, val)
    }
  }
}
, 
{ name: 'events'
, "new": function() {
    if(  (this.player && this.player.setEvents !== false)) {
      _vidEvents.call(this, this.events)
    }
  }
, remove: function() {
    if(this.rafId)
    { 
      window.cancelAnimationFrame(this.rafId)
      this.rafId = null
    }
    _removeVidEvents.call(this, this.events)
  }
, set: function(val) {
    var a = util.arg(arguments)
    
      a[5] = this._readyForEvents 
           ? _vidEvents.call(this, val) 
           : (this.player || video.player).events 

      if(!a[5].seeking) a[5].seeking = {set:false}
      if(!a[5].src) a[5].src = {set:false}
    

    events._set.apply(this, a)
  }
})

},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../events":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js","../properties":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/video/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
exports.time = function(time, decimals) {
  var hrs = ~~ (time / 3600),
    mins = ~~ ((time % 3600) / 60),
    secs = decimals ? (time % 60).toFixed(decimals) : ~~(time % 60);
  ret = "";
  if (hrs > 0) ret += "" + hrs + ":" + (mins < 10 ? "0" : "");
  ret += "" + mins + ":" + (secs < 10 ? "0" : "");
  ret += "" + secs;
  return ret || 0;
};
},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/advanced.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var events = require('./')
  , operators = require('../../value/operators')
  , doc = events.document

module.exports = events

operators._e = function(val, operator) {
  return val + operator
}

operators._esub = function(val, operator) {
  return val - operator
}

operators._e.order = 3
  
function chooseMove (val, method) {
  return val.move && val.move._val 
    || !method.__t && method !== true && method 
    || method._val;
}

function drag (e, method, val) {
  var t = val.bind ? val.bind._val : this
    , move = chooseMove(val, method)
    , id = 'drag'
  e.preventDefault()
  if (move) doc.addEvent('move', function(e) {
    move.call(t, e, val)
  }, id)

  if (val.down) val.down._val.call(t, e, val)
  
  doc.addEvent('up', function(e) {
    if (val.up) val.up._val.call(t, e, val)
    doc.removeEvent(false, id)
  }, id)
}

function active (e, method, val) {
  var self = this
    , id = 'active'
    , timer = setTimeout(function(){
        self.css = {addClass:val._val}
        timer = null
      },50)

  if(exports._deactivate) exports._deactivate()

  exports._deactivate = function(){
    if(timer) clearTimeout(timer)
    doc.removeEvent(false,id)
    exports._deactivate = null
    window.requestAnimationFrame(function(){
      if(!self) return
      if(!self._stayActive) self.css = {removeClass:val._val}
      else self.css = {addClass:val._val}
    })
  }

  doc.addEvent('move',exports._deactivate,id)
  doc.addEvent('up',exports._deactivate,id)
}

function shallowRaw (vobj) {
  var obj = {}
    , keys = vobj.keys
    , key
    , i = keys.length - 1
  for (; i >= 0; i--) {
    key = keys[i]
    obj[key] = vobj[key]
  }
  return obj
}

function initGrab (t, e, val, name) {
  if (!t[name] || !t[name]._e) t[name] = { _e: 0 }
  if (val[name]._val !== true) t[name].set('_e', shallowRaw(val[name]))
  return e[name] - (t[name]._e.val)
}

function grab (e, method, val, nested) {
  var t = val.bind && !nested ? val.bind.val : this
    , id = ( val.y 
      ? 'y' 
      : val.x 
        ? 'x' 
        : 'xy') 
        + 'Grab' 
        + (nested || '')
  if (t) {
    if (t._node) {
      var move = chooseMove(val, method)
        , startX = e.x
        , startY = e.y
        , ready
        , cX
        , cY
        , oldX
        , oldY
        , newX = startX
        , newY = startY
        , pass
        , upFn = function(e) {
            t.x._p = false
            t.y._p = false
            if (val.up && pass) {
              val.up._val.call(t, e, {
                x: newX - startX,
                y: newY - startY
              },
              { x: newX - oldX
              , y: newY - oldY
              })
            }
            events.click.block = false
            doc.removeEvent(false, id)
          }
      if (!val.x && !val.y){ //this needs revision
        val.x = {_val: true}
        val.y = {_val: true}
      }
      if (val.down) val.down._val.call(t, e, val);
      doc.addEvent('move', function(e) {
        oldX = newX
        oldY = newY
        newX = e.x
        newY = e.y

        events.click.block = true

        if (!ready) {
          pass = val.pass ? val.pass._val.call(t, e, {
            x: newX - startX,
            y: newY - startY
          }) : true
          if(!pass) {
            upFn(e)
            move = false
            doc.removeEvent(false, id)
          } else {
            e.preventDefault()
            if (val.x) {
              cX = initGrab(t, e, val, 'x')
              t.x._p = 1
            }
            if (val.y) {
              cY = initGrab(t, e, val, 'y')
              t.y._p = 1
            }
            if (val.start) val.start._val.call(t, e, val)
            ready = true
          }
        }else{
          e.preventDefault() //for android
          if (cX) t.x = { _e: newX - cX }
          if (cY) t.y = { _e: newY - cY }
          if (move) move.call(t, e, {
              x: newX - startX,
              y: newY - startY
            },val) //check for speed
        }
      }, id)
      doc.addEvent('up', upFn, id)
    } else {
      for (var i = t.length - 1; i >= 0; i--) {
        grab.call(t[i], e, method, val, i + 1)
      }
    }
  }
}
//add the events
events.drag = { val: { down: drag } }
events.grab = { val: { down: grab } }
events.active = { val: { down: active } }
},{"../../value/operators":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/operators.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/basic.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = module.exports = require('./')
  , cases = require('../cases')
  , util = require('../../util')
  , ua = require('../ua')

cases.touch =
( ( 'ontouchstart' in window )
  || window.DocumentTouch
  && document instanceof DocumentTouch
)
|| navigator.msMaxTouchPoints
|| false

function _basic(e, method, val) {
  e.x = e.pageX
  e.y = e.pageY
  method.call(this, e, val)
}

util.define
( events
, '_out'
, { value: [] }
)
//clickout cannot be used to create complex events! it's too custom 
//tried to fix

function keyBoardEvent( name, domEvent, wrapper ) {

  var _name = '_'+name

  util.define( events, _name, { value:[] } )

  var event = 
  {
    create: function( field, from ) {
      var exec = function( e ) {

        //dit gaat heel snel fout hiero
        // console.log('nu ff ook de wrapper callen!', field, from, events[from])
         if( this.rendered ) {

          if( wrapper ) {
            wrapper.call(this, e, this.events[from]._val )
            //this.events[from]._val.call(this, e)
          }
          else if( events[from] && events[from].val) {
            var method = events[from].val
            for(var i in events[from]) {
              if( cases[i]) {
                method = events[from][i]
              }
            }
            method = method[field]
            if( method ) {
              method.call(this, e, this.events[from]._val )
            } 
          } else if( this.events[from] ) {
            this.events[from]._val.call(this, e)
          }

        }
      }
      events.document.addEvent( domEvent, function(e) {

        for ( var arr = events[ _name ], i = arr.length - 1; i >= 0; i-- ) {
          exec.call( arr[i], e )
          
          if( arr[i] ) {
            // console.log( 'do it now!', _name, arr, arr[i], e)
            arr[i].eachInstance( exec, 'events', e )
          }

        }
      }, name )
    },
    add: function( id, field ) {

      field = _name

      this.setSetting(
      { name: field
      , remove: events[ name ].remove
      })

      if ( !util.checkArray( events[ _name ], this ) ) 
      {
        events[ _name ].push(this)
      }

    },
    remove: function() {
      // console.log('WRONGWRONGWRONG!!!!!', _name, events[_name], events)
      //selected moet mischein alleen vanuit Value $focused -- niet op elk item op key up....
      //doe dit smart -- for now zou auto remove kunnen doen als iets er niet meer is?
      var index = util.checkArray( events[ _name ], this, true ) 
      if( ~index ) {

        var noRemove

        // console.log('this:', this )
        // console.log('from base:', this._from.base)
        // console.log('event name:', name)
        // console.log('events:', this.events )
        if(this.events && this._from.base.events) { 
          noRemove = this.events[name] === this._from.base.events[name]
          // console.log('events equals class:', noRemove )
        } else {
          // console.error('no nice events')
        }
        
        if(!noRemove) {
          events[ _name ].splice( index, 1 )
        }
        else {
          console.log(noRemove, 'noRemove evnt, are we sure - fix this asap')
        }
        // debugger
        // this.removeSetting( name ) --- redo this later
      }
    }
  }

  events[ name ] = event

}

events.$makeKeyBoardEvent = keyBoardEvent

keyBoardEvent( 'keyboard', 'keyup' )
keyBoardEvent( 'keyboardDown', 'keydown' )
keyBoardEvent( 'keyboardDown$down', 'keydown' )
keyBoardEvent( 'keyboardDown$click', 'keydown' )

//-----dit ff echt goed fixen!

function basicDown(e, method, val) {
  if( e.which!==1 || events.down.block ) return
   _basic.call(this,e, method, val)
}

events.down =
{ touch:
  { touchstart: function(e, method, val) {
      if(events.down.block) return
      var targetTouches = e.targetTouches[0] || {}
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
    }
  }
, val: { mousedown: basicDown }
// , tv: 
//   {  // mousedown: basicDown //combineren binnen kort moet voor LG
//      keyboardDown$down: function( e, method, val ) {
//       //this._$focused && 
//       if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) 
//       {
//         method.call(this, e, val)
//       }

//     }
//   }
}

//right-down
events.rdown =
{ touch:
  { touchstart: function () {
      //2 fingers?
    }
  }
, val:
  { mousedown: function (e, method, val) {
      if(e.which===3) {
        document.oncontextmenu = function() { return false }
        e.preventDefault()
        // e.rdown = true
        _basic.call(this,e,method,val)
        setTimeout(function() { document.oncontextmenu = false }, 0)
      }
    }
  }
}

//move
events.move = {
  touch:
  { touchmove: function (e, method, val) {
      var targetTouches = e.targetTouches[0]
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
      // document.write(e.targetTouches[0].pageX);
    }
  }
  , val: {
    mousemove: _basic
  }
}

//up
events.up = {
  //keyUp
  touch: {
    touchend: function(e, method, val) {
      var ct = e.changedTouches
      e.x = ct[0].pageX
      e.y = ct[0].pageY
      method.call(this, e, val)
    }
  }
, val: {
    mouseup: _basic
  }
}

//click
events.click = {
  // tv: {
  //   keyboardDown$click: function(e, method, val ) {

  //     if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) {
  //       method.call(this, e, val)
  //     }

  //   }
  // },
  val: {
    down: function(e, method, val) {

      // console.log('CLICK IT!')

      var t = this
        , name = 'click'
      if(!events.click.block){
        t.addEvent('up', function(e) {
          t.removeEvent('up', name)
          var ms = events._maybescroll
          if(ms){
            if(ms.length) events._maybescroll.unshift([method,t])
            else events._maybescroll = [[method,t]]
          }else if(!events.click.block) method.call(t, e, val)
        }, name);
        setTimeout(function() {
          t.removeEvent('up', name)
        }, 300)
      }
    }
  }
}

events.rclick = {
  val: {
    rdown:events.click.val.down
  }
}

var _outRemove = function() {
    var index = util.checkArray(events._out, this, true)
    if (~index) {
      events._out.splice(index, 1)
      this.removeSetting('_out', _outSetting)

      // debugger

    }
  }
, _outSetting = {
  name: '_out',
  render: function() {
    if (!util.checkArray(events._out, this)) {
      events._out.push(this)
    }
  },
  remove: _outRemove
}

events.out = {
  create: function() {
    this.m = true;
    events.document.addEvent('up', function(e) {

      var base = e.target,
        exec = function() {
          var p = base
            , t
          while (p && !t) {
            if (p.base && this === p.base) {
              t = true;
            } else {
              p = p.parentNode;
            }
          }
          if (!t && this.rendered) this.events.out._val.call(this, e)
        }
      for (var arr = events._out, i = arr.length - 1; i >= 0; i--) {
        exec.call(arr[i])
        if (arr[i]) arr[i].eachInstance(exec, 'events')
      }
    },'out')
  },
  add: function() {
    var t = this
     // events._out.push(this)
    this.setSetting(_outSetting)
  },
  remove:_outRemove
};
},{"../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","../ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var element = require('../element')
  , cases = require('../cases')
  , util = require('../../util')
  , FieldStore = function () {}

util.define(FieldStore, '_uid', { value: 0 })

exports._r = {} //list of basic (raw) events e.g. 'mousedown'

//remove events if there are no children that use them anymore

exports.document = new element({ node: document })

exports.document.exec = function( event ) {
  if( this.__e[event] )
  {
    var args = util.arg( arguments, 1 )
    for( var i in this.__e[event] )
    {
      this.__e[event][i].apply( this, args )
    }
  }
}

function _create( i, from ) {
  if( exports[i] )
  {
    // console.log('complex', i, from)
    _createComplex( i, from )
  }
  else
  {
    // console.log('_basic', i)

    exports[i] = { _basic: true }
    _createBasic( i )
  }
}

function _createWhile (i, m) {
  return function(e) {
    var parent = e.target
      , base, events
    while (parent) {
      base = parent.base
      if (base) {
        events = base.events
        if (events[i]) {
          if (m) {
            exports[i]._m.call(base, e, events[i])
          } else if (events[i]._val) {
            events[i]._val.call(base, e)
          }
          if (e.prevent) return
        }
        events = base.__e
        if (events && events[i]) {

          for (var j in events[i]) {
            if(j!=='_uid') {
              if (m) {
                exports[i]._m.call(base, e, events[i][j])
              } else {
                // console.log('?what', i, j, base, base._node)
                events[i][j].call(base, e)
              }
              if (e.prevent) return
            }
          }
        }
      }
      parent = parent.parentNode
    }
  }
}

function _createBasic (i, r) {
  var type = i || r

  // console.log('createBasic', type)

  exports._r[i] = true
  if(type === 'scroll') {
    document.addEventListener(type, function(e){
      var base = e.target.base
        , events
      if(base) {
        events = base.events
        if(events && events[i]) events[i]._val.call(base, e)
        events = base.__e
        if (events && events[i]) {
          for (var j in events[i]) {
            if(j!=='_uid') events[i][j].call(base, e)
          }
        }
      }
    },true)
  }else document.addEventListener(type, (exports[i].m = _createWhile(i)))
}

function _setComplex ( i, m, r, from ) {
  var met = exports[i]._m = function (e, val) {
    if (e.prevent) return
    m.call(this, e, (val._val || val.val || val), val)
  }
  exports[i].m = _createWhile(i, true)
  exports._r[i] = true
  if (exports[r]) {
    if (!exports[r].m) {
      _create(r, from )
    }
    if (!exports[r]._basic) {
      exports[i].__e = exports[r].__e
      exports[i]._m = function (e, m) {
        exports[r]._m.call(this, e, function(e) {
          met.call(this, e, m)
        })
      }
    } else {
      exports[i].__e = r
    }
  }
  document.addEventListener((exports[r] && exports[r].__e) || r, exports[i].m)
}

var addWrapper = function( add, field, orig ) {
  return function() {
    // console.log( 'ADD WRAP!', field, orig , arguments )
    return add.apply(this, arguments)
  }
}

function _createComplex( field, from ) {

  // console.log('_createComplex' ,field, from )

  if( exports[field].create ) exports[field].create( field, from)
  var m
    , i
    , j
  for ( i in exports[field] ) {
    if (cases[i] === true) m = exports[field][i]
  }
  if ( m || ( m = exports[field].val ) ) {
    for (j in m) //only one
    ;exports[field].__e = j

    if (m[j] === true) 
    {
      exports[field]._basic = true
      _createBasic(field, j)
    } 
    else 
    {
      //basic en non basic ijn niet te combineren -- combineren nog kapot
      // console.log('set complex field', field, m, j,  exports[j]) 
      //!!!tripple check dit!!!
       for( j in m ) 
       { 
        if( exports[j] && exports[j].add 
         && exports[field] && !exports[field].add
        ) 
        {
          exports[field].add = addWrapper( exports[j].add, field, j )
        }
        _setComplex(field, m[j], j, from )
      }
      //!!!danger loop!!!
    }

  }
}

exports._set = function (val, stamp, from, remove, cval, blacklist) {
  var t = this
  val.each(function (i) {
    if (!blacklist || !blacklist[i]) {
      if (this._val === false) {
        if (exports[i]) {
          if (exports[i].remove) exports[i].remove.call(t)
          t.eachInstance(exports[i].remove, val._prop.name)
          this.remove()
        }
      } else {
        
        // console.log('_cre', i, exports[i])

        if (!(exports[i] && exports[i].m)) {
          // console.log('---pass', i)
          _create(i, i)
        }
        //add wrapper?


        // console.log('_set',i, exports[i].add, exports[i])

        if (exports[i].add) exports[i].add.call( t, false, i )
      }
    }
  })
}

element.base.extend(
{ name: 'events'
, set: exports._set
})

util.define(element
, 'addEvent', function(field, fn, id) {
          // console.log('XXXX',field)

    if (!(exports[field] && exports[field].m)) _create(field)
    var events = this.__e || (this.__e = {})
      , f = events[field] || (events[field] = new FieldStore())

    if (!id) {
      f._uid++
      id = f._uid
    }
    f[id] = fn

    // console.log('addEvent!!!', field)

    if (exports[field].add) exports[field].add.call(this, id, field)
    return this
  }
, 'removeEvent', function (field, id, fn) {
    var events = this.__e
      , remove
    if (events) {
      if (field && events[field]) {
        remove = (exports[field] && exports[field].remove)
        if (id) {
          if (events[field][id] && (!fn || events[field][id] === fn)) {
            if (remove) exports[field].remove.call(this, id)
            delete events[field][id]
          }
        } 
        else {
          for (id in events[field]) {
            if (!fn || events[field][id] === fn) {
              if (remove) exports[field].remove.call(this, id)
              delete events[field][id]
            }
          }
        }
        if (util.empty(events[field])) delete events[field]
      } 
      else if (!field) {
        for (field in events) {
          this.removeEvent(field, id, fn)
        }
      }
    }
    if (util.empty(events)) delete this.__e
    return this
  })

require('./basic')

},{"../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","../element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js","./basic":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/basic.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/offset.js":[function(require,module,exports){
var matrix = require('../element/properties/util').getMatrix
  , vigour = require('../../')
  , css = require('../css')

exports.left = exports.x = function ( object, arr ) {
  return offset(object,arr,'left','offsetLeft', 4)
}

exports.top = exports.y = function ( object, arr ) {
  return offset(object,arr,'top','offsetTop', 5)
} 

function offset ( object, arr, prop, propL, matrixIndex ) {
  if(!object) return 0
  var start = false
  if(!arr) {
    arr = []
    start = true
  }
  
  if(vigour.Element && object instanceof vigour.Element) object = object.node

  var amount = object[propL]
    , temp = 0
  if(typeof(amount) !== 'number') amount = 0
  if(object.parentNode) exports[prop](object.parentNode, arr)
    if( ( (object.style && object.style.position)
      ||object.__preCss
      ||object.className 
        && (object.__preCss = css(object.className, 'position')||true)) 
      !== 'absolute' ) {
        arr.push(['rel', amount])
    } else {
      var matrixArray = matrix(object)
      arr.push(['abs', matrixArray 
        ? parseInt(matrixArray[matrixIndex],10)+amount //normal amount as well
        : amount ])
    }
  
  if(start) {
    var lastrel
      , abs = 0
      , i
    for(i in arr) {
      if(arr[i][0] == 'abs') {
        abs += arr[i][1]
      } else {
        lastrel = arr[i][1]
      }
    }
    amount = arr[arr.length - 1][0] === 'rel' ? abs+lastrel : abs
  }
  return amount || 0
}

  



},{"../../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../css":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/css.js","../element/properties/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/properties/util.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js":[function(require,module,exports){
var raf = require('../animation/raf')
  , util = require('../../util')

exports.throttle = function(fn, frames, bind) {
  frames || (frames = 20) //~0.4sec
  var timer
    , arg
    , nobind = !bind
  return function() {
    arg = arguments
    if(nobind) bind = this
    if(!timer) {
      timer = frames
      raf(function repeat() {
        timer--
        if(!timer) {
          fn.apply(bind,arg) 
        } else {
          raf(repeat)
        }
      })
    }
  }
}

//TODO: postpone based on frames
exports.postpone = function(fn, time, bind) {
  time || (time = 200) //no raf!
  var timer
    , arg
    , nobind = !bind
  return function() {
    arg = arguments
    if(nobind) bind = this
    if(timer) clearTimeout(timer)
    timer = setTimeout(function() {
      fn.apply(bind,arg)
    },time)
    return timer
  }
}

//TODO: test for leaks...
exports.interval = function(fn, frames, bind) {
  frames || (frames = 30) //~0.5sec
  var timer
    , clear
    , arg = util.arg(arguments,3)
  if(!timer) {
    timer = frames
    raf(function repeat() {
      timer--
      if(!timer) {
        timer = frames
        fn.apply(bind,arg)
      } 
      if(!clear) raf(repeat)
    })
  }
  return function() {
    clear=true
  }
}

},{"../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/ajax.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var _a = 'addEventListener'
  , util = require('../../util')
  , ua = require('../ua')
  , cnt = 0

/**
 * xhr wrapper, adds some nice extras such as multiple requests to a single api call
 * xhr wrapper will include jsonp in a later stage
 * @method extend
 * @param   {String|Array} params.url         Specifiy the url, array fetches multiple url's
 * @param   {String}   [params.api]           Repeat this string for the url that needs to be called
 * @param   {Function} [params.complete]      Specify a callback when an array is passed to url complete is called when all items are complete
 * @param   {Function} [params.error]         On error callback
 * @param   {Function} [params.change]        Function called on xhr.onreadystatechange
 * @param   {Boolean}  [params.async]         If set to false will call an syncronous request (not recommended!)
 * @param   {String}   [params.user]          User parameter
 * @param   {String}   [params.pass]          Password parameter
 * @param   {Boolean}  [params.parse]         If set to false will not try to parse response to JSON
 * @param   {String}   [params.type|.method]  POST or GET, default is get;
 * @param   {String}   [params.contentType]   request content type default id "application/x-www-form-urlencoded"
 * @param   {String}   [params.mime]          defines mime type
 * @param   {Function} [params.progress]      Progress callback
 * @param   {Boolean|String} [params.jsonp]   Use jsonp , if passed as a string determines script+?callback=
 * @param   {Object}   [params.header]        Sets request headers
 * @param   {*}        [params.data]          Pass data to the request, defaults to ? on get;
 */

var iframes
  , ajax = module.exports = function(params, urlset) {
    var _url = params.url;
    if (!urlset && _url instanceof Array) {
      params.m = function() {
        if ((++params.r) === params.n) {
          for (var i = 0, arr = [], l = _url.length; i < l; arr.push(params.d[_url[i++]]));
          params.complete(arr);
        }
      };
      params.r = 0;
      params.d = {};
      for (var i = 0, l = params.n = _url.length; i < l; module.exports(params, _url[i++]));
    } else {
      var data = params.data
        , encode = params.encode
        , url = (params.api || '') + (urlset || _url)
        , headers = params.headers
        , success = params.complete
        , progress = params.progress
        , error = params.error
        , change = params.change
        , mime = params.mime
        , user = params.user
        , pass = params.pass
        , jsonp = params.jsonp
        , parse = params.parse
        , iframe = params.iframe
        , reqdata = null
        , fallback = params.fallback
        , fallbackIndex = params._fallbackIndex
        , method = params.type || params.method || 'GET'
        , contentType = params.contentType || encode === 'json'
          ? 'application/json'
          : 'application/x-www-form-urlencoded'
        , async = (params.async === false) ? false : true
        
      if( jsonp ) 
      {
        ajax.jsonp( url, success, error )  
        //function( url, success, error, context, cbName ) {
      } 
      else 
      {
        // ------------------------------------------------------------ DATA
        var xhr = new XMLHttpRequest()
        if(iframe) {
          cnt++
          var elem
            , msg = {}
            , reqid = cnt

          for(var field in params) {
            if(field!=='error'&&field!=='iframe'&&field!=='complete') {

              msg[field]=params[field]
            }
          }
          var setmsg = function() {
            var elem
            iframes[iframe].onload = null
            var msgcomplete = function(e) {
              // console.error('IFRAME REQ MSG COMPLETE',e.data)
              if(e.data) {
                var d
                try {
                  d = JSON.parse(e.data)
                } catch(e) {
                  if(error) error(e)
                  return
                }
                if(d.id!==reqid) return
                if(d.err) {
                  if(error) {
                    error(d.err)
                  }
                  return
                }
                var resp = d.msg
                if(success) {
                  if (parse !== false) {
                    try {
                      resp = JSON.parse(resp)
                    } catch (e) {}
                  }
                  success(resp,e)
                }
                removeEventListener('message', msgcomplete)
              }
            }
            if(window.addEventListener) {
              addEventListener("message", msgcomplete, false)
              elem = iframes[iframe].contentWindow
              msg = JSON.stringify({
                msg:msg,
                id:reqid
              })
              elem.postMessage(msg, '*')
            }
          }

          if(!iframes) iframes = {}
          if(!iframes[iframe]) {
            elem = iframes[iframe] = document.createElement('iframe')
            elem.src = iframe
            elem.cListeners = [
              setmsg
            ]
            elem.onload = function() {
              for(var h in elem.cListeners) {
                elem.cListeners[h]()
              }
              elem.cListeners = null
            }
            elem.style.visibility='hidden'
            elem.style.width = '0px'
            elem.style.height = '0px'
            elem.style.position = 'absolute'
            document.body.appendChild(elem)
          } else if(iframes[iframe].cListeners) {
            iframes[iframe].cListeners.push(setmsg)
            //elem.cListeners[i]
          } else {
            setmsg()
          }
          return;
        }

        if (data) {

          if (method === 'GET') {
            url += '?' + enCode(data, 'GET', encode)
          } else {
            reqdata = enCode(data, 'POST', encode)
  //           console.log( reqdata )
          }
        }

        // ------------------------------------------------------------ METHOD, URL, ASYNC, USER & PASS
        xhr.open(method, url, async, user, pass)
        // ------------------------------------------------------------ HEADERS
        xhr.setRequestHeader('Content-Type', contentType)
        if (headers) {
          for (var f in headers) {
            xhr.setRequestHeader(f, headers[f]);
          }
        }

        // ------------------------------------------------------------ EVENTS
        if (success) {
          xhr[_a]("load", function(e) {
            var resp = (e.target || e.srcElement).response;
            if (parse !== false) {
              try {
                resp = JSON.parse(resp)
              } catch (e) {}
            }
            if (params.m) {
              params.d[urlset] = resp
              params.m()
            } else {
              success(resp, e)
            }
          }, false)
        }
        if (error) {
          if(!fallbackIndex) params._fallbackIndex = 0
          if(fallback && fallbackIndex!==fallback.length) {
            params._fallbackIndex++
            params = util.merge(params,fallbackIndex)
            ajax(params, urlset)
          } else {
            xhr[_a]("error", error, false)
          }
        }
        if (progress) {
          xhr[_a]("progress", progress, false)
        }
        if (change) {
          xhr.onreadystatechange = change
        }
        // ------------------------------------------------------------ MIME
        if (mime) {
          xhr.overrideMimeType(mime)
        }
        // ------------------------------------------------------------ SEND

        xhr.send(reqdata)
      }
    }
  }

var jsonpStamp = 0

ajax.jsonp = function( url, success, error, context, cbName ) {

  if( !cbName || cbName === true ) cbName = 'callback'

  var name = '_jsonp_' + jsonpStamp++
    , script = document.createElement('script')
  
  if (url.match(/\?/)) 
  { 
    url += '&'+cbName+'='+name
  }
  else 
  {
    url += '?'+cbName+'='+name
  }
  
  script.type = 'text/javascript'
  script.src = url
  
  if(error) {
    script.onerror = function( e ) {
      error( e )
    }
  }

  window[name] = function(data){
    success.call(( context || window ), data)
    document.getElementsByTagName('head')[0].removeChild(script)
    script = null
    delete window[name]
  }
  
  document.getElementsByTagName('head')[0].appendChild(script)

}

var enCode = ajax.encode = function(data, method, encode) {
  var result = ''

  if(encode === 'json'){
    result = JSON.stringify(data)
  } else if(data instanceof Object) {
    if (!util.isNode && (window.FormData && data instanceof FormData) && method !== 'GET') {
      result = data
    } else if (data instanceof Array) {
      result = JSON.stringify(data[f])
      if(encode === 'uri') result = encodeURIComponent(result)
    } else {
      for (var f in data) {
        var val = data[f]
        if(val instanceof Object) val = JSON.stringify(val)
        if(encode === 'uri'){
          f = encodeURIComponent(f)
          val = encodeURIComponent(val)
        }
        result += f + '=' + val + '&'
      }
      result = result.slice(0, -1)

    }
  } else {
    result = (encode === 'uri') ? encodeURIComponent(data) : data
  }
  // console.log('encoded:', result)
  return result
}
},{"../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/authenticate.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var util = require('../../../util')

exports.extend = util.extend(extend)

function extend(Cloud) {
  util.define( Cloud
  , 'authenticate', function authenticate(req, cb, re){
      window.authrequest = req
      var cloud = this

      if(typeof req === 'function')
        req = req()

      if(!req)
        return cloud.socket.removeListener('connect', reAuth)

      cloud.emit('authenticate', req, function(res){
        if(res.hop)
          cloud.hop(res.hop)
        else if(cb)
          cb(res)
      })
     
      if(!re){
        cloud.on('connect', reAuth)
      }

      function reAuth(){
        console.error('connect ->>> reAuth?')
        if(cloud._status > 2){
          console.error('reconnect ->>> reAuth!', req)
          cloud.authenticate(req, cb, true)
        }
      }
      cloud._reAuth = reAuth
    }
  , 'logout', function logout(userid){
      var cloud = this

      cloud.emit('logout', userid)

      if(
        cloud.data.users[userid] && 
         cloud.data.users[userid].activeClient 
         && cloud.data.users[userid].activeClient.from._name === cloud.clientid
       ) 
       {
         cloud.data.users[userid].activeClient.remove()
       }

      
      var stamp = cloud.stamp

      if(userid){
        if(cloud.data.users[userid])

        if( 
          cloud.data.users[userid].activeClient 
          && cloud.data.users[userid].activeClient.from._name === cloud.clientid) 
        {
          cloud.data.users[userid].activeClient.from = cloud.data.users[userid].activeClient
        }

        cloud.data.users[userid].remove(void 0, void 0, void 0, void 0, stamp)
        // else
        //   console.error('that user does not exist')
      } else{
        cloud.data.users.each(function(userid){
          this.remove(void 0, void 0, void 0, void 0, stamp)
        })
      }

      cloud.socket.removeListener('connect', cloud._reAuth)
      cloud._reAuth = null

    }
  )
}
},{"../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var util = require( '../../../util' )
  , NetworkData = require( '../data' )
    .inject( require( '../../../object/hashpath' ) )
    //TODO: add localstorage --> , !util.isNode && require('../../../object/localstorage')
  , networkDataElement = require( '../data/element' )
  , Data = require( '../../../data' )
  , preventUpdate
  , vObject = require( '../../../object' )
  , timestamp = require( 'monotonic-timestamp' )
  , CloudData = NetworkData.new
    ( false //put some settings!
    , function CloudData( val, hook, parent, cloud ) {
        var _this = this

        if( cloud )
        {
          _this.cloud = cloud
          _this.addListener(cdListener)

          if(!util.isNode && !!window.cordova) 
          {

            document.addEventListener('pause', function() {
              //TODO: this does not work yet -- make prevent update a usable thing in app logic ( e.g. in device lists or clients )
              _this.preventUpdate = true
            }, false)

            document.addEventListener('resume', function() {
              
              cloud.kickPing()

              if( _this.timeout )
              {
                clearTimeout( _this.timeout )
              }

              _this.timeout = setTimeout( function() {
                if( _this.defered ) 
                {
                  _this.merge( _this.defered.data, false, _this.defered.stamp )
                }
                _this.preventUpdate = null
                _this.defered = null
                _this.timeout = null
              }, 100 )
              // _this.preventUpdate = true //wait for another update and timeout
            }, false)
          }

          cloud.on
          ( 'set'
          , function( data ) {
 
            // console.clear()
            
            // console.group()
            // console.log('\n-----------INCOMING CLOUD-------\n', data )

            // if()

            // console.log(JSON.stringify(data, false, 2).slice(0,200))
            // console.groupCollapsed()
            // console.log(JSON.stringify(data, false, 2))
            // console.groupEnd()
              // console.log('INCOMING!\n', JSON.stringify(data))
              var set = data.s
                , vclock = data.v
                // , stamps = vclock[1]
                , subs = cloud.state.subs.map
                , stamp = vclock[1]

              if( vclock[0] instanceof Array )
              {

                //vclock where is it??????

                for( var i = vclock[0].length; hash = vclock[0][--i]; )
                {
                  updateSub( subs[hash], data.v[1] )
                }

              }
              else
              {
                updateSub( subs[data.v[0]], data.v[1] )
              }

              // stamp = 0

              // for( var s in stamps )
              // {
              //   console.log('burrr', stamps[s])
              //   if( stamps[s] > stamp ) stamp = stamps[s]
              // }

              cloud.stamp = stamp

              // _this._time

              if( !_this.preventUpdate ) 
              {
                _this.merge( data.s, false, stamp )
              } 
              else
              {
                if(!_this.defered)
                {
                  //pause geen timeout alleen maar uitstellen
                  _this.defered = 
                  { data: data.s
                  , stamp: stamp
                  }
                }
                else 
                {
                  _this.defered.stamp = stamp
                  _this.defered.data = util.merge( _this.defered.data, data.s)
                  // _this.defered.data._update( data.s )

                }
              }

            }
          )

        }
        else if( parent )
        {
          _this.cloud = parent.cloud
        }

      }
    )
  , __update

module.exports = CloudData

function updateSub( cached, vclock ) {
  if( !cached ) return

  return // not implemented

  // var sub = cached.subsobj
  // if( !sub._v ) sub.set( '_v', {} )

  // for( var f in vclock )
  // {
  //   sub._v.set( f, vclock[f] )
  // }

}

function createSub( path, sub, partialSub ) {

  if( path.length )
  {
    util.path( sub, path, partialSub, true )
    return sub
  }
  else
  {
    return partialSub
  }

}

function t4walker( val ) {
//TODO: remove $t:4
  for( var i in val )
  {

    if(val[i] instanceof Object)
    {

      if(val[i] instanceof vObject)
      {
        val[i] = { $path: val[i]._path } // $t: 4 
      }
      else
      {
        t4walker( val[i] )
      }

    }

  }

}

function cdListener( val, stamp, from, remove, added, old ){
  var cloud = this.cloud
  // console.log('OOOO cloudata listenerbur', this._path, val)
  if( stamp === 'localStorage' || stamp===false  )
  {
    // console.log('I WILL NOT UPDATE'.red.inverse)
    // console.log('Cloud from localstorage'.inverse.red)
    return
  }


  if( stamp !== cloud.stamp && val !== void 0 )
  {

    // console.log('>>>>>> shiner')

    // console.log('\n\n\n\n\nupdate cloud', val)



    if( remove && from )
    {
      if( from._removed )
      {
          // console.log('!!!!!!UPDATE CLOUD!!!', from && from._path, val, stamp)

        cloud.set(from._hashpath, [from._path, null, cloud.timeStamp()])
      }

    }
    else if ( from && !this._cloudignore )
    {


      // if( stamp === void 0 ) {
      //   alert('X')
      // }

      // console.log( 'cccccccccccc update!', this._path , from._updateOrigin, from._cachedPath)

      // console.error('_update Origin call from cloud.data') 
      if( from._updateOrigin === from ) //hier gaat iets mis
      {
        if( from.__t === 2 && val instanceof Object ) {
//           console.log(from, val)
          t4walker(val)
        }


        //["users", "U_fe7cc800136b7608", "clients", "V_kuco2zs2qf"]
        var p = from&&from._path
        if(p && p[0] === 'users' && p[p.length-2] && p[p.length-2] === 'clients' ) {
          //TODO: very dirty fix!
          // console.error('break it down!', p, p, val )
          return
        }

        if(p && p[0] === 'users' && p[1] === 'media') {
          throw(new Error('THIS IS WRONG ABORT!---> setting users.media '+p.join('.')))
          // console.error('THIS IS WRONG ABORT!---> setting users.media', p)
          return
        }


        cloud.set
        ( from._hashpath
        , [ from._path
          , from.__t === 4 ? {  $path: val._path } : val //$t: 4,
          , cloud.timeStamp()
          ]
        )

      }

    }

  }

}

CloudData.prototype._blacklist.push('cloud', 'datacloud', '_batchUnsub','_cloudignore', '_lstamp', '$t', '$loaded')

__update = CloudData.prototype.__update

CloudData.inject( require('old-vigour-js/object/flags') )

CloudData.flags.$path = {
  reset:true,
  set: function(val, stamp, reset) {
    
    if( reset ) {
      throw new Error('cloud data $path flag reset???')
    }
  
    var t = this
    if(stamp !== this.cloud.stamp) {
      throw new Error('set with $path only allowed from the hub')
    }

    var path = util.changeType( val )
    if(path.length){
      // console.log('___________ $path set')
       // val, set, notself, stamp 
      this._$setVal( this.cloud.data.get( path, {}, void 0, stamp ) ,stamp,false,true)
    }

    if(this.__t!==4) {
      throw new Error('cloud data $path flag __t !== 4')
    }

  }
}


var _set = CloudData.prototype.set

var _$setVal = CloudData.prototype._$setVal

//CloudData add flags

//( name, val, vobj, stamp, noupdate, from )
util.define
( CloudData
, '_$setVal', function( val, stamp ) {
   //setVal

   // console.log('.............', this._path, stamp, stamp && this.cloud.stamp === stamp)
   if(this.cloud.stamp === stamp && !this.$loaded) {
    //TODO: faster to do ! loaded
    var parent = this
    while(parent && !parent.$loaded) {
      parent.$loaded = true
      parent = parent._parent
    }
   }

   _$setVal.apply( this, arguments )
  }
, 'set', function(name, val, vobj, stamp){
  if (stamp !== this.cloud.stamp &&
      this._name === 'clients' &&
      !this[name] && 
      name !== this.cloud.clientid
     ) {
    console.error('\n\nI WANT TO BLOCK THIS YA DURK',
      '\nstamp !== this.cloud.stamp', stamp !== this.cloud.stamp,
      "\nthis._name === 'clients'", this._name === 'clients',
      "\n!this[name]", !this[name],
      "\nname !== this.cloud.clientid", name !== this.cloud.clientid
    )
    debugger
    // return false
  }
  return _set.apply(this, arguments)
}
, 'updateQueue'
, function() {
    // why this???
  }
, 'stamp'
, function(){
    if( !this.cloud ) {
      console.error( 'WAT NO CLOUD?! in this:\n', this )
      return
    }
    return this.cloud.timeStamp()
  }
, '__update'
, function( val, stamp, from, remove, added, oldval ) {


    this._lstamp = stamp


    // if(this._path[0]==='clients') {

    //   console.log('2', this._path, stamp===this.cloud.stamp)

    // }
    // console.log('1 lets __update', this._path, arguments)
    // if( this._ignore  ) {

      // console.log('21 lets __update', this._path, arguments)

      // delete this._ignore
      // return false
    // }
    //most nested update hier addition maken voor process
    // console.log(val, stamp, from)
    //is dit maybe weird???
    return __update.call( this, val, stamp, from, remove, added, oldval )
  }
, '_set'
, function (val, stamp) {
    if( !stamp ) return
    if( this._lstamp > stamp )
    {
      return
    }
    // console.log('lets set it!!!', this._path, arguments)

    return NetworkData.prototype._set.apply( this,arguments )
  }
, 'subscribe'
, function( val, from, parentFixer ) {
              // console.log('start')

    if( from && from.cloud  && from._val === this ) {

        //BUG: dit kan heel veel broken maken!!!!!!!
//         console.log('\n\nHURK!!!!!! DIT IS TEMP MOET NIET EEN EXTRA SUB GEMAAKT WORDEN!' )

        // from = void 0

        //TODO: dit is helemaal wrong GET RID OF IT!!!!
        // return
    }

    // console.log( 'lets do it sub sub'.cyan.inverse, this, val, from, parentFixer )
    // if(from) {
      // console.log('GOT FROM', from , 'SUBSCRIBE')
    // }
     if (!val || typeof val === 'function') { return; }
     // if(val instanceof vObject) {
     //    val = val.from
     // }


     var path = this._path
       , elem = val[1]
       , sub
       , partialSub
       , stringified
       , subsArray
       , exists
       , listeners
       , fromName

      var found = path && util.checkArray( path , 'usage' )
    


    // if( found || found===0) {
            // console.log('lets try to sub', val && val._path, ':', this._path )
      // }
   

    // if(elem) {
    //   console.error(elem, elem._col, elem._dfrom, elem._fmodel)
    // }

    // console.log('SUBSCRIBE', elem._dfrom, elem._fmodel, 'DFROM, FMODEL!')

    // if (elem && !elem._col && (!elem._dfrom || elem._fmodel)) {
    var isElem = (elem && !elem._col && (!elem._dfrom || elem._fmodel))

    if( isElem && !elem.getModel) {
      // console.error('be carefull! cloud data elem does not have getModel')
    } else if( isElem ) {

      // console.error('XXX!')
      //hier dingen vinden voor
      // console.log('!DFROM!')

    //isElem

    //val, from, parentFixer

    // if(val[3] && val[3] instanceof Array) {
    //       console.log( 'YES!!!' )

    // }

          // console.log( '!!!!!!111111', arguments, val[3], from, parentFixer, this, path )

    var fieldignore
    if( val[1]._ignoreFieldInSubscription ) {
      // alert('!'+val[3])
      if(!val[3]) {
        // console.log('FIELDIGNORE'.blue.inverse, val, this, path )
        // debugger

        // if(fi)

        fieldignore = true
      }
    }

    //TODO: has to become val[2]!!!
    //typeof from === 'string' ? from :
      //dit is niet goed!!!!
      fromName = val[3]

    // console.log( '--------22!!!!!!111111', partialSub, val[3], '\n\n?', val[3]._name  )

      //val[3] instanceof Data
      partialSub = elem.getModel( this,  val[3] , fieldignore )
      // console.clear()
    // console.log( '----!!!!!!111111', partialSub )
      // if(partialSub && partialSub.specialFix) {
      //   console.log('LETS DO IT ITI IT', partialSub, partialSub.specialFix, path)
        
      //   // if(partialSub.specialFix instanceof Array ) {

      //   //   console.log( path, partialSub.specialFix, partialSub )
      //   //   if(path[path.length-1] === partialSub.specialFix[0]) {

      //   //     if(partialSub.$ && partialSub.$[partialSub.specialFix[1]]) {
      //   //         console.log('do it!')
      //   //         partialSub = partialSub.$[partialSub.specialFix[1]]
      //   //     }

      //   //   }

      //   // } else 

      //   if(path[path.length-1]===partialSub.specialFix) {
      //     path.pop()
      //   }
        
      //   delete partialSub.specialFix
      // }

      // console.log('LETS DO IT ITI IT'.green.inverse, partialSub)

      // partialSub.DEBUG$log('partial')

    } else if (val instanceof Data && val.__sub) {
    //isData+Subscription
      //dit moet ook gefixed!!!!!!!!!
      partialSub = networkDataElement.parseData(val)

    } else if (val instanceof vObject ) {
    //vObject
      listeners = val._listeners

      // console.log(this._path, 'LISTENER', from )

      if(listeners) {
        for( var listener$=0, len$=listeners.length; listener$<len$; listener$++ ) {
                // console.log('!!!!!!!!!!! listner$333333'.red.inverse, listeners[listener$])
                  // console.log('--------->',this._path, 'LISTENER, ' , listeners[listener$]._path, val)
          this.subscribe( listeners[listener$], val )
        }
      }

      // if(val._parent && !val._parent.cloud) {
        // console.log('parent',val._parent, val._parent._listeners)
      //   listeners = val._parent._listeners

      //   // val._pa
      //   if(listeners) {
      //     for (var listener$=0, len$=listeners.length; listener$<len$; listener$++) {
      //       this.subscribe(listeners[listener$], false, true)
      //     }
      //   }
      // }

      return;
    } else if (val && util.isObj(val) && !(val instanceof Array)) {
      //isNormalSubscription
      // console.log('IS OBJ'.cyan)
      partialSub = val
      val = JSON.stringify(val)
    }

    if (partialSub) {

     //if! empty
     // console.log('2 LETS DO IT ITI IT 2',this , path, 'from:', from, 'sub:', networkDataElement.parseData(from, partialSub, this._subs ) )

     var fromCheck
     if(from) partialSub = networkDataElement.parseData(from, partialSub, this._subs)
      //de check moet nu in from gebeuren
      // console.log('.subscribe cloud.data partialSub are we sure this is from a ref in the cloud'.blue.inverse, partialSub, path) //replace /w from

      if(from && from.cloud && from._val === this) {
        path = from._path //if from is cloud
        // alert('!')
        fromCheck = true
        // console.warn('do nothing prop from cloud', from)
      }

     sub = createSub(path, {}, partialSub)
     stringified = JSON.stringify(sub)

     var substarget =  fromCheck ? from : this

     if(!substarget._subs) substarget._subs = []
     if(elem) elem._subscribed = true
     // console.log('3LETS DO IT ITI IT 3'.red.inverse, networkDataElement.parseData(from, partialSub) )

      subsArray = [ partialSub, elem || val , stringified ]

      if(fromName) {
        subsArray.push(fromName)
      }

      exists = util.checkArray( substarget._subs, stringified, 2)
      //maybe check if val already exists
      // console.log(' TEST TRUE ----- SUBSCRIBE', from, exists, this._subs, stringified, partialSub, sub )
      //TODO: check if not exists subsArray each field
      // console.log('PUSH! SUBS'.green.inverse, subsArray ,stringified, exists )
      var same
      for(var i in substarget._subs ) {

        // console.log(substarget._subs[i], i, substarget._path)
        //compare objects

        if( substarget._subs[i][1] === (elem || val) && substarget._subs[i][2] === stringified ) {
          //distincation!!!!
          // console.log('THE SAME'.cyan.inverse)
          same = true
        }

      }

      if(!same) {
      substarget._subs.push( subsArray )
        //just dont subscribe ---
        if ( exists===false ) {

          // console.log(' TRUE ----- SUBSCRIBE', JSON.stringify(sub,false,2) )
          this.cloud.subscribe(sub, stringified)
        }
        else {
          // console.warn('ALLREADY EXISTS!', sub, stringified)
        }
      }
    }

  }
, 'unsubscribe'
, function( val, from ) {

    //todo: double check if this goes well
    // console.error('1unsubscribe!')

    //doundle remove

    if 
    ( !val
      || val._col
      || (val._filter && val._filter._col)
      || !(!val._dfrom || val._fmodel)
    ) 
    { 
      return 
    }

     var path = this._path
       , stringified
       , subsArray
       , sub
       , exists
       , partialSub
       , index
       , field
       , listeners = val._listeners

    // console.log('unsubscriblex','path:'.blue, path, 'stringified:'.blue,  sub, 'this:'.blue,this, 'val:'.blue, val, 'from:',from )

    if ( util.isObj( val ) && !( val instanceof Array ) ) val = JSON.stringify( val )

    index = this._subs && util.checkArray( this._subs, val, 1 )
    //niet alle 1's weghalen

        // console.log('unsubs??????'.red.inverse, util.clone(this._subs), val, index, this )
        //missing index!


    if ( index!==false && index !== void 0 ) {




      if(val.model && val.model.parsing) {

        // console.log('MODEL unsubs??????'.red.inverse)
        // var removeI

        //block unsubs on model parsing
        if(val.model && val.model.field ) {
          // console.clear()
          // console.log('WARN! unsubs field WARN!'.red.inverse, from, this._subs[index] )

          //reapply if field
          field = this.get(val.model.field.val)
          if(!field._subs) field._subs = []

          // console.log('WARN! unsubs field WARN!'.red.inverse,field===this, field, from, this._subs[index] )


          var __subs = util
            .get( this._subs[index][0], val.model.field.val )

            // console.log( 'subs[0]'.blue,  this._subs[index][0] )

          if( __subs ) {
          this._subs[index][0] = __subs
          // field._subs.push(this._subs[index])
          // console.log('REMOVE SUBS and push'.red.inverse, index,field._subs, __subs, this._subs[index], this._path)
          // debugger
          // this._subs.splice(index, 1)
        } else {
          // console.log('warn'.red)

        }
          // console.log( __subs )


         
          //dit ff beter doen (meerdere _subs)
          //tel counts
          
          //voor deze splice check op index en stringified!

         
        }

        return
      }

      subsArray = this._subs[index]
      stringified = subsArray[2]
      partialSub = subsArray[0]
      // if(from) partialSub = networkDataElement.parseData(from, partialSub)

      // console.log( 'partialSub'.inverse, partialSub )

      sub = createSub(path, {}, partialSub)

      //voor deze splice check op index en stringified!
      //kan dus ook efficienter
      // if( removeI !== void 0 ) {
        // console.log('REMOVE', index)
         // console.log('REMOVE SUBS'.red.inverse, index, this._subs, this._path )
          // debugger
        this._subs.splice(index, 1)

      // }



      exists = util.checkArray(this._subs, stringified, 2)

      if(exists!==false) {
        // console.log('EXISTS????'.cyan.inverse, exists, stringified, this._subs, this._path, this)
      } else {
        // console.log('!EXISTS' , exists, stringified)
      }

      if ( exists === false ) this.cloud.unsubscribe(sub, stringified)
        // this._subsRAF.push([sub, stringified])
        // this._subsRAF = [] search & remove use different identifiers e.g. subs array

    } else if( val._removed ) {

            // console.log('unsubs??22222???? 2222222'.red.inverse)

      // console.error('is this really nessecary? _removed , froce all listeners remove tagets etc')
    } else if(listeners) {

                  // console.log('unsubs??333333333???? 2222222'.red.inverse)

      // console.log('----> this is also pretty different! _listeners')
      for (var listener$=0, len$=listeners.length; listener$<len$; listener$++) {
        if (listeners[listener$] instanceof Array) {
          this.unsubscribe(listeners[listener$][1], val)
        } else if (listeners[listener$].__t) {
          this.unsubscribe(listeners[listener$], val)
        }
      }
      return
    }

  }
)

},{"../../../data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","../../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../../object/hashpath":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/hashpath.js","../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/data/index.js","../data/element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/data/element.js","monotonic-timestamp":"/Users/youzi/dev/mtv-play/node_modules/monotonic-timestamp/index.js","old-vigour-js/object/flags":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/flags.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/datacloud.js":[function(require,module,exports){
module.exports = DataCloud

var timestamp = require('monotonic-timestamp'),
  util = require('../../../util/object'),
  CloudData = require('./data'),
  VObject = require('../../../object'),
  Batch = VObject.new({
    merge: true
  }),
  CloudState = VObject.new({
    merge: true
  }),
  makeHash = require('../../../util/hash'),
  batchtime = 20,
  SUBS = 'subs',
  SETS = 'sets',
  UNSUBS = 'unsubs'

function DataCloud () {
  // window.datacloud = this
  var cloud = this
  cloud._joins = {}
  cloud._status = 1

  cloud.on('connect', function () {
    // console.error('---- cloud connect >> cloud._status++ call _reconnect')
    cloud._status++
    cloud._reconnect()
  })

  // console.log('start making state')
  cloud.state = new CloudState({
        subs: {
          map: {},
          tree: {}
        },
        sets: {
          map: {} /*, list:[]*/
        }
      }
      // , { localstorage: 'VC$' }
    )
    // console.log('done making state', JSON.stringify(cloud.state.raw,false,2))

  if (!cloud.state.sets.list) cloud.state.sets.set('list', [])
    // ^^ set met lege array merged niet

  cloud.batch = {
    maps: {
      sets: {},
      subs: {},
      unsubs: {}
    }
  }

  // console.log('------SET C DATA')

  cloud.data = new CloudData({}, false //{localstorage:'cloudData'}
    , false, this)

  // console.log('------LOG')


  // console.log(JSON.stringify( cloud.data.raw,false,2))
  // ^^ dit kan door weirde shit in localStorage de constructor laten kappen!

  // cloud.on('incoming::pong', this._clearCache)
  // cloud.on('data', this._clearCache)

  cloud._qTimer = setInterval(function _qTimer () {
    cloud._doBatch()
  }, batchtime)


  // cloud.on('welcome', function onWelcome(){

  // })

  cloud.on('subscribed', function (msg) {
    // console.error('>>> Hey Cloud says im subscribed to', msg)
  })

}

DataCloud.prototype.timeSync = function timeSync () {
  // console.log('timeSync!')
  var cloud = this,
    outstamp = Date.now()
  cloud.emit('time', function (cloudstamp) {

    var traveltime = Date.now() - outstamp,
      arrival = outstamp + traveltime / 2,
      offset = cloudstamp - arrival
      // console.log('timestamp in', traveltime, 'offset', offset)
    if (traveltime < cloud._timeTravel) {
      cloud._timeTravel = traveltime
      cloud._timeOffset = offset
    }
    var tries = cloud._timeTries++
      if (traveltime > 75 && tries < 10 || traveltime > 50 && tries < 5 || traveltime > 20 && tries < 2) {
        cloud.timeSync()
      }
  })
}

DataCloud.prototype.outList = function (label) {
  var batch = this.batch
  if (!batch.lists) {
    batch.lists = {}
    return batch.lists[label] = []
  } else if (!batch.lists[label]) {
    return batch.lists[label] = []
  } else {
    return batch.lists[label]
  }
}

DataCloud.prototype._doBatch = function _doBatch () {
  var cloud = this,
    out = cloud.batch.lists

  if (out) {
    // console.log('emit dat batch out!')
    // console.log('EMITTING!',out)
    // if(typeof window !== 'undefined'){
    //   console.log('writing out', JSON.stringify(out).slice(0,50))
    //   console.groupCollapsed()
    //   console.log(JSON.stringify(out,false,2))
    //   console.groupEnd()
    // }
    cloud.emit('batch', out)
      // cloud.write(out)
      // cache sets untill next heartbeat
      // var setslist = out.sets
      // if(setslist) {
      //   var cache = cloud.state.sets
      //     , setsmap = cloud.batch.maps.sets

    //   for(var hash in setsmap) {
    //     var update = setsmap[hash].update
    //     if(update[1] === null)
    //       update[1] = '$$null'
    //     storeSet(hash, update, cache.list, cache.map)
    //   }
    // }
    cloud.batch.lists = null
    cloud.batch.maps = {
      subs: {},
      sets: {},
      unsubs: {}
    }
  }
}

DataCloud.prototype._clearCache = function _clearCache () {
  // if(this.state.sets.list.length){
  //   this.state.sets.remove()
  //   this.state.set('sets', {map:{},list:[]})
  // }
  // could be nicer if we have a good way of clearing arrays
}

DataCloud.prototype.subscribe = function subscribe (subsobj, str) {
  // console.log('subscribe!', str)
  var cloud = this,
    state = cloud.state,
    hash, cached

  if (subsobj.hash && subsobj.subsobj) {
    // console.log('das cached!')
    hash = subsobj.hash
    cached = subsobj
  } else {
    if (!str)
      str = JSON.stringify(subsobj)
    hash = makeHash(str)
    cached = state.subs.map[hash]
  }
  // console.log('hash', hash)


  if (!cached) { // place in tree

    // console.log('set active!')

    state.subs.map.set(hash, {
      hash: hash,
      subsobj: subsobj,
      active: cloud._status,
      cleared: false
    })
    cached = state.subs.map[hash]
    var tree = state.subs.tree
    insertLeaf(tree, cached.subsobj, cached)
  } else if (!cached.active || cached.active._val) {
    // console.warn('subscription already active!', cached, cached.active)
    return
  } else {
    cached.active.val = cloud._status
  }

  var unsubsmap = cloud.batch.maps.unsubs,
    unsubindex = unsubsmap[hash]

  if (unsubindex !== void 0) {
    cloud.cancel(hash, unsubindex, UNSUBS)
    return
  }

  var subslist = cloud.outList(SUBS),
    subsmap = cloud.batch.maps.subs,
    out

  if (!cached.cleared._val) {
    cached.cleared.val = cloud._status
    var depends = cloud.getDeps(state.subs.tree, cached.subsobj, cached, {})
    if (!util.empty(depends)) {
      out = {
        $subsobj: cached.subsobj.raw,
        $depends: depends
      }
    } else {
      out = cached.subsobj.raw
    }
  } else {
    out = cached.subsobj.raw
    cached.cleared.val = cloud._status
  }

  subsmap[hash] = subslist.length
  subslist.push(out)
}

DataCloud.prototype.getDeps = function getDeps (tree, walker, cached, list) {
  walker.each(function (f) {
    var branch = tree[f]
    if (branch) {
      if (branch._subs) {
        branch._subs.each(function (i) {
          var found = this._val
          if (found.subsobj._v && found.hash._val !== cached.hash._val && !found.cleared._val && !list[found.hash._val]) {
            found.cleared.val = cached.cleared._val
            list[found.hash._val] = found.subsobj.raw
          }
        })
      }
      getDeps(branch, walker[f], cached, list)
    }
  })
  return list
}

DataCloud.prototype.unsubscribe = function unsubscribe (subsobj, str) {
  // still do
  var cloud = this
  // console.error('unsubscribe!', subsobj)
  if (subsobj instanceof Array) {
    // console.log('unsub with array', subsobj)
    var tree = cloud.state.subs.tree,
      spot = tree.get(subsobj)

    if (spot) {
      // console.log('OK UNSUBSCRIBE TO THIS CRAP', spot)
      recurUnsub(cloud, spot, str)
    }
  } else {

    var batchmap = cloud.batch.maps.subs,
      hash,
      cached

    if (subsobj.hash) {
      hash = subsobj.hash.val
      cached = subsobj
    } else {
      if (!str) {
        str = JSON.stringify(subsobj)
      }
      hash = makeHash(str)

      var statemap = cloud.state.subs.map

      cached = statemap[hash]
    }

    var index = batchmap[hash]

    if (index !== void 0) {
      cloud.cancel(hash, index, SUBS)

    } else {
      var list = cloud.outList('unsubs')
      cloud.batch.maps.unsubs[hash] = list.length
      list.push(hash)
    }

    cached.active.val = false
  }

}

function recurUnsub (cloud, spot, clear) {
  // console.log('recurUnsub!', spot._path)
  spot.each(function (f) {
    if (this._subs) {
      this._subs.each(function () {
        // console.log('unsub on this!', this.raw, 'clear?', clear)
        if (clear && this.from.subsobj._v) {
          this.from.subsobj._v.remove()
        }
        cloud.unsubscribe(this.from)
      })
    }
    if (f !== '_subs') {
      recurUnsub(cloud, this, clear)
    }
  })
}

DataCloud.prototype.cancel = function cancel (hash, index, label) {
  var batch = this.batch,
    list = batch.lists[label]
  removeIndex(list, index)
  if (!list.length) {
    delete batch.lists[label]
    if (util.empty(batch.lists)) {
      delete batch.lists
    }
  }
  var map = batch.maps[label]
  delete map[hash]
  for (hash in map)
    if (map[hash] > index) {
      map[hash] --
    }
}

DataCloud.prototype.set = function set (hash, update) {

  // console.log('SET CLOUD!')

  if (!update[0].length) {
    // console.error('EMPTY PATH', update)
  }

  var cloud = this,
    list = cloud.outList(SETS),
    map = cloud.batch.maps.sets

  storeSet(hash, update, list, map)
}

function storeSet (hash, update, list, map) {
  // console.log('storeset?!')
  var V = list.__t,
    stored = map[hash]

  if (stored) {
    var val = update[1],
      ts = update[2],
      oldval = stored.update[1]

    if (V) oldval = oldval.raw

    if (val instanceof Object && oldval instanceof Object && !(val.$path) && !(oldval.$path)) {
      if (!V) oldval = util.clone(oldval)
      val = util.merge(oldval, val)
    }

    if (V) {
      stored.update.set(1, val)
      stored.update.set(2, ts)
    } else {
      stored.update[1] = val
      stored.update[2] = ts
    }

    if (!V) {
      var i = stored.i,
        end = list.length - 1
      if (i !== end) {
        moveToEnd(list, i)
        for (var maphash in map) {
          if (map[maphash].i >= i) map[maphash].i--
        }
        stored.i = end
      }
    }
  } else {
    var setobj = {
      update: update,
      i: list.length
    }
    if (V) {
      map.set(hash, setobj)
    } else {
      map[hash] = setobj
    }

    stored = map[hash]
    list.push(stored.update)
  }
}

DataCloud.prototype._reconnect = function _reconnect () {

  // alert('(RE)CONNECT!')
  // console.error('------------- (RE)CONNECT!')

  var cloud = this,
    state = cloud.state,
    subs = state.subs.map

  cloud._timeTries = 0
  cloud._timeTravel = Infinity
  cloud.timeSync()

  // clean data
  cloud.stamp = 'cleanup'
  if (cloud.data.clients) {
    var myclient = cloud.data.clients[cloud.clientid]

    if(myclient) {
      myclient = myclient.raw
      delete myclient.key
      delete myclient.type
      delete myclient.ip
      delete myclient.token
    }

    cloud.data.set('clients', {
      clear: true
    }, void 0, cloud.stamp)

    // TODO: put all cloud.client logic in one place
    if(cloud.clientid && cloud.client) {
      cloud.client.val = cloud.data.clients.get(cloud.clientid, {})
      if(myclient) {
        cloud.client.from.val = myclient
      }
    }
  }

  if (cloud.data.users) {
    cloud.data.users.each(function () {
      // console.log('CLEAN CLOUD: clean usrt!!', this._name)

      this.set('clients', {
        clear: true
      }, void 0, cloud.stamp)

      // CLEAN MAINSCREEN AND ACTIVE CLIENT?!

      // this.mainscreen.set('clientRef', false, void 0, cloud.stamp)
      // this.mainscreen.clientRef.remove(void 0, void 0, void 0, void 0, cloud.stamp)

      // this.activeClient.remove(void 0, void 0, void 0, void 0, cloud.stamp)

    })
  }

  // if(sets.length){
  //   sets.sort(byTs)
  //   for(var i = 0, set ; set = sets[i++];){
  //     if(set[1] === '$$null')
  //       set[1] = null
  //   }
  //   cloud.write({sets:sets})
  //   // would be nicer to insert them into current batch
  // }

  var resubs = []
  subs.each(function (f) {
    // console.log('resub?', f)
    var cached = this,
      active = cached.active,
      cleared = cached.cleared

    if (active._val === 1) {
      active.val = true
      cleared.val = true
    } else if (active._val) {
      // active._val = false

      active.val = false
      // dit wordt niet in ls opgelsagen

      if (cleared._val === 1) {
        cleared.val = true
      } else if (cleared._val) {
        cleared.val = false
      }
      resubs.push(cached)
    } else if (cleared._val) {
      if (cleared._val === 1) {
        cleared.val = true
      } else {
        cleared.val = false
      }
    }

  })
  for (var i = 0, resub; resub = resubs[i]; i++) {
    // console.error('resubscribe!!', resub.subsobj.raw)
    cloud.subscribe(resub)
  }
  // console.error('done resubscribin')

  for (var j in cloud._joins) {
    cloud.join(cloud._joins[j], true)
  }

}

DataCloud.prototype.timeStamp = function () {
  var ts = timestamp()
  if (this._timeOffset) {
    ts += this._timeOffset
  }
  return ts
}

function insertLeaf (tree, subsobj, cached) {
  subsobj.each(function (f) {
    if (f === '*') {
      if (!tree.$) {
        tree.set('$', {})
      }
      subsobj['*'].each(function (s) {
        subsobj['*'][s][1].each(function (ss) {
          insertLeaf(tree.$, subsobj['*'][s][1][ss], cached)
        })
      })
      return
    }
    if (!tree[f]) {
      tree.set(f, {})
    }
    if (subsobj[f].val === true) {
      if (!tree[f]._subs) {
        tree[f].set('_subs', [cached])
      } else {
        tree[f]._subs.push(cached)
      }
    } else {
      insertLeaf(tree[f], subsobj[f], cached)
    }
  })
}

function moveToEnd (arr, i) {
  var tmp = arr[i]
  while (arr[i + 1]) {
    arr[i] = arr[++i]
  }
  arr[i] = tmp
}

function removeIndex (arr, i) {
  while (arr[i + 1]) {
    arr[i] = arr[++i]
  }
  arr.pop()
}

// function byTs (a, b) {
//   return a[2] - b[2]
// }

},{"../../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../../util/hash":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/hash.js","../../../util/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/object.js","./data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/data.js","monotonic-timestamp":"/Users/youzi/dev/mtv-play/node_modules/monotonic-timestamp/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/emitter.js":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/node_modules/component-emitter/index.js"][0].apply(exports,arguments)
},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */

var util = require('../../../util'),
  io = util.isNode
    ? require('socket.io-client')
    : require('./socket.io.js'),
  G = require('../../../util/global'),
  id = require('../../../util/id'),
  urlEncode = require('../ajax').encode,
  VObject = require('../../../object'),
  Value = require('../../../value'),
  Emitter = require('./emitter')

var Cloud = module.exports = function Cloud (url, params) {

  if (!params) {
    params = {}
  }

  var cloud = this
  cloud.params = params
  cloud.url = url
  cloud.VID = params.VID = fixVID(params.VID)
    // var HID = params.HID || G.env('HID')
    // if(HID)
    //   cloud.HID = params.HID = HID
  cloud.connected = new Value(false)

  // cloud.connected.addListener(function(){
  //   console.log('connected: state change >', this.val)
  // })

  cloud.api = new Value({
    defer: function (update, args) {
      var type = this.from.__t
      if (type !== 2) {
        throw new Error('cloud.api needs to be an Object')
      }
      update()
    }
  })

  // cloud.api.on(function(){
  //  console.error('lolk cloud.api is set!! on', this.val)
  // })

  if (params.api) {
    cloud.api.val = params.api
  }

  cloud.addDocumentListeners()

  if (url instanceof VObject) {
    var current = url.val
      // console.log('current', current)

    if (current) {
      cloud.init(url, params)
    } else {
      var placeholder = new Emitter()
      placeholder.emit = function () {
        var buffer = cloud.emitbuffer || (cloud.emitbuffer = [])
        buffer.push(arguments)
      }
      placeholder.placeholder = true
      cloud.socket = placeholder
      url.addListener(function (val, p1, p2, p3) {
        // console.log('URL VAL CHANGE', this.val)
        if (this.val) {
          cloud.init(url, params)
        }
      })
    }
  } else {
    // console.log('normal burk just init', url)
    cloud.init(url, params)
  }

}

Cloud.inject = require('../../../util/inject')

Cloud.prototype.addDocumentListeners = function () {
  var cloud = this
  if (!util.isNode && window.cordova) {
    document.addEventListener('resume', function () {
      // console.log('connected: RESUME')
      cloud.connected.val = false
    }, false)
    document.addEventListener('pause', function () {
      // console.log('connected: PAUSE')
      cloud.connected.val = false
    }, false)
  }
}

Cloud.prototype.init = function (url, params) {
  //   console.log('INIT!')
  var cloud = this,
    socket = cloud.connect(url, params,
      { disconnect: function () {
          log('disconnect')
          cloud.connected.val = false
        },
        connect: function () {
          log('connect')
          cloud.connected.val = true
          socket.io.engine.on('heartbeat', function () {
            cloud.connected.val = true
          })
        },
        welcome: function (address) {
          log('welcome')
          address = address.split('@')

          var clientid = cloud.clientid = address[0],
            hubid = address[1],
            state = cloud.state

          cloud.hub = params.h = hubid

          cloud.socket.io.uri = fixUrl(cloud.socket.io.uri, params)
        },
        hop: function (newhub) {
          log('hop')
          cloud.hop(newhub)
        },
        err: function (err) {
          log.error(err)
          if (err.type === 'tokenCheck') {
            if (typeof localStorage !== 'undefined') {
              localStorage.removeItem('productionuserToken')
              localStorage.removeItem('userId')
            }
          }
        },
        reconnecting: logger('reconnecting'),
        reconnect_attempt: logger('reconnect_attempt'),
        reconnect: logger('reconnect'),
        reconnect_failed: logger('reconnect_failed')
      }
    )

  var emitbuffer = cloud.emitbuffer
  if (emitbuffer) {
    for (var e in emitbuffer) {
      socket.emit.apply(socket, emitbuffer[e])
    }
    cloud.emitbuffer = null
  }

}

Cloud.prototype.connect = function (url, params, listeners) {

  var cloud = this

  if (!url)
    url = cloud.url
  if (!params)
    params = cloud.params

  if (url instanceof VObject) {
    url = url.val
  }

  url = fixUrl(url, params)

  var oldsocket = cloud.socket

  if (oldsocket && !oldsocket.placeholder) {
    oldsocket.disconnect()
    oldsocket.io.disconnect()
  }

  // console.log('CONNECTING!', url)

  var socket = cloud.socket = new io(url, {
    forceNew: true,
    timeout: 5e3
  })

  if (listeners) {
    for (var l in listeners) {
      socket.on(l, listeners[l])
    }
  }

  if (oldsocket) {
    // console.error('------------- transferring old listeners', socket._callbacks)
    passOn(oldsocket, socket)
  }

  // ------- these extentions are only for logging:
  window.cloudmessages = []
  var _onevent = cloud.socket.onevent
  cloud.socket.onevent = function (packet) {
    window.cloudmessages.push(JSON.stringify(packet.data, false, 2))
    // console.log('incoming cloud message!', JSON.stringify(packet.data, false, 2))
    _onevent.apply(this, arguments)
  }
  var _emit = cloud.socket.emit
  cloud.socket.emit = function (event, data) {
    if (typeof data !== 'function') {
      // console.log('\ncloud.socket.emit:', event, data)
      if (event === 'batch') {
        if (data.subs) {
          for (var s in data.subs) {
            if (data.subs[s].mtvData) {
              // console.log('\nsubscribin to mtvData!', data.subs[s].mtvData)
            }
          }
        }
        if (data.sets) {
          for (var s in data.sets) {
            // console.error('set:', JSON.stringify(data.sets[s]))
          }
        }
      }
    }
    _emit.apply(this, arguments)
  }
  // ------- these extentions are only for logging:

  return socket

}

Cloud.prototype.hop = function hop (newhub) {

  // console.log('GOT ORDER TO HOP TO', newhub)

  var cloud = this,
    params = cloud.params
    // --------------- dev
  if (newhub.indexOf('@') !== -1)
    cloud.url = 'ws://' + newhub.split('@')[1]
    // --------------- /dev
  cloud.hub = params.h = newhub
  cloud.connect()
}

Cloud.prototype.whenReady = function whenReady (fn) {
  if (this.clientid)
    fn()
  else
    this.once('welcome', fn)
}

Cloud.prototype.kickPing = function kickPing (time) {
  var e = this.socket.io.engine
  e.ping()
  e.onHeartbeat(time || e.pingTimeout)
  e.setPing()
}

Cloud.prototype.disconnect = function disconnect () {
  var socket = this.socket
  if (socket) {
    socket.disconnect()
    socket.io.disconnect()
  }
}

delegateList(Cloud.prototype, 'socket', ['on', 'once', 'emit'])

function delegateList (obj, target, list) {
  for (var i = list.length - 1; i >= 0; i--) {
    delegate(obj, target, list[i])
  }
}

function delegate (obj, target, field) {
  obj[field] = function delegated () {
    var thing = this[target]
    thing[field].apply(thing, arguments)
  }
}

function logit (flag) {
  return function logger () {
    console.log(':: vigour-cloud ::', flag, arguments)
  }
}

var vflag = ':: vigour-cloud ::'
function log () {
  var args = util.arg(arguments)
  args.unshift(vflag)
  console.log.apply(console, args)
}
log.error = function (flag, err){
  console.error(vflag, flag, '\n', err)
}
function logger (flag){
  return function logger () {
    var args = util.arg(arguments)
    args.unshift(vflag, flag)
    console.log.apply(console, args)
  }
}

function fixVID (VID) {
  VID = VID || G.session('VID') || id('V_')
  return G.session('VID', VID)
}

function passOn (from, to) {
  for (var e in from._callbacks) {
    var fromlist = from._callbacks[e]
    for (var i = 0, fn; fn = fromlist[i]; i++) {
      // console.log('hand over dat listner', fn.name === 'on' && fn.fn ? 'once' : 'on',e, fn.fn || fn)
      if (fn.name === 'on' && fn.fn) {
        to.once(e, fn.fn)
      } else {
        to.on(e, fn)
      }
    }
  }
  from.off()
}

function fixUrl (url, params) {
  var cutoff = url.indexOf('?')
  if (cutoff > -1) {
    url = url.slice(0, cutoff)
  }
  return url + '?' + urlEncode(params, 'GET', 'uri')
}
},{"../../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../../util/global":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/global.js","../../../util/id":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/id.js","../../../util/inject":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/inject.js","../../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../ajax":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/ajax.js","./emitter":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/emitter.js","./socket.io.js":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/socket.io.js","socket.io-client":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/cloud/socket.io.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

module.exports = _dereq_('./lib/');

},{"./lib/":2}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var parser = _dereq_('socket.io-parser');
var Manager = _dereq_('./manager');
var debug = _dereq_('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_('./manager');
exports.Socket = _dereq_('./socket');

},{"./manager":3,"./socket":5,"./url":6,"debug":9,"socket.io-parser":40}],3:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var eio = _dereq_('engine.io-client');
var Socket = _dereq_('./socket');
var Emitter = _dereq_('component-emitter');
var parser = _dereq_('socket.io-parser');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var object = _dereq_('object-component');
var debug = _dereq_('debug')('socket.io-client:manager');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = 0;
  this.attempts = 0;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.openReconnect && !this.reconnecting && this._reconnection && this.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.openReconnect = true;
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    }

    self.maybeReconnectOnOpen();
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      self.connected++;
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  --this.connected || this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting) return this;

  var self = this;
  this.attempts++;

  if (this.attempts > this._reconnectionAttempts) {
    debug('reconnect failed');
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.attempts * this.reconnectionDelay();
    delay = Math.min(delay, this.reconnectionDelayMax());
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.attempts);
      self.emitAll('reconnecting', self.attempts);
      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.attempts;
  this.attempts = 0;
  this.reconnecting = false;
  this.emitAll('reconnect', attempt);
};

},{"./on":4,"./socket":5,"./url":6,"component-bind":7,"component-emitter":8,"debug":9,"engine.io-client":10,"object-component":37,"socket.io-parser":40}],4:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],5:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_('socket.io-parser');
var Emitter = _dereq_('component-emitter');
var toArray = _dereq_('to-array');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:socket');
var hasBin = _dereq_('has-binary');
var indexOf = _dereq_('indexof');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.subEvents();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * "Opens" the socket.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  // clean subscriptions to avoid reconnections
  for (var i = 0; i < this.subs.length; i++) {
    this.subs[i].destroy();
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (!this.connected) return this;

  debug('performing disconnect (%s)', this.nsp);
  this.packet({ type: parser.DISCONNECT });

  // remove socket from pool
  this.destroy();

  // fire events
  this.onclose('io client disconnect');
  return this;
};

},{"./on":4,"component-bind":7,"component-emitter":8,"debug":9,"has-binary":32,"indexof":36,"socket.io-parser":40,"to-array":44}],6:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_('parseuri');
var debug = _dereq_('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.hostname;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('undefined' != typeof loc) {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":9,"parseuri":38}],7:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],8:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],9:[function(_dereq_,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],10:[function(_dereq_,module,exports){

module.exports =  _dereq_('./lib/');

},{"./lib/":11}],11:[function(_dereq_,module,exports){

module.exports = _dereq_('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_('engine.io-parser');

},{"./socket":12,"engine.io-parser":21}],12:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_('./transports');
var Emitter = _dereq_('component-emitter');
var debug = _dereq_('debug')('engine.io-client:socket');
var index = _dereq_('indexof');
var parser = _dereq_('engine.io-parser');
var parseuri = _dereq_('parseuri');
var parsejson = _dereq_('parsejson');
var parseqs = _dereq_('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) opts.port = pieces.pop();
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.open();
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_('./transport');
Socket.transports = _dereq_('./transports');
Socket.parser = _dereq_('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState || 'closing' == self.readyState) {
            return;
          }
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.onClose('forced close');
    debug('socket closing - telling transport to close');
    this.transport.close();
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":13,"./transports":14,"component-emitter":8,"debug":9,"engine.io-parser":21,"indexof":36,"parsejson":28,"parseqs":29,"parseuri":30}],13:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_('engine.io-parser');
var Emitter = _dereq_('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":8,"engine.io-parser":21}],14:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var XHR = _dereq_('./polling-xhr');
var JSONP = _dereq_('./polling-jsonp');
var websocket = _dereq_('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":15,"./polling-xhr":16,"./websocket":18,"xmlhttprequest":19}],15:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_('./polling');
var inherit = _dereq_('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    });
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":17,"component-inherit":20}],16:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var Polling = _dereq_('./polling');
var Emitter = _dereq_('component-emitter');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;
  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var xhr = this.xhr = new XMLHttpRequest({ agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR });
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup();
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  try {
    this.xhr.abort();
  } catch(e) {}

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = 'ok';
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":17,"component-emitter":8,"component-inherit":20,"debug":9,"xmlhttprequest":19}],17:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parseqs = _dereq_('parseqs');
var parser = _dereq_('engine.io-parser');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_('xmlhttprequest');
  var xhr = new XMLHttpRequest({ agent: this.agent, xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":13,"component-inherit":20,"debug":9,"engine.io-parser":21,"parseqs":29,"xmlhttprequest":19}],18:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parser = _dereq_('engine.io-parser');
var parseqs = _dereq_('parseqs');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = _dereq_('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":13,"component-inherit":20,"debug":9,"engine.io-parser":21,"parseqs":29,"ws":31}],19:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":34}],20:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],21:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_('./keys');
var sliceBuffer = _dereq_('arraybuffer.slice');
var base64encoder = _dereq_('base64-arraybuffer');
var after = _dereq_('after');
var utf8 = _dereq_('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (isAndroid) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (supportsBinary) {
    if (Blob && !isAndroid) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":22,"after":23,"arraybuffer.slice":24,"base64-arraybuffer":25,"blob":26,"utf8":27}],22:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],23:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],24:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],25:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],26:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob(['hi']);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],27:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

  // Detect free variables `exports`
  var freeExports = typeof exports == 'object' && exports;

  // Detect free variable `module`
  var freeModule = typeof module == 'object' && module &&
    module.exports == freeExports && module;

  // Detect free variable `global`, from Node.js or Browserified code,
  // and use it as `root`
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  var stringFromCharCode = String.fromCharCode;

  // Taken from http://mths.be/punycode
  function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    var value;
    var extra;
    while (counter < length) {
      value = string.charCodeAt(counter++);
      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);
        if ((extra & 0xFC00) == 0xDC00) { // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }

  // Taken from http://mths.be/punycode
  function ucs2encode(array) {
    var length = array.length;
    var index = -1;
    var value;
    var output = '';
    while (++index < length) {
      value = array[index];
      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }
      output += stringFromCharCode(value);
    }
    return output;
  }

  /*--------------------------------------------------------------------------*/

  function createByte(codePoint, shift) {
    return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
  }

  function encodeCodePoint(codePoint) {
    if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
      return stringFromCharCode(codePoint);
    }
    var symbol = '';
    if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
      symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
    }
    else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
      symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
      symbol += createByte(codePoint, 6);
    }
    else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
      symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
      symbol += createByte(codePoint, 12);
      symbol += createByte(codePoint, 6);
    }
    symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
    return symbol;
  }

  function utf8encode(string) {
    var codePoints = ucs2decode(string);

    // console.log(JSON.stringify(codePoints.map(function(x) {
    //  return 'U+' + x.toString(16).toUpperCase();
    // })));

    var length = codePoints.length;
    var index = -1;
    var codePoint;
    var byteString = '';
    while (++index < length) {
      codePoint = codePoints[index];
      byteString += encodeCodePoint(codePoint);
    }
    return byteString;
  }

  /*--------------------------------------------------------------------------*/

  function readContinuationByte() {
    if (byteIndex >= byteCount) {
      throw Error('Invalid byte index');
    }

    var continuationByte = byteArray[byteIndex] & 0xFF;
    byteIndex++;

    if ((continuationByte & 0xC0) == 0x80) {
      return continuationByte & 0x3F;
    }

    // If we end up here, itâ€™s not a continuation byte
    throw Error('Invalid continuation byte');
  }

  function decodeSymbol() {
    var byte1;
    var byte2;
    var byte3;
    var byte4;
    var codePoint;

    if (byteIndex > byteCount) {
      throw Error('Invalid byte index');
    }

    if (byteIndex == byteCount) {
      return false;
    }

    // Read first byte
    byte1 = byteArray[byteIndex] & 0xFF;
    byteIndex++;

    // 1-byte sequence (no continuation bytes)
    if ((byte1 & 0x80) == 0) {
      return byte1;
    }

    // 2-byte sequence
    if ((byte1 & 0xE0) == 0xC0) {
      var byte2 = readContinuationByte();
      codePoint = ((byte1 & 0x1F) << 6) | byte2;
      if (codePoint >= 0x80) {
        return codePoint;
      } else {
        throw Error('Invalid continuation byte');
      }
    }

    // 3-byte sequence (may include unpaired surrogates)
    if ((byte1 & 0xF0) == 0xE0) {
      byte2 = readContinuationByte();
      byte3 = readContinuationByte();
      codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
      if (codePoint >= 0x0800) {
        return codePoint;
      } else {
        throw Error('Invalid continuation byte');
      }
    }

    // 4-byte sequence
    if ((byte1 & 0xF8) == 0xF0) {
      byte2 = readContinuationByte();
      byte3 = readContinuationByte();
      byte4 = readContinuationByte();
      codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
        (byte3 << 0x06) | byte4;
      if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
        return codePoint;
      }
    }

    throw Error('Invalid UTF-8 detected');
  }

  var byteArray;
  var byteCount;
  var byteIndex;
  function utf8decode(byteString) {
    byteArray = ucs2decode(byteString);
    byteCount = byteArray.length;
    byteIndex = 0;
    var codePoints = [];
    var tmp;
    while ((tmp = decodeSymbol()) !== false) {
      codePoints.push(tmp);
    }
    return ucs2encode(codePoints);
  }

  /*--------------------------------------------------------------------------*/

  var utf8 = {
    'version': '2.0.0',
    'encode': utf8encode,
    'decode': utf8decode
  };

  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:
  if (
    typeof define == 'function' &&
    typeof define.amd == 'object' &&
    define.amd
  ) {
    define(function() {
      return utf8;
    });
  } else if (freeExports && !freeExports.nodeType) {
    if (freeModule) { // in Node.js or RingoJS v0.8.0+
      freeModule.exports = utf8;
    } else { // in Narwhal or RingoJS v0.7.0-
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      for (var key in utf8) {
        hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
      }
    }
  } else { // in Rhino or a web browser
    root.utf8 = utf8;
  }

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],28:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],29:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],30:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],31:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],32:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":33}],33:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],34:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = _dereq_('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":35}],35:[function(_dereq_,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],36:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],37:[function(_dereq_,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],38:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],39:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_('isarray');
var isBuf = _dereq_('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is-buffer":41,"isarray":42}],40:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_('debug')('socket.io-parser');
var json = _dereq_('json3');
var isArray = _dereq_('isarray');
var Emitter = _dereq_('component-emitter');
var binary = _dereq_('./binary');
var isBuf = _dereq_('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments == 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    p.attachments = '';
    while (str.charAt(++i) != '-') {
      p.attachments += str.charAt(i);
    }
    p.attachments = Number(p.attachments);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i + 1 == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' != next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i + 1 == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":39,"./is-buffer":41,"component-emitter":8,"debug":9,"isarray":42,"json3":43}],41:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],42:[function(_dereq_,module,exports){
module.exports=_dereq_(33)
},{}],43:[function(_dereq_,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],44:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}]},{},[1])
(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/data/element.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../../../util')
  , element = require('../../element')
  , utilHash = require('../../../util/hash')
  , vObject = require('../../../object')

/*this file has nothing to do with the networkdata Class
  it only reads out models for elements so you can make a subscription
*/

function sortField( filter, obj ) {
  if( filter.sort && filter.sort.field ) 
  {
    var sort = { $:{} }
    sort.$[filter.sort.field] = true
    util.merge( obj, sort )
  }

  return obj
}

exports.parseData = function( val, fromtargets, logger ) {


  //important for unSubscribe ???
    // console.log('LETS PARSE DATA!'.cyan.inverse , val, JSON.stringify(fromtargets))
  

  // console.log('LETS PARSE DATA!'.cyan.inverse , val, JSON.stringify(fromtargets))

  if(!val) return
    // console.log('LETS PARSE DATA!2'.cyan.inverse , val, JSON.stringify(fromtargets))

  var subsobj = {}
    , f = val._filter
    , targets = fromtargets || val.__sub

  if (targets) {
    // console.log('targets', targets)

    if (f) {
      if(!subsobj['*']) subsobj['*']=[]
      subsobj['*'].push([
        util.clone(f, {subsObj:true, fn:true, type:true})
        , sortField(f, fromtargets || { $: targets })
      ])

    // console.log( 'IM DOING SELECTS parseDatelex', subsobj )
    //TEMPFIX!!!!
    for(var i in subsobj['*'][1] ) {
      //wel ff de fields ook doen prob

      subsobj[i] = subsobj['*'][1][i]
    }
    delete subsobj['*']

    } else {
          // console.log( 'targets IM DOING SELECTS parseDatelex', targets )

      subsobj = targets
    }
  } else {
        // console.log('LETS PARSE DATA!4'.cyan.inverse , val, JSON.stringify(fromtargets))

    // console.warn( 'cant\'t find target -- lets do stuff!', val  )
    //TODO:guard voor als het het niet wil -- mischiend door _subs zoeken

    // if(val._path) {
    //   console.log(val._path)
    // }

    //no tragets dont do anything?
  }

  // console.log('RESULT!', JSON.stringify(subsobj))

  return subsobj
}

function setFlag( obj, string, flag, field, val, from, elem ) {



  var nonCloudDataBindings
    , fromKey

    , beTripppin


  if( from ) {
    fromKey = from._name !== void 0 ? from._name : from

    if( from instanceof vObject) {

      //tegenover gestelde bij
      // if(from.__t === 4) {
        // if(from._val && from._val.cloud) {
          //haal juist field weg
        // }
      // } 
      // console.log('FROM!', from._name, from._path )
      fromKey = from._name
    }

    if(from instanceof Array && from[1]) {
      // console.log('be tripping!', from)
      //   fromKey = from[1] && from[1]._name

      // beTripppin = from[0]._name

    }

  }

  var dd = elem && from && ( elem._d || elem.checkParent('data', true) )

  // if(beTripppin) {
  //   console.log(dd, fromKey, beTripppin)
  // }


  if (field === 'collection') {
    var obj2

    if (flag.filter && flag.filter.val!==true) 
    {
      //dit nog handelen op refs
      obj2 = {}


      //ENABLE FOR SELECTION
      // if (string === true) {

      //   string = '*'
      // } else {

      //   string = string + '.*'
      // }
      var f = flag.filter.raw

        // console.log( 'SET FLAG', arguments )


  // console.log( 'FIELD!:', field , 'FROM:', from,  string.split('.'), string )

      var arr = util.path(obj, string.split('.'), [])

      arr.push( 
        [f, {
          $: sortField(f,obj2)
        }]
      )

      //obj, path, val, overwrite

      //TEMPFIX!!!!
      var temp = util.path( obj, string.split('.'), {}, true )
      for(var i in arr[arr.length-1][1] ) {
        //wel ff de fields ook doen prob

        temp[i] = arr[arr.length-1][1][i]
      }
      arr = temp

          // console.log( 'IM DOING SELECPS COL COL!', arr )


    } else {

      var f = string === true ? '$' : string + '.$'
        , p =  f.split('.')

        , specialFix

      if( dd && dd[ fromKey ] ) 
      {
        nonCloudDataBindings = true
        if( p[0] === fromKey ) 
        {
          p.shift()
          nonCloudDataBindings = false
        }
      }

      if( nonCloudDataBindings ) 
      {
        if(specialFix) {
          obj.specialFix = fromKey
          if(beTripppin) {
            obj.specialFix = [ fromKey, beTripppin ]
          }
          obj2 = util.path(obj, p , {})
          readModel(flag.element._val instanceof element ? flag.element._val : flag.element._val.base, obj2 )
        }
      } 
      else 
      {
        obj2 = util.path(obj, p , {})
        readModel(flag.element._val instanceof element ? flag.element._val : flag.element._val.base, obj2 )
      }

    }

                  // console.log(  'xxxXX1112222XXxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )


  } else {

    if( dd && dd[ fromKey ] ) 
    {
      nonCloudDataBindings = true
    }

    if ( string instanceof Array ) 
    {
      for (var i in string) 
      {
        if( nonCloudDataBindings )
        {
          //TODO: this is a tempfix
          // console.log('NON cloud bindings', string, string[i])
          if( string[i] instanceof Array ) {
            // console.log('!@!@!@')
            string[i] = string[i][0]
          }
          string[i] = string[i].split('.')
          if( string[i][0] === fromKey ) 
          {
            string[i].shift()
            util.path( obj, string[i], true )
          }
        }
        else
        {
          //TODO: this is a tempfix
          // console.log('OBJ:' , obj, 'STRING[i]:', string[i], 'STRING:', string, fromKey)
           if( string[i] instanceof Array ) {
            // console.log('2!@!@!@')
            string[i] = string[i][0]
          }
          util.path(obj, string[i].split('.'), true)
        }
      }
    } 
    else if ( string !== true && typeof string === 'string' ) 
    {
              // console.log(  'xxxXXXXxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )

      if( nonCloudDataBindings )
      {
        // console.log( nonCloudDataBindings , 'NONCLOUD')
          string = string.split('.')
          if( string[0] === fromKey ) 
          {
            string.shift()
              // console.log( 'FIELD!:222222', string )

            if(string.length > 0) util.path( obj, string, true )
          }
          // console.log( nonCloudDataBindings , 'NONCLOUD', string, obj )
      }
      else
      {
        // console.log(  'xxxxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )
        util.path( obj, string.split('.'), true )
      }
    } 
    else 
    {
      // console.log('----> 2'.inverse, string, obj, flag, field)
      // console.error('xxxxxx')
      // obj['__#__'] = true
      // obj = true;
      // console.log('!!!',obj, parent);
      // obj['#'] = true;
    }
    

  }
}

function store( obj, flag, field, val, from, elem ) {

  // console.log('STORE', arguments )

  if (flag instanceof Array) {
    for (var i = 0, l = flag.length; i < l; i++) {
      setFlag(obj, flag[i]._flag.data[2], flag, field, val, from, elem )

    }
  } else {
        // console.log('------>'.red,flag)

    setFlag(obj, flag._flag.data[2], flag, field, val, from, elem )
  }
}

function readModel( elem, obj, val, from , ignorefield) {

  // console.log( 'lets read model'.yellow.inverse, val && val._path || 'no valPath', from && from._path || 'no fromPath' , val, elem, obj, val, from )
    //hier moet het gecombineerd worden met een value waar het aan gebind is!

  if (elem.model && (elem.model.flags||elem.model.subscription||elem.model.field)) {
    
    // if(obj) console.log('XXX121212XXX COLLECTION',  elem.model.field && elem.model.field.val )
    // console.log('SET SORTFIELD! 2.12', JSON.stringify(obj,false,2))

    var a = obj
      , field

      //["users", "U_ba3215a1b1038a70", "navigation", "episode"] 
    // console.log( '\n\n\n\n\n-------->', elem.model.field && elem.model.field.val, elem.model.parsing && !elem.model.parsed  )

    if(ignorefield) {
      // console.log('STOP!'.inverse, obj, elem.model.field && elem.model.field.val, from, from && from._path)
      // debugger
    }
    //TODO: compare arrays 
    else if(elem.model.field && elem.model.field.val && !elem.model.parsing && !elem.model.parsed && ( typeof from !== 'string' || elem.model.field.val === from  )  ) {
      field = elem.model.field.val.split('.')
      

      if( elem.model.field.val === from ) {

        // console.log('HERE ITS INTERESTING DO'.cyan.inverse, elem.model.field.val , from )

      } else {

        // console.log('DO IT FIELD'.red.inverse, 1, elem.model.field, elem.model.field.val)

        a = util.path(obj,field,{},true)
      }

    } else {
      if(from && elem.model.field && elem.model.field.val !== from) {
        // console.log('!!!!!!!0000 filed !== filed'.red.inverse, elem.model.field.val, from )

        return void 0

      }
    }

    // console.log('SET SORTFIELD! 2.13', JSON.stringify(obj,false,2), from)

    if(elem.model && elem.model.subscription ) {

      //ook hier ofcourse!!!!

      var subs = elem.model.subscription.raw
      if(subs === true) {
        if(field) {
          // console.log('SET SORTFIELD! 2.13.1',field, JSON.stringify(obj,false,2))
                // console.log('---->', field, obj,field.slice(0,-1))
          if(field.length>1) {
          a = util.path(obj,field,true,true)
          } else {
            obj[field[0]] = true
            a = true
          }
        }
        // console.log('???'.green.bold.inverse,elem.model.subscription.raw, a, obj)
      } else {
        // console.log('SET SORTFIELD! 2.13.2',a, elem.model.subscription, elem.model.subscription.raw, JSON.stringify(obj,false,2))
        var sub = elem.model.subscription.raw
        if( typeof sub === 'string' ) {
          var old = sub
          sub = {}
          sub[old] = true
        }
        util.merge(a,sub)
      }

      // console.log('SET SORTFIELD! 2.14', JSON.stringify(obj,false,2))
    }

    for (var i in elem.model.flags) {
        // console.log('STORE --- go', elem.model.flags[i], elem.model.flags )

        //store

      store(a, elem.model.flags[i], i, val, from, elem )

      // if(obj.specialFix) {
      //   console.log('SP{EC')
      // }

      // console.log('SET SORTFIELD! 2.15', i, JSON.stringify(obj,false,2))
    }

  }

  if( !elem.model || !elem.model.block || !elem.model.block.val ) {

    for (
      var children = elem.children
      , child
      , child$ = 0
      , children$len = children && children.length
      ; child$ < children$len
      ; child = child$++
    ) {
      child = children[child$]
      if ((!child.model || (!child.model.inherit || child.model.inherit.val!==false))
        && !child._col && !child.data || child._dfrom) { //dit kan beter!
        readModel(child, obj, val, from )
      //elem, obj, val, from , ignorefield, field
      }
    }
  }

  if(obj['__#__']) {
    // obj.$ = true
    // util.merge(obj, obj['__#__'])
    delete obj['__#__']
  }


  // if(obj.specialFix) {
  //   console.log('HEREHEREHERE', JSON.stringify(obj,false,2) )
  // }

  // for(var i in obj) {
  //   if(obj[i]&&obj[i].specialFix) {
      
  //     console.log('HERE!!!', obj.specialFix, JSON.stringify(obj,false,2))

  //   }
  // }

  //elem, obj, val, from , ignorefield, field

  return elem.model && elem.model.block && elem.model.block.val==='all' ? void 0 : obj
}

util.define(element, 'getModel', function( val, from, ignorefield ) {

  // if(ignorefield) console.log( 'lets get that model!'.green.inverse , val, 'FROM!', from && from._path, this )
  var subscription = readModel( this, {}, val, from, ignorefield )
  // console.log( 'subscribs!!!!'.blue, subscription )
  // if(ignorefield) {
  //   console.log('IGNOREFIELD', subscription)
  //   // debugger
  // }
  // if(subscription.specialFix) {
  //   console.log('HJEEE', subscription.specialFix, JSON.stringify(subscription,false,2))
  //   if(subscription.specialFix instanceof Array) {



  //   }
  // }

  // for(var i in subscription) {
  //   if(subscription[i]&&subscription[i].specialFix) {
      
  //     console.log('HERE!!!',i, subscription.specialFix, JSON.stringify(subscription,false,2))

  //   }
  // }

  return !util.empty( subscription ) ? subscription : null
})
},{"../../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../../util/hash":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/hash.js","../../element":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/element/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/data/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var object = require('../../../object')
  , data = require('../../../data')
  , Value = require('../../../value')
  , util = require('../../../util')
  , vigour = require('../../../')
  , _networkdata = module.exports = exports = vigour.Networkdata = data.new({
      mixed: 4, //mischien niet mixed
      merge: true
    })
  , _sub = 'subscribe'
  , _unsub = 'un' + _sub
  , _listener = 'Listener'
  , _al = 'add' + _listener
  , _rl = 'remove' + _listener
  , _proto = object.prototype
  , _protoAddListener = _proto[_al]
  , _protoRemoveListener = _proto[_rl]
  , _checkSubscription = function( field, val ) {
      var a = this
      while (a && a.__t === 4) {
        if(a.__block) return
        a = a._val
      }
      // console.log(field, a)
      if((a instanceof _networkdata) && a[field]) a[field](val, this)
    }
  , V = require('../../../')

_networkdata.prototype._blacklist.push('_subs','_complete')
//'_' + _sub, '_' + _unsub, we dont use there now
// _subscribe(_sub);
// _subscribe(_unsub);


//TODO: fix mark!!!!!!!!!!! mark:true
util.define(_networkdata,
  'get', function( val, set, notself, stamp ) {
    
    // IM GETTING! ["users", "u_ba3215a1b1038a70", "mtvData", "NL", "nl", "shows"] undefined
    //obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, i
    // var bla = (val instanceof Array) ? val : String(val).split('.')
    // console.log('IM GETTING!', bla, val, set, this, this.path)

    //TODO: Always give me the non-from is possible
    // console.warn('Get -- self is now on on defualt should become something different!')
    //obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self,
    //conditional self

    return this.path
      ( (val instanceof Array) ? val : String(val).split('.')
      , set !== void 0 ? set : {}
      , false
      , false
      , false
      , stamp || false //stampy
      , true
      , !notself
      )

  },
  // '_changevobj', function(val,stamp) {
  //   console.error(val,stamp)
  //   return _changevobj.apply(this,arguments)
  // },
  // '_hook', function(val, param) {
  //   for (var i in param) {
  //     this['_' + i] = param[i];
  //   }
  // }, //dont use this now so lets add when used
  _al, function( val ) {
    // console.log('LETS GO!', _sub, val, !!this[_sub])
    if(this[_sub]) this[_sub](val)
    _protoAddListener.apply( this, arguments )
  },
  _rl, function( val, mark ) {
    if (this._listeners && this[_unsub]) {
      // console.log('REMOVE _L'.red.inverse, mark)
      this[_unsub]( mark )
    }
    _protoRemoveListener.apply( this, arguments )
  }
);

//-------DATA---------
util.define(data, 
  _al, function(val) {
    // console.log('0--------->',val)
    if(!this.__block) _checkSubscription.call(this, _sub, val);
    _protoAddListener.apply(this, arguments);
  },
  _rl, function(val, mark) {
     // console.error('2.1 REMOVE _L', mark, val, _unsub)
    if(!this.__block) _checkSubscription.call(this, _unsub, mark);
    _protoRemoveListener.apply(this, arguments);
  }
);

//-------Value---------

// util.define(Value, //test is this impacts performance to much
//   _al, function(val) {
//     // console.log('0--------->',val)
//     if(!this.__block) _checkSubscription.call(this, _sub, val);
//     _protoAddListener.apply(this, arguments);
//   },
//   _rl, function(val, mark) {
//      // console.error('2.1 REMOVE _L', mark, val, _unsub)
//     if(!this.__block) _checkSubscription.call(this, _unsub, mark);
//     _protoRemoveListener.apply(this, arguments);
//   }
// );





},{"../../../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../../../data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","../../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/url.js":[function(require,module,exports){
var util = require('../../util')
  , Value = require('../../value')
  , config = require('../../util/config')
  , process = require('../../value/flags/process')
  , raf = require('../../browser/animation/raf')
  , postpone = require('../../browser/events/util').postpone
  , ua = require('../../browser/ua')
  , cases = require('../../browser/cases')
module.exports = exports = new Value()
//TODO: .params /w listeners!

// config.hashUrl = ua.device === 'tv' && ua.platform === 'lg' ? false :  config.hashUrl

if (cases.crawler) {
  config.hashUrl = false
}
console.log('config.hashUrl',config.hashUrl)
// history.pushState({}, '','' )
// history.go(0)
// history.back()
var pstate = !config.hashUrl //= !window.DEBUG$ && window.history && window.history.pushState
  , cnt = 0
  , timedState
  , state = postpone ( pstate ? function(val) {
      window.history.pushState( {}, '', '/'+val.replace(/ /g, '+').replace(/^#\//, '').toLowerCase() )
    } : function(val) {
      exports.block = true
      window.location.href = '#/' + val.replace(/ /g, '+').toLowerCase()
      exports.block = false
    } )
  , _set = Value.prototype._set
  , parse = function() {
      if (!pstate)
      {
        var url = window.location.href.split('#')
        var params = ''
        if( url && url.length === 1 ) {
          params = query( url[0] )
          url[0] = url[0].replace(params, '')
          // window.location = '#/'+params
          // return = 'x'
        }
        // console.log( url, ( url.length > 1 ? url[1].replace(/\+/g, ' ') : ' ' ).slice(1), params )
        // +params
        return ( url.length > 1 ? url[1].replace(/\+/g, ' ') : ' ' ).slice(1)+params
      } else
      {

        var url = window.location.href
        if( url ) {
          params = query( url )
          url = url.replace(params, '')
          // window.location = '#/'+params
          // return = 'x'
        }

        return String(window.location.href)
               .replace(String(window.location.origin) + '/', '')
               .replace(/^#\//, '')
               .replace(/\+/g, ' ')
               || ''
      }
    }
  , query = function( str ) {
      if(!str) str = parse() || ''
      var arr = str.split('?')
        , len = arr.length
      str = len > 1 && arr[ arr.length - 1 ] ? '?'+arr[ arr.length - 1 ] : ''
      return str
    }

exports.parse = parse

//TODO: back btn hijack (event hijack add random param)
//TODO: use raf for updates
exports.val = {
  string: function() {
    var str = parse()
    return str.replace( query( str ), '' )
  },
  params: {
    val: function() { return query() },
    defer:function( update, args ) {

      this.clearCache() //maybe not?

      var val = this.val
        , params
        , nestedparams
        , c

      if( val && val!==this._last ) {
        this._last = val
        params = val.slice(1).split('&')
        nestedparams = {}
        for( var i in params ) {
          c = params[i].split('=')
          if( c.length>1 )
          {
            nestedparams[c[0]] = c[1]
          }
          else
          {
            console.error('url: no [key]=[value] format -- not implemented yet')
          }
        }
        this.val = nestedparams
      }
      raf(function() { update() })
    }
  },
  transform: function( v, cv ) {
    return cv
  },
  defer: function( update, args ) {
    if( args[1] && args[1][0] === 'u' )
    {
      this.clearCache()
      raf( function() {
        update()
      })
    } else
    {
      this.clearCache()
      var a = ( typeof args[0] === 'string'  ? args[0] : args[0] && args[0].val || this.val )
      if(a)
      {
        exports.blocks = cnt

        state( a + this.params.val )
      }
      return  true
      //TODO: update( true ) blocks all consecutive updates
    }
  }
}

function urlEvent(e) {
  var stamp

  if( !config.hashUrl || exports.blocks!==cnt )
  {
    cnt++
    stamp = 'u'+cnt
    exports.clearCache()
    exports.string.clearCache() //maybe not clear on string?
    // exports._update( parse(), 'url' )
    exports.string._update( exports.string.val , stamp )
    exports.params._update( exports.string.val, stamp )
    exports._update( exports.string.val, stamp )
    exports._lstamp = null

  } else {
    cnt++
  }
}

util.define( exports, 'update', function() {
  urlEvent()
})

util.define( exports.string, 'raw', {
  get:function() {
    return this.val.replace( / /g, '+' )
  }
})

if( config.hashUrl )
{
  window.onhashchange = urlEvent
}
else
{
  window.onpopstate = urlEvent
}
//TODO: add popstate

},{"../../browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","../../browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","../../browser/events/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/events/util.js","../../browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../util/config":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js","../../value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../../value/flags/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js":[function(require,module,exports){
/*
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
/*
/*
  useragent sniffing is never used for feature detection, for a multi-screen app you do need information about the device also when running in the browser
  has fields V.ua.platform, device, browser and version. This implementation when compiled, is only 700 bytes
*/
var util = require('../util')
/**
 * test
 * search for regexps in the userAgent
 * fn is a on succes callback
 * check http://www.useragentstring.com/ to test for userAgents
 * @method
 */
, test = exports.test = function( _ua, fn ) {

  for
  ( var tests = util.arg( arguments, 1 )
      , i = tests.length - 1
      , query = tests[i][0]
    ; query !== true && !new RegExp( query ).test( _ua )
    ; query = tests[--i][0]
  )

  ;if( fn.slice || fn.call( this, query, tests[i] ) )
  {
    this[fn] = tests[i][1]
  }

}
, parse = exports.parse = function(_ua, obj) {

  if( !_ua )
  {
    obj = exports
    _ua = typeof navigator !== 'undefined'
        ? navigator.userAgent.toLowerCase()
        : 'no navigator'
  }

  _ua = _ua.toLowerCase()

  if( !obj ) obj = {}

  // _ua = 'webos; linux - large screen'

  var _ff = 'firefox'
    , _android = 'android'
    , _mobile = '.+mobile'
    , _webkit = 'webkit'
    , _ps = 'playstation'
    , _xbox = 'xbox'
    , _linux = 'linux'
    , _castDetect = 'crkey'
    , _chromecast = 'chromecast'
    , _tablet = 'tablet'
    , _windows = 'windows'
    , _phone = 'phone'
    , _iphoneVersion

  test.call
  ( obj
  , _ua
  , function( query, arr ) {

      obj.browser = arr[2] || query

      var _v = _ua.match
      ( new RegExp
        ( '((([\\/ ]version|'
        + arr[0]
        + '(?!.+version))[\/ ])| rv:)([0-9]{1,4}\\.[0-9]{0,2})'
        )
      )

      obj.version = _v ? Number( _v[4] ) : 0
      obj.prefix = arr[1]
      //TODO: add prefix for opera v>12.15;
      //TODO: windows check for ie 11 may be too general;
    }
  , [ true, _webkit ]
  , [ '\\(windows', 'ms', 'ie' ]
  , [ 'safari', _webkit ]
  , [ _ff, 'Moz' ]
  , [ 'opera', 'O' ]
  , [ 'msie', 'ms', 'ie' ]
  , [ 'chrome|crios\/', _webkit, 'chrome' ]
  )

  /**
  * platform detection
  */
  test.call
  ( obj
  , _ua
  , 'platform'
  , [ true, _windows ]
  , [ _linux, _linux ]
  , [ 'lg.{0,3}netcast', 'lg' ] //TODO:propably need to add more!
  , [ _ff + _mobile, _ff ]
  , [ 'mac os x', 'mac' ]
  , [ 'iphone|ipod|ipad', 'ios' ]
  , [ _xbox, _xbox ]
  , [ _ps, _ps ]
  , [ _android, _android ]
  , [ _windows, _windows ]
  , [ _castDetect, _chromecast ]
  , [ 'smart-tv;|;samsung;smarttv', 'samsung' ] //SmartTV2013
  )

  /**
  * device detection
  */
  test.call
  ( obj
  , _ua
  , 'device'
  , [ true, 'desktop' ]
  , [ _windows + '.+touch|ipad|' + _android,  _tablet ]
  , [ 'iphone|(' + _android + _mobile + ')|(' + _ff + _mobile + ')|' + _windows + ' phone|iemobile'
    , _phone
    ]
  , [ _xbox + '|' + _ps, 'console' ]
  , [ 'tv|smarttv|googletv|appletv|hbbtv|pov_tv|netcast.tv|webos.+large', 'tv' ]
  , [ _castDetect, _chromecast ]
  , [ 'amazon-fireos', _tablet ]
  )

  //TODO: amazon firetv and phone
    // alert(window.innerWidth*window.innerHeight +  '  '+ 414 * 736)
  
  //414 × 736
  var iphone6plus = 414 * 736
  if
  ( obj.platform === _android
    && !util.isNode
    && obj.device === _phone
    && window.innerWidth*window.innerHeight > iphone6plus
    // && ~_ua.indexOf('crosswalk')
  )
  {
    obj.device = 'tablet'
  }

  return obj
}

if( !util.isNode ) 
{ 
  parse()
  //TODO: this is very ugly, try to find a better solution
  if( window.__ua__ ) 
  {
    for( var field in window.__ua__ )
    {
      exports[field] = window.__ua__[field]
    }
  }
}

/**
 * prop
 * re-writes js properties to their css counterpart
 * e.g. webkitTransform --> -webkit-transform
 * now its commented since its not nessecary yet
 * @method
 */
// this.prop = function(str) {
//  return str.replace(this.prefix,'-'+this.prefix+'-').toLowerCase();
// }

},{"../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var  data = require('./')
  , base = require('../base')
  , util = require('../util')
  , flags = require('../value/flags/data')
  , vObject = require('../object')

exports.extend = util.extend( function(base, extensions, modelblacklist) {

  // var _blacklist = util.add(['flags', 'ref', 'parse', 'parsing'], modelblacklist),
    var _compare = util.compareArrays,
    methods = {
      _dUpdate: function(obj, val, stamp, from, remove, added, oldval, instances, argx1, argx2 ) {
        // if(window.here) console.log('X',stamp)
        if (this.model) {

          //$ndata

          //TODO: very dirty fix get rid of this!
          if( obj === '$ndata' ){
            val = from
            stamp = remove
            from = added
            remove = oldval
            added = instances
            oldval = argx1
            instances = argx2
            // console.log('!@#!@#!@#!@#@!#!@#!@#!@#'.red.inverse)
          }

          // var non = 0
          //   , cnt = 0
          // for( var i in arguments ) 
          // {
          //   cnt++
          //   if(!arguments[i]) {
          //     non++
          //   }
          //   console.log( arguments[i] )
          // }
          // if(non === cnt) {
          //   alert('no args')
          //   return true
          // }

          if (!this._d && this.parent) {
            var p = this.parent;
            while (!this._d && p) {
              if (p._d) {
                // console.error('SET DATA')
                this._dSet(p._d, true);
              } else {
                p = p.parent;
              }
            }
          }
          var t = this,
            model = t.model,
            f = model.flags,

            // f = model ? model.flags : false be carefull with updates in values that have data

            path = t._d && t._d._path || [],
            name = (from || (from = (t._d && t._d._updateOrigin)) && !(from === t._d && (from = false))) && from.updatePath,
            fromPath = from && from._path,
            method = function(i, field) {

              var select, pass, fr, lfield;
              // if( field._flag[2].__t) {
              //multiple flags!
                // console.log('FLAG'.inverse, name, field._flag)
              // }

              if(!field._flag.data) {
                console.error('NO DATA FLAG', name, field._flag, val, obj, remove, added, oldval)
                return
              }
              field = field._flag.data[2];

               // console.log('DATA UPDATE'.magenta.inverse,
               //      'obj:', obj
               //    , 'val:', val
               //    , 'stamp:', stamp
               //    , 'from:', from
               //    , 'remove:', remove
               //    , 'added:', added
               //    , 'field:', field
               //  )
              // var test = (i==='text' && field === 'real.duration')
              // if(test) console.log(field,i)
              // if(test) pass = true

              if (i === 'collection' && t._colFilter) return
              //if not own colfilter --> handle yourself!;
              // if data has changed change colfilter adn send update
              //be carefull /w changes!; too crude

              if (field === true) {
                // console.log('PASS'.inverse,name)
                pass = true;
              } else if (field.pop) {
                // console.log(name,'???')

                // console.log('--->',field, field.pop)

                field = field.concat();

                for (var j = field.length - 1; j >= 0; j--) {
                  if (!lfield !== void 0) {
                    select = util.get(t._d, field[j]);
                    if (select !== void 0) {
                      lfield = true;
                      // break;
                    }
                  }
                  field[j] = field[j].split('.');
                }
              } else {

                // console.log('DO DO!'.inverse,name, t._d && t._d._updateOrigin)

                // console.log(name, path, select, obj, val, stamp, from, remove, added, oldval, instances)

                field = field.split('.')

                select = util.get(t._d, field)

                if(!select && t._d && t._d.from && field ) {
                  // console.log('NO SELECT'.red.inverse, t._d )
                  select = util.get(t._d.from, field)
                  // if(select) {
                  //   // console.log('FOUND SELECT'.green.inverse, select)
                  // }
                } 

                if(select && from && from.__t === 4) lfield = true //test dit of het alles slow maakt

                // if(test&&select) console.log(select._val)
              }

              if (!pass && from) {

                // console.log('testing....?', name, from, select, lfield)
                // if(test) console.log(name, select, lfield, from);

                fr = true;
                var fromFrom

                if ( from === select || ( fromFrom = from.from ) === select ) {
                  pass = true;
                } else {
                  if (t._d._filter && select && select._ancestor(from)) {
                    pass = true;
                    //field ook voor arrays!;
                  } else if (lfield) {

                    // console.log('got lfield!!!!')

                    for (var n = 0; n < field.length; n++) {
                      if (name && _compare(name, field[n]) || field[n][0] === name[0] && util.get(val, field[n].concat().shift())) 
                      {
                        fr = false;
                        break;
                      } 
                      else if ((_compare(path.concat(field[n]), fromPath) || _compare(field[n], fromPath))) 
                      {
                        fr = false;
                        break;
                      } 
                      else {

                        // console.log('HERE?'.cyan.inverse, '\n\n\n', select.from.raw, 'val:'
                        //   , val, 'field:', field, 'fn', field[n], 'n:', n, 'check field:', val && val[field[n]], 'ref:', val.from)
                        // console.log('coming trugh', select && from._val !== null && val, field[n]
                        //   , select && from._val !== null && val && ( val[field[n]] || val.__t === 4 && val.from[field[n]] ) )
                        //TODO: need to add more gaurding for val.$path check if this is cloud and ref

                        if(select && from._val !== null && val && (val[field[n]] || val.$path || val.__t === 4) && (select._ancestor(from) || select.from._ancestor( fromFrom )  ))  //
                        {
                          // console.log(val, field);
                          pass = true;
                          break;
                        }
                      }
                    }
                  } else {

                    // console.log( '---', select, val, field, from, 'fromPath:' , fromPath )

                    if(val===null) {
                      // if(DEBUG$) t._d.DEBUG$log('data/base ---> ERROR val is null  --->'+t._d._removed )
                    } else if(val === void 0) {
                      // TODO: handle this
                      // console.log('\n\n\n undefined what to do now?', arguments,this)
                      // debugger
                      // pass = true
                      // pass = true
                    } else if (name && _compare(name, field) || field[0] === name && name[0] && util.get(val, field.concat().shift())) {
                      fr = false;
                    } else if (path && (_compare(path.concat(field), fromPath) || _compare(field, fromPath))) {
                      fr = false;
                    } else if (select && (val[field[0]]) && select._ancestor(from)) {
                      // console.log(val, field);
                      pass = true
                    } else if( t.__checkKeys__ ) {
                      // console.log('lets checkj the keys!')
                      // console.log( field, name, val, path, select, val[field[0]], from, this )
                      for( var key$ in t.__checkKeys__ ) {
                        if( field === t.__checkKeys__[key$] || field[0] === t.__checkKeys__[key$] ) {
                          // console.log('maybe??!!@#!@', i, t.__checkKeys__[key$])
                          pass = true
                        }
                      }

                    }
                    // console.log(val, field[0], from);
                  }
                }
              }
              // pass = true;
              // console.log('PASS>>>>>>>>>?'.magenta.inverse, pass ? 'OK!'.green.inverse : 'NO!'.red.inverse  
              //   , 'val:'.blue, val
              //   , 'obj._path:'.blue, obj && obj._path
              //   , 'field:'.blue, field
              //   , 'fromPath:'.blue, fromPath
              //   , 'from:'.blue, from
              //   , 'select'.blue, select
              //   )

              // if(! pass && )

              // pass = true

              //|| remove 

              if (pass || remove || (instances || remove || select !== void 0) && ( !fr || remove === 1)) {

                // console.log('updating!'.cyan.inverse, i, val, instances, remove, select, fr, from)
                // debugger
                //stamp meegeven????
                // console.log( 'FROM!!!!!'.green.inverse, from )
                // console.l
                t[i]._update(val, false, from, remove, added, oldval, !instances, t);
                return true;
              }
            };
          //----------------------------------------------------
            //add advanced models (like on website)
            //not tested and still pretty broken
           var parser = function() {
            if (this._d) {
              var t = this, a
              //if added or first run
              t.model.val //set _caller
              // if (model.field) console.log('????', this.field, model.field)

              if (model.field) a = util.get(t._d, model.field.val)
              if (model._val) a = model._val.call(t, a || t._d) || a
              if (a && t._d !== a) {
                model.parsing = true
                if(model.field) model.parsed = model.field.val
                this._dSet(a)
                model.parsing = false
              }
            }
          }
          parser.call(t)
          if (instances) t.eachInstance(parser, 'model')
          //----------------------------------------------------

          //----------------------------------------------------
          if (f && (instances || t._d)) {
            for (var i in f) {
              if (!f[i].__t) {
                for (var j = 0, l = f[i].length; j < l; j++) {
                  if (method(i, f[i][j])) {
                    break;
                  }
                }
              } else {
                method(i, f[i]);
              }
            }
          }
          //----------------------------------------------------

         if(this.model.complete) this.model.complete._val.call(this,data)

        }
      },
      _dSet: function(val, dfrom) {


        // if(val) {
        //   console.log('_Dset'.cyan.inverse, val._path, dfrom)
        // }
        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        if(this.model._flag && this.model._flag.defer  && !this.__processing) {
          this.__pFlag = [ val, dfrom ]
          return
        }

        //dfrom moet niet nog een subscribe doen! -- als het goed is is zn parent al subscribed

        if (this._d && this._d.__t) this._d.removeListener(true, this)
        this._d = val
        if (dfrom) this._dfrom = true
        this._dListen()



        return val;
      },
      _dListen: function() {

          // console.log('HEEEEEE', this.model)

        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        //hier gaan we s fftjes werken met each

        // this._dfrom = true;
        var _this

        if (this.model && this._d && this._d instanceof vObject) 
        { //this model maybe not nessecary?

          // console.log('----->'.cyan.inverse, this._d )

          this._d.addListener([this._dUpdate, this])

          _this = this
          
          //hier filteren op cloudData --- ook werken vanuit remove!!!
            //never do for cloud data
         
          if( !this._d.cloud )
          {
            this._d.each(
              function() { 
                _this.__checkKeys__ = true

                if(this.__t === 4 ) this.addListener([ _this._dUpdate, _this, '$ndata', this ]) 
              }
            )
          }
          //eventueel .val gebruiken voor Values *awesjume!
          //eventueel hier dingen adden aan model

        } 
        else if( this.model && this._d ) 
        {
          for( var key in this._d ) 
          {
            if(!this.__checkKeys__ || this.__checkKeys__ === true) this.__checkKeys__ = []
            if( this._d[key] instanceof vObject )
            {
              if(!this.__checkKeys__.push) {
                console.error('xxxxxx', this, this.__checkKeys__, key, this._d)
                debugger
              }
              this.__checkKeys__.push( key )
              this._d[key].addListener([ this._dUpdate, this, '$ndata', key ])
            }
          }

        }
      },
      updateData: function(instances) {

        if(this.model._flag && this.model._flag.defer && !this.__processing) {
          // console.log('oo2')
          this.__pFlagU = [ instances ]
          this.model._update()
          return
        }
        // console.log('!DOIT updateData'.cyan.inverse)

        this._dUpdate(this._d, void 0, false, false, false, false, false, instances)
      }
    },
    extend = function(i) {
      base.extend({
        name: i,
        type: false,
        value: (extensions && extensions[i]) ? function() {
          methods[i].apply(this, arguments);
          extensions[i].apply(this, arguments);
        } : methods[i]
      });
    };
  for (var i in methods) {
    extend(i)
  }
  base.extend({
    name: 'model',
    cache: false,
    set: function(val) {

      if(this.__pFlag || this.__pFlagU) {
        /*
        TODO: test defer better!!!
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        */
        this.__processing = true
        this.model.parsing = false
        if(this.__pFlag) {
          this._dSet.apply(this,this.__pFlag)
        }
        //subscribe helemaal fucked met field erbij
        if(this.__pFlagU) {
          this.updateData.apply(this,this.__pFlagU)
        }
        this.__pFlagU = null
        this.__pFlag = null
        this.__processing = null
      }

      if(val.field && val.field.val !== val.parsed) {
        var a = val.parsed && val.parsed.split('.')
          , parent
        val.parsed = null
        if(this._d) {
          parent = this._d
          if(a) {
            for(var i = a.length-1; i >=0 ; i--) {
              parent = parent._parent
            }
            if(parent) {
              this._dSet(parent)
              this.updateData(true)
            }
          } else {
            this.updateData(true)
          }
        }
        val.parsed = null
      }
    },
    remove: function() {
      if( this._d )
      {
        if ( this._d.__t )  
        {
          this._d.removeListener( void 0, this )

          if( !this._d.cloud )
          {
            var _this = this
            this._d.each(
              function() { 
                // _this.__checkKeys__ = true
                if(this.__t === 4 ) this.removeListener( void 0, _this ) 
              }
            )
          }

        }
        else if( this.__checkKeys__) 
        {
          for( var key$ in this.__checkKeys__ ) 
          {
            if( this._d[this.__checkKeys__[key$]] instanceof vObject )
            {
              this._d[this.__checkKeys__[key$]].removeListener( void 0, this )
            }
          }
        }
      }
    }
    // parent: function(parent) {
    //   if( parent.data && (!parent.parent || parent.parent.data!==parent.data) ) {

    //     console.error('WTF?')

    //     this.data = parent.data
    //   }
    // }
  }, {
    name: 'data',
    type: false,
    set: function(val) {
        // console.log('?',val)
      if( this._d === val ) return

      // if(!this.model) this.model = {} //dit met het nooit setten van fmodel scheel op show al 3/9 subscriptions
      //nu nog shared subs maken -- 'shows' (ook meteen process) en dan word thet als het goed is nog een stuk minder
    
      // this.model = {} //pas op met deze
      // console.log('?2')

      if( this.model._flag && this.model._flag.defer ) {
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        // console.log('!@#!@#!@# OOOO'.red)
        return
      }

      // console.error('!!!!!MODEL -- dit moet zoveel mogelijk gereduced', this.model)

      this.model.parsing = false
      this._dSet(val)

      //subscribe helemaal fucked met field erbij
      this.updateData(true)

    },
    get: function() {
      return this._d
    }
  })
})
},{"../base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js","../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../value/flags/data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/data.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/conditions.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var data = require('./'),
  cnt = 0,
  handleTest = module.exports = function(test, subsObj) {
    // console.error('handleTest!', test)
    if (test instanceof Object) {
      var keys = Object.keys(test);
      if (keys.length === 1) {
        var key = keys[0]
          , valcheck = handleField(key, test[key], subsObj)
          
        return subsObj._check = function(doc){
          // console.log('TESTING', test, doc && doc.raw)
          // console.log('checking for key', key)
          var val = getValue(doc)
          return valcheck(val)
        }
      } else {
        var list = [],
          key;
        for (var k = 0, l = keys.length; k < l; k++) {
          key = keys[k];
          list.push(handleField(key, test[key], subsObj));
        }
        return subsObj._check = makeAND(list);
      }
    } else {
      return subsObj._check = function(doc) {
        return getValue(doc) === test;
      }
    }
  }

function handleField(key, value, subsObj) {
  // console.warn('handleField [', key, '] value', value)
  var check;
  switch (key) {
    case '$not':
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj);
        check = function(doc) {
          return follow(doc) === false;
        };
      } else {
        check = function(doc) {
          return doc !== value;
        };
      }
      break;
    case '$ne':
      check = function(doc) {
        return doc !== value;
      };
      break;
    case '$and':
      var list = makeList(value, subsObj);
      check = makeAND(list);
      break;
    case '$nand':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc) === false) return true;
        }
        return false;
      };
      break;
    case '$or':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return true;
        }
        return false;
      };
      break;
    case '$nor':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return false;
        }
        return true;
      };
      break;
    case '$every':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (!follow(this)) return !(result = false);
          });
          return result;
        } else {
          return false;
        }
      };
      break;
    case '$nevery':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = false;
          doc.each(function() {
            if (!follow(this)) return result = true;
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$':
    case '$some':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj.$);
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (follow(this)) return found = true;
            });
            return found || false;
          }
          return false;
        };
      } else {
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (this === value) return found = true;
            });
            return found || false;
          }
          return false;
        };
        subsObj.$._check = function(doc) {
          return doc === value;
        };
      }
      break;
    case '$nsome':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (follow(this)) return !(result = false);
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$lt':
      check = function(doc) {
        // console.log('burk lt', doc, value)
        return doc < value;
      };
      break;
    case '$lte':
      check = function(doc) {
        return doc <= value;
      };
      break;
    case '$gt':
      check = function(doc) {
        return doc > value;
      };
      break;
    case '$gte':
      check = function(doc) {
        return doc >= value;
      };
      break;
    case '$contains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return regex.test(doc);
      };
      break;
    case '$ncontains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return !regex.test(doc);
      };
      break;
    case '$containsall':
      break;
    case '$ncontainsall':
      break;
    case '$has':
      check = function(doc) {
        return doc && doc[value] !== void 0;
      };
      break;
    case '$nhas':
      check = function(doc) {
        return !doc || doc[value] === void 0;
      };
      break;
    case '$exists':
      check = function(doc) {
        return (doc !== void 0 && doc !== null) === value;
      };
      break;
    case '$in':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return true;
        }
        return false;
      };
      break;
    case '$nin':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return false;
        }
        return true;
      };
      break;
    case '$regex':
      check = function(doc) {
        return value.test(doc);
      }
      break;
    default:
      if (value instanceof Object) {
        var dsubsObj = subsObj[key];

        if (dsubsObj) {
          // console.log('already made that dsubsObj with key', key);
          // dsubsObj._up = subsObj
        } else {
          subsObj.set(key, {});
          dsubsObj = subsObj[key];
        }
        var follow = handleTest(value, dsubsObj);

        check = function(doc) {
          // console.log('TESTING: check OBJECT', doc && doc.raw || doc, 'for field', key)
          doc = getField(doc, key)

          // console.log('wups', doc && doc.raw || doc)
          return follow(doc);
        };
      } else {
        check = function(doc) {
          doc = getField(doc, key)
          
          // doc = getValue(doc)
          // console.log('TESTING: check VALUE', doc && doc.raw || doc, value, doc === value)
          return doc === value;
        };
        subsObj.set(key, {});
        subsObj[key]._check = check
        // subsObj[key] = {
        //   _up: subsObj,
        //   _check: function(doc) {
        //     return doc === value;
        //   }
        // };
      }

  }
  return subsObj ? subsObj._check = check : check;
}

function makeList(arr, subsObj) {
  var list = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    list.push(handleTest(arr[i], subsObj));
  }
  return list;
}

function makeAND(list, subsObj) {
  return function(doc) {
    var val = getValue(doc);
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i](val) === false) return false;
    }
    return true;
  };
}

function getValue(thing){
  var val = thing && thing.from && thing.from.val
  return val !== void 0 ? val : thing
  
}
function getField(thing, field){
  // console.error('getField field', field, 'from', thing && thing.raw || thing)
  thing = getValue(thing)
  return thing ? getValue(thing[field]) : void 0
}
},{"./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('old-vigour-js'),
  object = require('old-vigour-js/object'),
  util = require('old-vigour-js/util');

module.exports = exports = V.Data = object.new();
exports.prototype._blacklist.push('__sub','__block');
util.define(exports, '_hook', function(val, obj) {
  if (obj.subscription) {
    this.__sub = obj.subscription;
    delete obj.subscription;
  }
  if(obj.block) {
    this.__block = true
    delete obj.block
  }
});


},{"old-vigour-js":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/selection.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */

var conditions = require('./conditions')
  , utilHash = require('../util/hash')
  , VObject = require('../object')
  , util = require('../util')

/**
 * Selection
 * Class extention for selection / filtering functionality
 * @Class
 */

exports.SubsObj = VObject.new()
exports.SubsObj.prototype._blacklist.push( '_root'
                                         , '_check'
                                         , '_sort'
                                         , '_uid'
                                         )

exports.extend = util.extend(function(base){

  base.prototype._blacklist.push( '_filter'
                                , '_uid'
                                , '_hash'
                                , '_indexCache'
                                , '_subscnt'
                                )

  var _update = base.prototype._update
    , _hook = base.prototype._hook
    , _remove = base.prototype.remove

  util.define( base
    , 'remove', function() {
        var l
        if(this._filter && (l = this.length)){
          for(var i = 0; i < l; i++)
            delete this[i]
        }
        return _remove.apply(this, arguments)
      }
    , 'filter', {
        get: function() {
          return this._filter
        },
        set: function(val) {
          // console.log('new filter \n from --->', this._filter, '\n to ---->'
          //            , val
          //            )
          this._filter = val //moet ook werken als data nog geen selection is
          this._build(undefined, true)
          _update.call( this, void 0, this.stamp(), void 0, false
                      , false, void 0
                      )
        }
      }
    , '_hook', function(val, filter) {
        if (_hook) {
          _hook.call(this, val, filter)
        }
        if (!util.empty(filter) && val) {
          var selection = this
          selection._subscnt = 0
          selection._filter = filter

          selection._hash = utilHash(val._path + JSON.stringify(
            [ filter.condition
            , filter.range
            , filter.sort
            ])
          )
          //!only nessecary serverside!
          if (!selection._uid) selection._uid = selection._hash
        };
      }
    , '_build', function(val, noupdate) {
        var selection = this
        
        if (!val) val = selection._val
        if(!val) return
        if (selection.length) selection._clear() 

        var list = []
          , itemsHandler = this._itemsHandler
          , filter = selection._filter
          , subsObj = filter.subsObj || new exports.SubsObj({}, selection)
          , stamp = this.stamp()
          , sort, item

        if (val.__t === 4 && !val._filter) {
          val = val.from;
        }

        if (filter.sort) {
          if (typeof filter.sort === 'string') {
            filter.sort = {
              field: filter.sort
            }
          }
          sort = filter.sort
          if (!sort.fn) {
            if (!sort.type) sort.type = 'string'
            sort.fn = sortMakers[sort.type](sort)
          }
          subsObj.path(sort.field.split('.'), {}).set('_sort', true)
        }
        // console.log('building?!')
        if (filter.condition) {
          // console.log('found condition', filter.condition)
          var pcnt = 0
            , rcnt = 0
          var check = filter.check 
                 || ( filter.check = conditions( filter.condition
                                               , subsObj
                                               )
                    )
          filter.subsObj = subsObj
          val.each(function(f) {
            item = this
            if (itemsHandler) itemsHandler(item, subsObj, selection)
            if (check(item)) {
              pcnt++
              list.push(item)
            } else if (selection._has(item) !== void 0) {
              // console.log('-------- > removed from selection by condition:'
              //             , item.raw
              //             )
              unstoreIndex(item, selection)
              if(!noupdate){
                _update.call(selection, item, stamp, selection, item, false, null)
              }
              rcnt++
            } else { 
              rcnt++
            }
          })
          // console.log('ran condition: passed:', pcnt, 'rejects:', rcnt)
        } else {
          val.each(function() {
            if (itemsHandler) itemsHandler(this, subsObj, selection)
            list.push(this)
          })
        }

        filter.subsObj = subsObj

        if (sort && list.length > 1) {
          list.sort(filter.sort.fn)
        }

        var i, item

        var range = filter.range
        if (range) {
          if (!(range instanceof Array)) {
            range = filter.range = [0, filter.range]
          }
          if (list.length) {
            var newlist = list.splice(range[0], range[1])
            for (i = list.length; item = list[--i];) {
              if(selection._has(item) !== void 0){
                unstoreIndex(item, selection)
                // if(!noupdate){
                //   _update.call(selection, item, stamp, selection, item, false
                //               , null
                //               )
                // }
                
              }
            }
            list = newlist
          }
        }

        for (var i = list.length, item; item = list[--i];) {
          selection[i] = item
          var isnew = selection._has(item) === void 0
          storeIndex(item, selection, i)
          // if (isnew) {
          //   if(!noupdate){
          //     console.log('doing update wickeds')
          //     _update.call(selection, item, stamp, selection, false, item, null)  
          //   }
          // }
        }
        selection.length = list.length
      }
    , '_update', function(val, stamp, from, remove, added, oldval) {

        if (this._filter) {
           // if(window.here) console.log('hups _update on selection!')

          var selection = this
            , upath = selection.updatePath

          if (upath[0] !== void 0) {
            var shortpath = upath.length === 1
              , itemremove = shortpath && remove
              , item = itemremove ? selection._lfrom : selection.val[upath[0]]
              , relevant

            if (selection._val._filter) {
              if (selection._val._has(item) === void 0) {
                if (selection._has(item) !== void 0) {
                  selection._checkItem(item, false, val, stamp)
                }
                return
              }
            }
            var hint = itemremove ? false : (shortpath && added) ? void 0 : upath

            if (selection._checkItem(item, hint, val, stamp) === true) {
              _update.apply(selection, arguments)
            }
          } else {
            // console.log('hit on selection itself?!')
            if (!from) {
              // console.log('\n>>>>>> hit on selection itself (V.Data)')
              if (remove) {
                if (selection.length) selection._clear()              
              }else{
                selection._build()
              }
            }
            _update.apply(this, arguments)
          }
        } else {
           // if(window.here) console.log('hups _update on selection!',this)
           // console.log('SELECT', this, arguments, this._path)
          _update.apply(this, arguments)
        }
      }
    , '_has', function(item) {
        var indexCache = item._indexCache
          , uid = this._uid
          , ic

        if (indexCache && uid && (ic = indexCache[uid])) {
          return ic[0]
        }
      }
    , '_clear', function() {
        var self = this
        self.each(function(f) {
          self[f] = void 0
          delete self[f]
        })
        self.length = 0
      }
    , '_checkItem', function(item, hint, val, stamp) {
        if(!item) { return }
        // console.log('_checkItem!', item.raw, hint)
        var selection = this
          , from = item
          , filter = selection._filter
          , sort = filter.sort
          , range = filter.range
          , ranged = range && !(  range[0] === 0 
                               && range[1] >= selection._val.length 
                               || selection.length < range[1] - range[0]
                               )
          , removed = hint === false || item._removed
          , added, index, isin
          , result = isin = (index = selection._has(item)) !== void 0

        var check = filter.check
          , pass = removed 
                   ? false 
                   : (!ranged && hint === 1) 
                     ? isin 
                     : !check || check(item)

        // console.log('================ checkitem in', selection._path)             
        // console.log('isin', isin, 'pass', pass, 'result', result)
        // console.log('---------- checked item', pass)
        // console.log('removed?', removed)
        // console.log('ranged? (pass == already in)', (!ranged && hint === 1), isin)
        // console.log('ok time for checking', check)
        // console.log('conditions', filter.condition)
        // console.log('check?', check && check(item))
        // console.log('----------')
        
        if (isin !== pass) {
          if (isin) {
            result = 1
            unstoreIndex(item, selection)
            removed = item
            var mark
            while (mark = selection[++index]) {
              selection[index - 1] = mark
              storeIndex(mark, selection, index - 1)
            }

            var end = index - 1
            selection[end] = null
            delete selection[end]

            var replacement
            if (ranged) {
              if (sort) {
                selection._val.each(function() {
                  if (  selection._has(this) === void 0 
                     && (!selection[end] || sort.fn(this, selection[end]) < 0) 
                     && (!check || check(this))
                     ) {
                    replacement = selection[end] = this
                  }
                })
              } else {
                selection._val.each(function() {
                  if ( selection._has(this) === void 0 
                     && (!check || check(this))
                     ) {
                    return replacement = selection[end] = this
                  }
                })
              }
            }
            if (!replacement) {
              selection.length--
            } else {
              storeIndex(replacement, selection, index - 1)
              added = replacement
            }
          } else {
            var newindex
            if (sort) {
              var sortfn = sort.fn
              if (selection.length) {
                selection.each(function(f) {
                  if (sortfn(item, this) < 0) {
                    return newindex = f
                  }
                })
              }
              if (newindex !== void 0) {
                result = 1
                newindex = Number(newindex)
                storeIndex(item, selection, newindex)
                added = item
                if (ranged) {
                  removed = selection[selection.length - 1]
                  unstoreIndex(removed, selection)
                } else {
                  this.length++
                }
                var index = selection.length - 2
                while (index >= newindex) {
                  storeIndex(selection[index], selection, index + 1)
                  selection[index + 1] = selection[index--]
                }
                selection[newindex] = item
              } else if (!ranged) {
                result = 1
                newindex = selection.length++
                selection[newindex] = item
                storeIndex(item, selection, newindex)
                added = item
              }
            } else if (!ranged) {
              result = 1
              newindex = selection.length++
              selection[newindex] = item
              storeIndex(item, selection, newindex)
              added = item
            }
          }
        } else if (isin && sort) {
          // console.log('isin + sort! resort?')
          if (hint.length && sort.field) {
            if (~sort.field.indexOf('.')) {
              var sortpath = sort.field.split('.')
              if (!util.compareArrays(hint.slice(1), sortpath)) {
                return result
              }
            } else {
              if (hint[1] !== sort.field) return result
            }
          }

          var newindex
          selection.each(function(f) {
            if (f != index) {
              var s = sort.fn(item, this)
              if (s === -1) {
                if (f == index + 1) return true
                newindex = f < index ? f : f - 1
                return true
              } else if (f >= index + 1 && s === 0) {
                return true
              } else if (f > index) {
                newindex = f
              }
            }
          });
          // console.log('newindex', newindex)
          if (newindex !== void 0) {
            result = 1
            var tmp
            if (index > newindex) {
              while (index > newindex) {
                tmp = selection[index] = selection[--index]
                if (tmp) storeIndex(tmp, selection, index + 1)
              }
            } else {
              while (index < newindex) {
                tmp = selection[index] = selection[++index]
                if (tmp) storeIndex(tmp, selection, index - 1)
              }
            }
            selection[newindex] = item
          }

          var end = selection.length - 1

          if (  ranged 
             && (newindex == end || newindex === void 0 
             && index == end)
             ) {
            var replaced
            selection._val.each(function() {
              if (  selection._has(this) === void 0 
                 && sort.fn(this, item) === -1 
                 && (!check || check(this))
                 ) {
                if (!replaced) replaced = item
                selection[end] = item = this
              }
            })
            storeIndex(item, selection, end)
            if (replaced) {
              unstoreIndex(replaced, selection)
              removed = replaced
              added = item
              result = 1
            }
          } else if (newindex !== void 0) {
            storeIndex(item, selection, Number(newindex))
          }

        }
        if (result === 1) {
          // console.log('update from _checkItem!')
          selection.__update(val, stamp, from, removed, added)
        }
        return result
      }
    )

})

var storeIndex = exports.storeIndex = function(item, selection, index) {
  // console.log('storeIndex! item', item._name, '@', index)
  var indexCache = item._indexCache
    , ic
  if (indexCache) {
    ic = indexCache[selection._uid]
    if (ic) {
      ic[1] = ic[0]
      ic[0] = index
    } else {
      indexCache[selection._uid] = [index]
    }
  } else {
    item._indexCache = {}
    item._indexCache[selection._uid] = [index]
  }
}

var unstoreIndex = exports.unstoreIndex = function(item, selection) {
  var indexCache = item._indexCache
  if (indexCache) {
    var ic = indexCache[selection._uid]
    ic[1] = ic[0]
    ic[0] = void 0
  }
}

var sortMakers = {
  number: function(sort) {
    var field = sort.field
    return function(a, b) {
      var va = a[field] && a[field].val
        , vb = b[field] && b[field].val
      if (va === void 0 || vb === void 0) {
        return va === vb 
               ? 0 
               : va === void 0 
                 ? 1 
                 : -1
      }
      return sort.order 
             ? (va - vb) * -1 
             : va - vb
    }
  },
  string: function(sort) {
    var field = sort.field
    if (~field.indexOf('.')) {
      var path = field.split('.')
      return function(a, b) {
        a = getDotFieldVal(a, path)
        b = getDotFieldVal(b, path)
        if (a === void 0 || b === void 0) {
          return a === b 
                 ? 0 
                 : a === void 0 
                   ? 1 
                   : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    } else {
      return function(a, b) {
        a = getFieldVal(a, field)
        b = getFieldVal(b, field)
        var weakA = a === void 0 || a === null
          , weakB = b === void 0 || b === null
        if (weakA || weakB) {
          return a === b ? 0 : weakA ? 1 : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    }
  }
}

function getFieldVal(obj, field) {
  var v = obj.val
  return v && v[field] && v[field].val
}

function getDotFieldVal(obj, field) {
  var v = obj.path(field)
  return v && v.val
}

function putSort(path) {
  var obj = part = {}
  for (var i = 0, l = path.length; i < l; i++) {
    part = part[path[i]] = {
      _up: part
    }
  }
  part._sort = true
  return obj
}

},{"../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../util/hash":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/hash.js","./conditions":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/conditions.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js":[function(require,module,exports){
//V only used as a reference now...
},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/array.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  object = require('./');

util.define(object,
  /**
   * V.Object's equivalent to Array.push()
   * @method push
   * @param  {Arguments}  The item(s) to add to the array
   * @return {Number}     The new length of the array
   */
  'push', function() {
    if (this.__t === 1) {
      if (this.length === void 0) {
        this.length = 0;
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        this._push(arguments[i]);
      }
      return this.length;
    }
  },
  '_push', function(val, vobj, stamp, noupdate, from) {
    //ame, val, vobj, stamp, noupdate, from
    this.length++;
    this.set((this.length - 1), val, vobj, stamp, noupdate, from);
    return this[this.length - 1];
  },
  /**
   * V.Object's equivalent to Array.pop()
   * @method pop
   * @return {*}  The removed array item
   */
  'pop', function() {
    if (this.__t === 1) {
      var l = this.length
      if(l !== 0){
        t = this[l - 1];
        this.length--;
        t.remove();
      }
      // return t; //pretty weird since this object always has value null;
    }
  },
  /**
   * V.Object's equivalent to Array.splice()
   * @method splice
   * @param  {Number}    index   An integer that specifies at what position to add/remove items, Use negative values to specify the position from the end of the array
   * @param  {Number}    howmany The number of items to be removed. If set to 0, no items will be removed
   * @param  {Arguments}         The new item(s) to be added to the array
   * @return {Array}             A new array containing the removed items, if any
   */
  'splice', function(index, howmany) { //can become shorter;
    if (index > -1 && this.__t === 1) { //how many and -i are ignored
      for (var i = 0, l = this.length, shift; i < l; i++) {
        if (shift) {
          if (i === l - 1) {
            // this.length--;
            this[i] = null;
          } else {
            this[i] = this[i + 1];
            this[i]._name = i;
          }
        } else {
          if (i === index) {
            if (i === l - 1) {
              this.pop();
            } else {
              shift = true;
              this.length--;
              this[i].remove();
              this[i] = this[i + 1];
              this[i]._name = i;
            }
          }
        }
      }
    }
  },
  /**
   * Adds value to array if it is not contained in array, executes handler on encountering val in array
   * @method include
   * @param  {*}         val       Value to add
   * @param  {Function}  [handler] Function to execute on encountering val in array
   * @return {Boolean}             True/false
   */
  'include', function(val, handler, arr) {
    return util.include(this, val, handler, arr);
  },
  'concat', function(val) { 

    // if(!val) {
    //   return
    // }
    
    var arr = this
    var ll = arr.length;
    for (var i = 0, l = val.length; i < l; i++) {
      arr._push(val[i], false, false, true);
    }
    arr._update(val);
    return arr;
  },
  'moveItem', function(from, to) { var arr = this
    if(to === void 0) to = arr.length - 1
    if(from === to) return
    var mover = arr[from]
    if(!mover) return
    var step = from < to ? 1 : -1
    do {
      arr[from] = null
      arr.set(from, arr[from + step], true)
      from += step
    } while(from !== to)
    arr[to] = null
    arr.set(to, mover, true)
  }
)

},{"../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/compound.js":[function(require,module,exports){


var VObject = require('old-vigour-js/object').inject(
    require('old-vigour-js/value/length')
  ),
  util = require('old-vigour-js/util'),
  uid = require('old-vigour-js/util/id')

var SAMEPATH = 'could not create compound of two Objects with the same path'

// function Compound(val){
//   var compound = this
//   compound.$sources = new SourceList(compound, val)
//   this.__t = 2
// }

// var Data = require('old-vigour-js/data')

var Compound = VObject.new(void 0, function(val){
  var compound = this
  compound.$sources = new SourceList(compound, val)
  this.__t = 2
  return false
})
util.define(Compound, '_class', VObject)


module.exports = Compound
// Compound.prototype = new VObject()

Compound.prototype._blacklist.push(
  '$sources'
)

util.define( Compound,
  '_absorb', function _absorb(entry) {
    var compound = this
    var source = entry.source
    var prefix = entry.name
    
    var endpoint = source
    while(endpoint && endpoint.__t === 4 && !endpoint._filter) {
      endpoint = endpoint._val
    }
    entry.endpoint = endpoint
    
    if(endpoint) {
      endpoint.each(function absorbEach(){
        compound.set(prefix + '-' +this._name, this)
      })
    }

    compound.each(function cleanOld(){
      var pointer = this
      var pointed = pointer._val

      // skip cleanup check on construction
      if(!compound.$sources) {
        return
      }

      // TODO: find a better way to check if thing is still in an enpoint
      // get the endpoint the item should be in
      var sourcename = pointer._name.split('-')[0]
      var ep = compound.$sources[sourcename].endpoint
      var ok
      ep.each(function okCheck(){
        if(this === pointed) {
          return ok = true
        }
      })
      if(!ok) {
        pointer.remove()
      }
    })
  },
  '_addCompoundListener', function _addCompoundListener(entry) {
    var compound = this
    entry.source.on(function compoundListener(){
      // console.log('change in source, run absorb on', entry, 
      //   '\nval', arguments[0],
      //   '\nstamp', arguments[1]
      // )
      compound._absorb(entry)
    })
  }
)

function SourceList(compound, val) {
  var sourcelist = this
  sourcelist._parent = compound
  if(val){
    if(!(val instanceof Array)) {
      val = [val]
    }
    this.push.apply(this, val)
  }
}

SourceList.prototype.push = function pushSource(){
  var sourcelist = this
  var compound = sourcelist._parent

  // console.log('push dat sources', arguments.length)
  var al = arguments.length
  for(var i = 0, source; source = arguments[i] ; i++){

    var sourcename = uid()

    // console.log('SOURCENAME IS', sourcename)

    var entry = sourcelist[sourcename] = {
      name: sourcename,
      source: source
    }

    compound._absorb(entry)
    compound._addCompoundListener(entry)

  }
}




},{"old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/util/id":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/id.js","old-vigour-js/value/length":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/length.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/flags.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')

/**
 * Flags are special properties where a function is called
 * different from operators since flags may have nothing to do with value calculation
 * extends default set from V.Object
 * @property
 */
/**
 * Adds new flags to V.Object
 * @method extend
 * @param  {Object}   object V.Object to extend flags to
 * @param  {Function} [set]  [description]
 * @return {[type]}          [description]
 */
exports.extend = util.extend(function(object, set) {
  
  //multiple flags 
  
  // abstract flags array away!
  // 
  // flags object --> field
  // 
  // check /w cases
  // check /w parent
  // flag4 is dynamic has stack as option
  
  var _proto = object.prototype
    , _convert = _proto.convert
    , _set = _proto._set
    , _remove = _proto._remove
    , _check = function(name) {
      var f;
      for (var i in object.flags.dynamic) {
        f = object.flags.dynamic[i](name)
        if(f) break
      }
      return f
    }
    , checkIfFlagOverwrite = function(val) {
      for(var i in val) {
        if(object.flags[i] || _check(i)) return true
      }
    }

  if (!set) set = _proto.set

  _proto._blacklist.push('_flag');
  util.define(object,
    /**
     * [description]
     * @method convert
     * @param  {[type]} val [description]
     * @return {[type]}     [description]
     */
    'convert', function(val) {

      //hier ook weer for
      var obj = _convert.call(this, val);

      // console.log('I SHOULD BE CONVERTING!', val, obj, this._flag)





      if (this._flag && (!val || !util.isObj(val) || val.val || checkIfFlagOverwrite(val) )) {

        // console.log('I SHOULD BE CONVERTING! step 2')

        //ff useVal gebruiken

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (!flag[4] || !flag[4].stack) {

            // console.log('CONVERT NEEDS FIX'.red.bold.inverse)

            if (obj === flag[1]) {
              // console.log('2 CONVERT NEEDS FIX'.red.bold.inverse)
              obj = {};
            }
            if (obj.val === flag[1]) {
              // console.log('3 CONVERT NEEDS FIX'.red.bold.inverse)
              delete obj.val;
            }


            obj[flag[0]] = flag[2]
          }
          else {
            //still have to take care of this situation
            // console.error('trying convert a stack-dynamic flag', flag);
          }
        }

        // console.log('CONVERTED ---->',obj)

      }
      return obj;
    },
    /**
      @property __flags__
    */
    '__flags__', {},
    /**
     * [description]
     * @method remove
     * @param  {[type]} from   [description]
     * @param  {[type]} update [description]
     * @param  {[type]} stamp  [description]
     * @return {[type]}        [description]
     */
    '_remove', function(from, update, stamp) {

      if(this._flag) {
        for(var i in this._flag) {
          // console.log(i, this._flag)
          var flag = this._flag[i]
          //for 
          // console.log('_remove')
          if (flag) {
            //dit moet wel ff lukken
            if (object.flags[flag[0]]) {
              object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag);
            } else {
              flag[4].remove.call(this, flag);
            }
          }
        }
        this._flag = null
      }

      _remove.call(this, from, update, stamp);
    },
    /**
     * [description]
     * @method _set
     * @param  {[type]} val      [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} from     [description]
     * @param  {[type]} remove   [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    '_set', function(val, stamp, from, remove, noupdate) {
      // console.log('make _set',this._name,val);
      _set.call(this, val, stamp, from, remove, noupdate)

      //flag moet dus ook meer een copied value worden

      // console.log('_set', this._flag, val)


      if(this._flag) {

        // console.log('overwrite>?----', this._flag, val)

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (flag) {
            var setFl = object.flags[flag[0]] || flag[4]
            //what to do with reset?
            //change fixen bij cases?
            
            // console.log('2 overwrite>?----', flag, this._val, this._val !== flag[1])
            
            if (this._val !== flag[1] && setFl.useVal) {

              // nu ff hier ook nog!

              if (object.flags[flag[0]]) {

                // console.log('remove flag normal',flag, flag[4], i, this)

                object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag)
                //if this empty
                // delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
                // this._update()
              } else if (!flag[5]) {
                // console.log('remove flag /w flag[4] and not flag[5]',flag, flag[4], i)
                flag[4].remove.call(this, flag);
                // if(this.)
                //delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
              }
            } else if (object.flags[flag[0]] && object.flags[flag[0]].reset && flag[3] !== this) {
              // console.error('RESETTING -- ingnore /w a clear!',flag[0]) 
              object.flags[flag[0]].set.call(this, flag[2], stamp, true, this._name)
            }
          }
        }
      }

    },
    /**
     * [description]
     * @method set
     * @param  {[type]} name     [description]
     * @param  {[type]} val      [description]
     * @param  {[type]} vobj     [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    'set', function(name, val, vobj, stamp, noupdate) {
      var fl = object.flags[name] || _check(name)
        , r
        , same

        // console.log(name, val, vobj)

      if (fl) {

        // console.log('set>?----', name, val, this._flag)
       
      if(val===false) {
          //stack -- alle flags name providen!
          var i = fl.stack||name 
            , flag = this._flag && this._flag[i]
          if(flag && fl.remove) {
            var d = fl.remove.call(this, flag, name)
            // console.log('REMOVE FLAG FROM FALSE'.inverse, fl, name, val, stamp, this)
            if(!d) {
              delete this._flag[i]
              if(util.empty(this._flag)) {
                // console.log('flag is empty, delete')
                delete this._flag
              }
            }
          } 
          r = true
          // if(this._flag)
      } else {
       if(this._flag) {
          //check if need to remove! -- only in case
          for(var i in this._flag) {
            var flag = this._flag[i]
            if (flag && fl.remove) {

              if(!fl.stack && name === flag[0]) {
                // console.log('--->',flag[0])
                if(val!==flag[2]) {
                  // console.log('remove flag! ---> overwrite bymyself --->', flag[0],  setFl, 'by:' ,name, fl, val, flag[2])
                  fl.remove.call(this, flag);
                } else {
                  same = true
                }

              } else if (!fl.stack || fl.stack !== flag[0]) {

                //this._flag

                //if val:true 
                //go check if you need to remove mofos

                var setFl = object.flags[flag[0]] || flag[4]

                if(setFl.useVal && fl.useVal) {

                  // console.log('remove flag! -- clearly has some useVal', flag[0],  setFl, 'by:' ,name, fl)

                  setFl.remove.call(this, flag);
                  delete this._flag[i]
                  if(util.empty(this._flag)) {
                    // console.log('flag is empty, delete')
                    delete this._flag
                  }
                }


                // console.log('remove flag!', flag, flag[0], flag[4],  object.flags[flag[0]]  , fl, name) //check if it needs to be removed
                // var fl 
                
                //fl = object.flags[name] || _check(name)
                //
                //hier iets mee doen weer zoeken naar flag set


                //do the special check if value is tight to flag check (for both! fl.value)

                // fl.remove.call(this, flag);
              }
            }
          }
        }

      if(!same) {
          // console.log('SET FLAG'.inverse, name, val, stamp, this)
          fl.set.call(this, val, stamp, false, name);
          r = true //niet altijd waar ofcourse!
          // console.log('---------')
        } else {
          // console.log('FLAG IS SAME'.red.inverse, name, val, stamp, this)
        }
      }
        this[name] && this[name].remove(false, false, false, false, false, true);
      } else {
        r = set.call(this, name, val, vobj, stamp, noupdate);
      }
      return r;
    });
  object.flags = _proto.__flags__;
  util.define(object.flags, 'dynamic', {});
})
},{"../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/hashpath.js":[function(require,module,exports){
var util = require('../util')
  , hash = require('../util/hash')

exports.extend = util.extend(function(base) {
  base.prototype._blacklist.push('__hp')
  util.define( base
  , '_hashpath', {
      get: function() {
        return this.__hp || (this.__hp = hash(this._path.toString()))
      }
    }
  )
})
},{"../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../util/hash":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/hash.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')
  , vigour = require('../')
  , inject = require('../util/inject')
/**
 * V.Objects are used instead of normal objects in vigour listeners are automatically added and removed
 * type: __t : 1 = array , 2 = object , 3 = has field (can never be an array) , 4 = field ref to other V.Object
 * note you can make an object out of a field or field ref the type will be 3 or 4 though!
 * @constructor
 * @param  {*}      [val]    Value
 * @param  {Object} [parent] Parentobject
 */
var object = module.exports = exports = vigour.Object = function(val, hook, parent) {
  if (parent) this._parent = parent
  if (hook && this._hook) this._hook(val, hook)
  if (val !== void 0) this.val = val
}
object.inject = inject
/**
 * Used to set .val
 * @method _set
 * @param  {*}              val                  [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Object|Boolean} [from]               [description]
 * @param  {Boolean}        [noupdate]           When true, no updates
 * @param  {Boolean}        [add]                When true, this is an add
 */
var _set = function(val, stamp, from, noupdate, add) {

  if(val===null) {
    if (!stamp) stamp = this.stamp()
    this.remove(false, false, false, from, stamp, noupdate)
  }

  if (!this.__t || this.__t < 3 || ( val !== this._val || this._ignoreValue ) ) {

    // console.error(this)
    if(!this.stamp) {
      //moet allemaal event emitters worden (on('error'))
      //this._update('error') en anders V.debug.error._update( 'object' )
      console.error( 'ERROR in vigour-js/object,  OBJECT no .stamp', this )
      return
    }

    if (!stamp) stamp = this.stamp()

    var oldval = this._val
      , nestedval
      , noset
      , isSet
      , isArray
      , valIsSet

    if (this._changevobj 
      && ((this.__t < 4 && val instanceof object) 
      || this.__t === 4 && ((!this._mixed||this._mixed===4) || val instanceof Array 
        || (val instanceof Object 
          && (val instanceof object || val.val))))) { //try to make this shorter
         this._changevobj(val, stamp)
         if(this._mixed===4) this._val = null
    }

    if (vigour.Base && (val instanceof vigour.Base)) {
      this.remove(true, true, false, false, stamp)
      this.__t = 5
      this._val = val
    } else if (val instanceof object) {
      if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
        this.remove(true, true, false, void 0, stamp) //check if 2nd param true is absolutely nessecary (else it will be removed)
      }
      this._val = val
      this.__t = 4
      if (this._setvobj) this._setvobj(val)
    } else {

      if (val instanceof Object && typeof val !== 'function') {
        if (val instanceof Array) {
          this._val = void 0
          this.__t = 1
          this.length = val.length
          noset = this.remove(true, true, val, false, stamp)
          for (var i = 0, l = this.length; i < l; i++) {
            if (!this.set(i, val[i], false, stamp, noupdate, true) && noset !== false) {
              noset = true
            } else {
              noset = false
            }
          }
        } else {

          //normal object

          if (val.clear) {
            noset = this.remove(true, true, false, false, stamp)
            delete val.clear
          } else {

            if (this.__t === 1) {
              if (this._mixed !== 1 && this._mixed!==4) {
                this.remove(true, true, false, false, stamp) //ommiting stamp can be a problem
              } else {
                isArray = true
              }
            } else if (!this._merge && (!this._mixed || this.__t === 2)) {
              noset = this.remove(true, true, val, false, stamp)
            }
          }
          if (val.val && util.isObj(val.val)) {
            valIsSet = true
            this._$setVal( new this._class(val.val, false, this), stamp, from, true)
            this._val._contained = true
          } else if (!this._mixed) {
            this._val = void 0 //this messes up property updates!! (youri)
          }

          if (!isArray) this.__t = 2

          for (var j in val) {
            if (!util.checkArray(this._blacklist, j)) {
              if (j === 'val') {
                if(!valIsSet) isSet = this._$setVal( val.val, stamp, from, true )
                nestedval = true;
              } else {
                //do not always ignore updates at this point
                if (!this.set(j, val[j], false, stamp, noupdate, true) && noset !== false) {
                  noset = true
                } else {
                  noset = false //this is the place where set is passed
                }
              }
            }
          }
        }

      } else {
        if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
          this.remove(true, true, false, false, stamp)
          if (this.__t === 1) delete this.length
        }
        if (val === this._val && !this._ignoreValue ) {
          //maybe use stamp for ignoreValue as well?
          if (noset !== false) {
            this.__t = 3
            return false
          }
        } else {
          this._val = val
          this.__t = 3
        }
      }
    }
    if (nestedval) {

      if (this._set && (isSet !== false || noset === false)) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      }
    } else if (this._set) {
      if (!noset) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      } else {
                    // if(window.smut) console.log('!1',arguments)

        return false;
      }
    }
  } else {
                        // if(window.smut) console.log('!1',arguments)

    return false;
  }

},
/**
 * stamp
 * paint the set origin
 * @method
 */
_stamp = 0,
_params = function(params, list) {
  for (var i = list.length - 1, p; i >= 0; i--) {
    if (params && params[list[i]]!==void 0) {
      p = '_' + list[i]
      util.define(this, p, params[list[i]])
    }
  }
}
/**
* Generates unique stamp
* @method stamp
* @return {Number} Returns stamp
*/
exports.stamp = function() {
//if stamp > x reset ?
return _stamp++
}

exports.set = _set

// objectUtils.extend(exports);  
/**
 * Creates a new constructor based on a V.Object
 * Params can be passed
 * Mixed creates mixed types for the new class i.e having a string and properties
 * @method new
 * @param  {Object} params Parametersobject
 * @return {Object}        Returns V.Object
 */
// window.cnt = 0
// setTimeout(function() {
//   window.smut = true
// },2000)

object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      var conresult
      if (constructor) {
        conresult = constructor.apply(this,arguments)
      }
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)

      if(val !== void 0 && conresult !== false) {
        this.val = val
      }
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  vObj.inject = inject //not handeled well yet
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

util.define(object,

// '_set, set , '

 '_$setVal', _set,

/**
 * Items in the blacklist skipped in each function
 * @method _blacklist
 */
'_blacklist', ['_', '__', '__t', '_val', 'length', '_name', '_parent', '_contained', '_removed','extensions', '__cachedPath', '_ignoreValue', '_indexCache'],
/**
 * Replaces default constructor property ,necessary for classes made with V.Object.new
 * @constructor _class
 */
'_class', object,
/**
 * Stamp is a method of VObject so that it can be extended in subclasses
 * @return {*} a unique identifier for a mutation
 */
'stamp', object.stamp,
/**
 * Used to get .val which returns field values i.e. a string
 * @method _get
 * @return {*} Returns value
 */
'_get', function() {
  var self = this
    , type = self.__t
    , val

  if (type < 3) {
    return self
  } else {
    val = self._val
    return (type !== 4) ? val : val && val._get()
  }
},
/**
 * Used to get .val which returns field values i.e. a string
 * Set creates instances of the _class for nested properties
 * @property
 */
'val', {
  set: function(val) {
    // window.cnt++
    // if(window.smut) {
      // console.error(window.cnt, 'whats happening', this._path, this._prop && this._prop.name, this, this._updateOrigin)
    // }
    return this._$setVal(val)
  },
  get: function() {
    return this._get()
  }
},
/**
 * Add a property to a object
 * @method set
 * @param  {String}  name                [description]
 * @param  {*}       val                 [description]
 * @param  {Boolean} [vobj]              [description]
 * @param  {Number}  [stamp = new stamp] [description]
 * @param  {Boolean} [noupdate]          [description]
 * @return {Boolean}                     [description]
 */
'set', function( name, val, vobj, stamp, noupdate, from ) {

  //function( name, val, vobj, stamp, noupdate, from ) 

  // console.log(name, stamp)

  from = from && this
  if (!vobj && (this[name] instanceof object)) {
    if (this._$setVal.call(this[name], val, stamp, from, noupdate) === false && stamp) {
      return false
    }
  } else {
    if (vobj) {
      if(this[name]) this[name].remove()
      this[name] = val
      this[name]._name = name
      this[name]._parent = this
      if(!noupdate) val._update(val, stamp || this.stamp(), from, void 0, true)
    } else {
      this[name] = new this._class(void 0, false, this)
      this[name]._name = name
      this._$setVal.call(this[name], val, stamp, from, noupdate, true)
    }
    if (this.__t === 1 && this._setArrayItem) {
      this._setArrayItem( this[name], val )
    }
  }
  return true
},
/**
 * Removes a V.Object including all nested fields and values
 * @method remove
 * @param  {Boolean}        [nested]             When true remove nested objects
 * @param  {Boolean}        [bl]                 When true doesn't remove blacklisted items
 * @param  {Boolean}        [not]                [description]
 * @param  {Boolean|Object} [from]               [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Boolean}        [noupdate]           [description]
 * @return {Boolean}                             [description]
 */
 //    this.remove(false, false, false, from, stamp, noupdate)

'remove', function(nested, bl, not, from, stamp, noupdate) { //no update first > (extended in selection.js)
  if (!nested) this._removed = true
  var r, i, oldval
  if (!stamp) stamp = this.stamp()
  // console.log('START',stamp,this._name);
  if (!nested) {
    if (this._parent) {
      this._parent[this._name] = null
      delete this._parent[this._name]
    }
    if (this._val !== void 0) {
      if (this._val instanceof object && this._val._contained) {
        this._val.remove(false, false, false, from || this, stamp, noupdate)
      }
      oldval = this._val
      this._val = null
    }
  }
  for (i in this) {
    if ((!not || !not[i]) && !util.checkArray(this._blacklist, i)) {
      if (this[i] instanceof object) {
        r = false
        // console.log('DELETE',stamp,i,this[i]);
        this[i].remove(false, false, false, from || this, stamp, noupdate)
      }
      this[i] = null
      delete this[i] //delete is pretty nasty for performance
    }
  }
  if (!nested) {
    if (this._remove) {
      //r
      this._remove(from, noupdate ? false : from /*||r*/ , stamp, oldval);
      if (!bl) {
        for (var j in this) {
          if (this[j] !== void 0) {
            if (j !== '_parent' && this[j] instanceof object && this[j]._contained) {
              this[j].remove()
            }
            this[j] = null
            delete this[j]
          }
        }
      }
    }
    this._removed = true
  }
  return r
})


//----this has to be initialized after defining the blacklist property;
exports.listen = require('./listen')
require('./array')
require('./util')
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../util/inject":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/inject.js","./array":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/array.js","./listen":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/listen.js","./util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/util.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/listen.js":[function(require,module,exports){
var util = require('../util')
  , vObject = require('./')
  , V = require('../')
  //TODO: this is a temp fix to emulate on next tick
  , raf = require('old-vigour-js/browser/animation/raf')
  , Promise = require('promise')

function _addListener( obj, fn, mark, original ) {
  //val, mark, skipcheck, ignoreval, orginal
  if( mark ) 
  {
    // console.log('hey got orginal!', original)
    //n( val, mark, skipcheck, ignoreval, original )
    obj.addListener([ fn, mark ], true, false, false, original  )
  } 
  else 
  {
        // console.log('hey got orginal!', original)

    obj.addListener( fn, false, false, false, original )
  }
}

/*
  _update calls listeners on a given Object (listeners include linking fields in other V.Objects)
  V.Object._update can be modified to change update behavior:
    - standard: update Object and it's parents / ancestors recursively.
    - parentOnly: update Object and only its direct parent.
    - just _update: update only the Object.
*/
var _update = exports._update = function(val, stamp, from, remove, added, oldval, test) {

  // if(window.here) console.log('UPDATE!',this._path)

  var _l = this._listeners
    , i
    , listener

  if (_l) {
    for (i = _l.length; listener = _l[--i];) { //order is irrelevant
      if (listener instanceof vObject) {

        // console.log('update?????', listener._path, this._path, from)

        // if (from) {
        listener._lfrom = from || this
          // }

        listener._update(val, stamp, false, remove, added, oldval)

        if (listener) listener._lfrom = null

      } else if (listener[0]) {
        if(!test || !test(listener)) {
          if (listener.length > 2) {
            for (var l = listener.length - 2
              , l2 = arguments.length
              , a = [], j = -1
              , la = l + l2
              ; j < la
              ; a[++j] = j < l
                ? listener[j + 2]
                : j === l ? this : arguments[j - l - 1]
              );

            listener[0].apply(listener[1], a)
          } else {
            listener[0].call(listener[1], this, val, stamp, from, remove, added, oldval)
          }
        }
      } else {
        listener.call(this, val, stamp, from, remove, added, oldval)
      }
    }
  }
}


// util.define(vObject, 
//   '_nodePath_', function() {
//     if(this._caller) {

//       var arr = []
//       var p = this._caller

//       while(p) {
//         arr.push( p._name || p._node && p._node.className )
//         p = p._node && p.parent
//       }
//       arr.reverse()
//       return arr


//     }
//   }

// )


vObject.prototype._blacklist.push('_listeners', '_listens', '_lfrom', '_listenMap');

util.define(vObject,
  /**
   * _set
   * is called when a value is set
   * @method
   */
  '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
    if (!noupdate) {
      // console.log(this._path, val)
      this._update(val, stamp, from, remove, added, oldval);
    }
  },

  'is', function (val, cb, nextTick ) {

    //on removal of promise remove listener

    if(!cb || ( typeof cb !== 'function')) {
      var _this = this
      nextTick = cb
      return new Promise(function( resolve, reject ) {
        // console.log('312123123213', val)
        _this.is( val, function() {
          resolve.apply(this, arguments)
        })
      })
    } else {
      var cbx = nextTick ? function() {
        var args = util.arg(arguments)
          , _this = this
        raf(function() {
          cb.call(_this)
        })
      } : cb
      //TODO: add original if its not 
          // console.error('--------------', val)

      if(val==='loaded') {
        if(this.$loaded || this.from.$loaded) {
          cbx.call(this)
        } else {
          this.once('loaded', cbx)
        }
      } else {
        var ret
        // var ignore
        // console.error('1!@#@#!!@#', ret, val)

        if(this.val == val ) {
          // console.error('2!@#@#!!@#', ret, val)

          return cbx.call(this)
        } else {
          // console.error('!@#xxxxx12121212122112@#!!@#', ret, val)

          ret = (typeof val === 'function') && val.call(this)
          // ignore = true
          // console.error('2222222222!@#@#!!@#', ret, val)
        }
        if(ret) {
          if( ret instanceof Promise ) {
            // console.error('promise')
            return ret
          } else {
            // console.log('????!!!')
            return cbx.call(this)
          }
        } else {
          // console.error('22222!@!@#!@#', val)
          if(typeof val === 'function') {
            this.once(val, cbx)
         } else {
            this.once({
              $val: val
            }, cbx)
         }
        }
      }
      return this
    }
  },
  /**
   * __update
   * calls listeners attached to the Object
   * types -- function or V.Object
   * @method
   */
  '__update', _update,
  /**
   * _update
   * escalates an update up it's structure and calls __update to call listeners
   * types -- function or V.Object
   * @method
   */
  '_update', function(val, stamp, from, remove, added, oldval, test) { //here you can see if its an update from another object (from)
    // console.log('V.Object OG _update', val, stamp, from, remove, added, oldval)
    var curr = this,
    s = true

    while (curr) {
      // var p = curr._path
      // _update ["clients", "V_2pxcewv3g4k"] 
      // console.log('_update', p, val, from || ((!s && this) ? this : void 0, this) )

      //TODO 10 double check this
      curr.__update(val, stamp, from || (s!==true) ? this : false , remove, added, oldval, test)
      curr = from ? false : curr._parent
      s = false
      if (remove) remove = 1
    }
  },
  /**
   * _remove
   * called on remove
   * @method
   */
  '_remove', function(from, update, stamp, oldval) {
    if (update !== false) {
      this._update(null, stamp, from, true, false, oldval);
    }
    this.removeListener();
    var _l = this._listens,
      i, listener;
    if (_l) {
      //optimize later
      //this,this is weird to always use this...
      for (i = _l.length - 1; i >= 0; _l[i--].removeListener(this, void 0, false, true));
    }
  },
  /**
   * _setvobj
   * if a value is set to a V.Object
   * @method
   */
  '_setvobj', function(val) {
    val.addListener(this);
  },
  /**
   * _changevobj
   * if a value is changed from a V.Object
   * @method
   */
  '_changevobj', function(val) {
    if (this.__t === 4) {
      var _l = this._listens,
        _val = this._val,
        i;
      if (_l) {
        for (i = _l.length; i >= 0; _l[--i] && _l[i].removeListener(this, this));
      }
      if (_val instanceof vObject && _val._contained) {
        _val.remove();
      }
    }
  },
  /**
   * addListener
   * adds a listener to an object can be a function or V.Object
   * @method
   */
  'addListener', function( val, mark, skipcheck, ignoreval, original ) {
    var _l = this._listeners || (this._listeners = []),
      target, g;

    if(original) {
      // console.log('ORGINAL!', original)
      if(!this._listenMap) {
        this._listenMap = []
      }
    }

    //more speed voor checkarray
    if (mark) {
      g = util.checkArray(_l, val[1], 1);
      if (g === false
        || !ignoreval && util.checkArray(_l, val[0], 0) === false
        || (mark !== true && mark.call(this, _l[g], _l, g, val) === true)) {
        
        //TODO: fix this ultra dirty stuff
        if( original && val !== orginal ) {
          this._listenMap.push([ orginal, val ])
        }

        _l.push(val);
      } else  {
         return _l[g];
      }
    } else if (!val.__t || !util.checkArray(_l, val)) {

      if( original && val !== original ) {
        this._listenMap.push([ original, val ])
      }

      _l.push(val);
    }
    if (mark || val instanceof vObject) {
      target = mark ? val[1] : val;
      if (target instanceof vObject) {
        _li = target._listens || (target._listens = []);
        if (skipcheck || !util.checkArray(_li, this)) {

          if( original && val !== original ) {
            this._listenMap.push([ original, val ])
          }

          _li.push(this);
        }
      }
    }
  },
   'once', function( val, method, mark ) {

    //val, mark, skipcheck, ignoreval, orginal

    //TODO:unify /w on
    var mval

    var listen = function() {
      
      this.removeListener( mval, mark )
      // this.removeListener( listen )

      mval.apply( this, arguments )
      //original perhaps????
    }

    if( method ) {
      mval = method
      this.on( val, listen, false, mval ) //deze fn moet wel geremoved worden gebeurd nu niet!
    } else {
      mval = val
      this.on( listen, false, false, mval )
    }

    return this

  },
  'on', function( val, method, mark, original ) {
      /**
        * val can be a condition or a comparison or a method
      **/
      if( V.Base && method instanceof V.Base ) 
      {
        mark = method //make exception for values!
        method = null
      }

      if(!original) {
        original = method
      } else {
        // console.log('set original!', original, method )
      }

      if( !method ) 
      {
        _addListener( this, val, mark, original )
      }
      else 
      {
        if( util.isObj( val ) )
        {
          // console.warn('this will become a condition later on for now its not supported!, conditions will be used eveyrwhere')
          //Has to become a condition
          if(val.$val) {
            _addListener( this, function( nval ) {
              if( this.val === val.$val ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          } else {
            console.warn('this will become a condition later on for now its not supported!, conditions will be used eveyrwhere')
          }
          //Has to become a condition


        }
        else if( typeof val === 'function' )
        {
          _addListener( this, function( nval ) {
            if( val.apply( this, arguments ) ) //more checks
            {
              method.apply( this, arguments )
            }
          }, mark, original )
        }
        else 
        {

          if( util.isObj( method ) )
          {

            mark = val

            console.warn('untested -- add as mark')
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )


          }
          else if( val === 'remove' )
          {
            //val, stamp, false, remove, added, oldval
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          //TODO: in redo this will be done differently (event types are special done)
          else if( val === 'loaded' ) {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;
              //__frommethod

              if( this.$loaded || this.from.$loaded ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'added' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;
              if( added ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'self' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;

              //TODO: put on in a different file
              // console.log('SHOULD DO SELF!', arguments, from ) //zo wrong!

              if( this._val === nval 
              || !val && this._updateOrigin===this //pretty slow check , its there to check when someone call .update for example
              ) 
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else
          {
            _addListener( this, function( nval ) {
              if( nval === val || this.val === val || this._val === val ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
        }
      }
      return this
    },

  /**
   * removeListener
   * if no val removes all listeners
   * mark checks in array on position 1 for uniqueness
   * remove is used in combination with mark
   * @method
   */
  'removeListener', function(val, mark, remove, nobreak) {
    // console.log('removeListener!', this._path, this._listeners && this._listeners.length
    //   , '\nmark:\n', mark && mark.raw
    //   , '\nval:\n', val && val.name
    //   , '\nval:\n', val
    // )
    var _l = this._listeners,
      i;
    if (_l) {
      for (i = _l.length - 1; i >= 0; i--) {
        //maybe checking mark all the time is too slow?
        var listener = _l[i]
        if (
          (!mark && !val)
          || (val && listener === val) //false voor mark
          || (mark!==false && ((listener instanceof Array) && ((mark && listener[1] === mark && (!val||listener[0]===val)) || val && listener[1] === val))
            && (!remove
              || (remove === true  //dit moet later weg is dan alleen een functie is nu overbodig (check boven)
                ? listener[0] === val
                : remove.call(this, listener, mark))))
        ) {
          // console.log('mark._listens?', !!(mark && mark._listens)
          //     , '\nis vObject?', listener instanceof vObject
          //     , '\nis marked?', listener instanceof Array
          //   )
          var focus = mark
            ? mark
            : listener instanceof vObject
              ? listener
              : listener instanceof Array
                ? listener[1]
                : false
          var listens = focus && focus._listens
          if(listens){
            for(var j = listens.length-1 ; j >= 0 ; j--){
              if(listens[j] === this){
                listens.splice(j, 1)
                if(listens.length === 0)
                  focus._listens = null
                if(focus.__t === 4 && listener._val === this)
                  listener._val = void 0
                break
              }
            }
          }
          _l.splice(i, 1)
          if (_l.length === 0) this._listeners = null;
          if (val && !nobreak) break
        }
      }

      //TODO: this has to be refactored ASAP! do when new design phase for vobject+base is going down
      if( this._listenMap && val ) {
        // console.log('im here!', val)
        var piv
        for(var i = 0, _len = this._listenMap.length; i < _len; i++ ) {
          if( this._listenMap[i][0] === val ) {
             // console.log('hey its the listenmap!', val)
             this.removeListener( this._listenMap[i][1] )
             piv = i
             break;
          }
        }
        if( piv !== void 0 ) {
          this._listenMap.splice(piv, 1)
          if(this._listenMap.length === 0) {
            this._listenMap = false
          }
        }
      }

    }
  });
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/browser/animation/raf":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/animation/raf.js","promise":"/Users/youzi/dev/mtv-play/node_modules/promise/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  VObject = require('./'),
  V = require('../')
  _c = util.checkArray

/**
 * Gets/sets VObject origin
 * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
 * @method from
 * @param  {Object} obj [description]
 * @return {Object}     [description]
 */
var _coreSet = VObject.set,
  _from = this.from = function(obj) {
    var val = obj,
      last;

    while (val instanceof VObject) {
      // console.log(val)
      if(val._filter) {
        // console.error('IS SELECITON', val)
      }
      last = val;
      val = val._val;
    }
    return last !== obj ? last : false;
  },
  _lastLFrom = function(obj) {
    while (obj && obj.__t === 4) {
      if (obj._lfrom) {
        return obj._lfrom;
      } else {
        obj = obj._val;
      }
    }
  },
  /**
   * Returns path
   * @method _updatePath
   * @param  {Object}    till [description]
   * @return {Object}         Returns path
   */
  _updatePath = function(till, start) {
    var parent = this,
      lfrom,
      path = []; //reduce amount of new arrays
    while (parent && (parent._name !== void 0 || start)) {
      lfrom = parent._lfrom || _lastLFrom(parent)
      if (lfrom) {
        var a = _updatePath.call(lfrom),
          c = parent.from._name;
        util.add(a, path);
        path = a;
        if (c) {
          c = a.indexOf(c);
          a.splice(c, a.length - c);
        }
      }
      if (parent !== till) {
        path.push(parent._name);
        parent = parent._parent;
      } else {
        parent = false;
      }
    }
    // console.log('----->',path)
    return till ? path.reverse() : path;
  }

util.define(VObject,
  /**
   * Removes all linked containers, uses slice on arrays
   * Removes all _listeners
   * @method destroy
   */
   'toString', function( compressed ) {
      return compressed 
             ? JSON.stringify( this.raw ) 
             : JSON.stringify( this.raw, false, 2 )
   },
   'referenceLevel', function(linked) {
      var link = this
      var cnt = 0

      // console.log(link, link.__t)

      while(link && link.__t) {
        if(link===linked) {
          return cnt
        }
        link = link._val
        cnt++
      }
      return false
   },
  'destroy', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    this._removed = true
    this.destroyReferences(nested, bl, not, from, stamp, noupdate)
    this.remove(nested, bl, not, from, stamp, noupdate)
  },
  'destroyReferences', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    var _l = this._listeners
      , parent
      // , item
    if (_l) {
      for (var i = _l.length, ref; ref = _l[--i];) {
        // if(listener instanceof Array){
        //   if(listener)
        // }
        // ref =  instanceof Array ? _l[i][1] : _l[i];
        if (ref instanceof VObject) {
          parent = ref._parent;
          if (parent && parent.__t === 1) {
            parent.splice(ref._name, 1);
          } else {
            ref.remove(nested, bl, not, from, stamp, noupdate);
          }
        }
      }
    }
  },
  /**
   * Performs passed function on each item.
   * Skips items in the blacklist.
   * @method
   * @param  {Function}  fn   function to perform on each
   * @param  {Boolean}   deep If true, repeats eachmethod on nested fields
   * @param  {Arguments} arg  Arguments to pass to the function
   * @return {Boolean}        [description]
   */
  'each', function(fn, deep, arg) {
    //try to make this a lot shorter
    var i, item;
    if (arg !== void 0) {
      arg = util.arg(arguments, 2);
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.apply(item, arg)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each.apply(item, arg)) {
              return true;
            }
          }
        }
      }
    } else {
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.call(item, i)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each(fn, deep, arg)) {
              return true;
            }
          }
        }
      }
    }
  },
  /**
   * Returns the real path
   * @attribute _path
   */
    '_path', {
      get: function() {
        var parent = this
          , path = []

        while (parent && parent._name !== void 0) {
          path.push(parent._name);
          parent = parent._parent;
        }

        return path.reverse();
      }
    },
    '_cachedPath', {
      get: function() {
        return this.__cachedPath || (this.__cachedPath = this._path.join('.'))
      }
    },
  /**
   * Returns the update path
   * @attribute updatePath
   */
  'updatePath', {
    get: function() {
      var a = _updatePath.call(this, this, true),
        name = this._name;
      name !== void 0 && a.unshift(name);
      return a;
    }
  },
  /**
   * Returns the keys of an object
   * @attribute keys
   */
  'keys', {
    get: function() {
      var i, arr = [];
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          arr.push(i);
        }
      }
      return arr;
    }
  },
  /**
   * Returns true if object is Ancestor
   * also return true when object is object to be compared to
   * @attribute keys
   */
  //t._d === from._parent || t._d === from
  '_ancestor', function(obj) {
    // console.log('ANCESTOR'.red.inverse, obj, this)
    var p = this
    while (p) {
      if (obj === p) return true
      p = p._parent
    }
  },
  /**
   * Get a field at first occurence in the parent chain
   * @method checkParent
   * @param  {String}  field [description]
   * @param  {Boolean} get   When true returns found instead of current
   * @return {Object}        [description]
   */
  'checkParent', util.checkParentFactory('_parent'),
  /**
   * Returns a normal object, and keeps links to V.Objects
   * @method
   * @param  {*}      [val] [description]
   * @return {Object}       [description]
   */
  'convert', function(val) {
    var obj = {}, l = 0
    if (!val || val.val) obj.val = this._val
    if (this.__t === 1) {
      obj = []
      for (var i = 0; i < this.length; i++) {
        l++
        obj[i] = this[i].convert()
      }
    } else {
      this.each(function(i) {
        if (!val || val[i]!==void 0) {
          l++
          obj[i] = this.convert()
        }
      })
    }
    if (val) {
      for (var i in val) {
        if (obj[i] === void 0) obj[i] = void 0
        l++
      }
    }
    if (!l && (!val || val.val)) obj = obj.val
    return obj
  },
  /**
   * Returns a normal object
   * @attribute raw
   */
  'raw', {
    get: function() {
      var self = this,
        type = self._filter ? 2 : self.__t,
        obj, i, l;
      if (type === 4) {
        return self._val && self._val.raw;
      } else if (type === 3) {
        return self.val; //when the type is mixed always uses val
      } else {
        if (type === 1) {
          obj = [];
          for (i = -1, l = self.length - 1; i < l; self[++i] && obj.push(self[i].raw));
        } else {
          obj = {};
          for (i in self) {
            if (!_c(self._blacklist, i) && self[i]) {
              obj[i] = self[i].raw;
            }
          }
        }
        return obj;
      }
    }
  },
  /**
   * Gets/sets object origin
   * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
   * @attribute from
   */
  'from', {
    set: function(val) {
      var found = _from(this)
      _coreSet.call(found || this, val)
    },
    get: function() {
      return _from(this) || this
    }
  },
  /**
   * Merge any object into another object
   * Shallow for a shallow merge
   * @method merge
   * @param  {Object}  obj      [description]
   * @param  {Boolean} shallow  [description]
   * @param  {Number}  stamp    [description]
   * @param  {Boolean} noupdate [description]
   * @return {Object}           [description]
   */
  'merge', function merge( obj, shallow, stamp, noupdate, block, sorted, deferUpdates ) {

    // console.log('MERGE---->', obj )

    var mergeArray = this._mergeArray
      , r
      , i
      , stop
      , rt
      , cobj
      , tobj
      , topLevel

    if(!deferUpdates) {
      // console.log('NO deferUpdates'.yellow.inverse)
      topLevel = true
      deferUpdates = []
    }
    //FIXME: make it better long names etc, code formatting

    if ( !stamp ) stamp = this.stamp()

    if ( this.__t === 1 ) {
      if (mergeArray) {
        mergeArray( obj, stamp, noupdate ) //hier moet ook ff deferUpdates
      } else {
        for (var j in obj) {
          cobj = obj[j]
          tobj = this[j]
          if ((j = Number(j)) > -1) {
            r = true
            if (tobj) {
              tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
            } else {
              if (j > this.length - 1) this.length = j + 1
              this.set(j, cobj, false, stamp, true, true)
            }
          }
        }
      }
    } else {
      for (i in obj) {
        stop = true
        cobj = obj[i]
        tobj = this[i]
        if (i !== 'val' && !_c(this._blacklist, i)) {
          if (!shallow && tobj && util.isObj(cobj)) { //cobj instanceof Object && (typeof cobj !== 'function') && cobj.__t !== 3)
            if (cobj.clear) {
              _coreSet.call(tobj, cobj, stamp, false, true)
              r = true
            } else {

              // console.error('---- merge /w update thats mos def wrong!', i, deferUpdates)
              //deferUpdates

              rt = tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
              if (r !== true) r = rt

              if (!rt) 
              {
                // console.log('0000')
                obj[i] = void 0
              }
            }
          } else {

            if (tobj && tobj._val === cobj) { //changed to differentiate between 0 and false, now also differentiates between 1 and '1'
                // console.log('---- 2 update thats mos def wrong!', i)

              if (r !== true) r = false
              // console.log('???????')
              obj[i] = void 0
            } else {
              // console.log('---- 3 update thats mos def wrong!', i)
              if(cobj===null && this[i]) {
                this[i].remove( false, false, false, void 0, stamp )
              } else {
                // console.log('!?'.bold, i, this[i])
                //name, val, vobj, stamp, noupdate, from
                this.set( i, cobj, false, stamp, true )
                // console.log('!xxxx?', i)
                if(this[i] && this[i]._listeners) {
                  // console.log('push push'.green,  JSON.stringify(obj) )
                  deferUpdates.push( [this[i], cobj] )
                }
                //add dit naar list
              }
              if (!r) r = rt;

              // console.warn(r, rt)

              if (!rt) 
              {
                //TODO: TEMP FIX DONT KNOW IF THIS WORKS!
                // console.log('???????22222')
                // obj[i] = void 0
                // console.warn('cant be right!')
                //SUPER CAREFULL WITH THIS R THING!!!!!
                r = true
              }
            }
          }
        }
      }
      if (obj.val) {
        rt = _coreSet.call(this, obj.val, stamp, false, true)
        if (!r) {
          r = rt
        }
        if (!rt) {
          obj.val = void 0
        }
      } else if (!stop) {
        if (!r) {
          r = false;
        }
      }
      r = (r !== false) || r
    }

    if (r) {
      if (!block) {
        // alert(noupdate)
        if (noupdate) {

          // console.log('!!??????????? NOUPDATE'.blue, JSON.stringify(obj))

          if(topLevel) {
            // console.log('UPDATE>?'.magenta.inverse, obj, JSON.stringify( obj ), noupdate, stamp)
            this._update(obj, stamp)
          }
          else {
            this.__update(obj, stamp)
            deferUpdates.push([ this, obj ])
          }
        } else {
          
          // console.log('2UPDATE>?'.cyan.inverse, topLevel, deferUpdates, obj, noupdate, stamp)

          this._update( obj, stamp )
        }
      }
    }
   

    if(topLevel && deferUpdates) {
      // console.log( 'defered updace', topLevel, deferUpdates)
      for(var df in deferUpdates) {
        if( deferUpdates[df][0] && deferUpdates[df][0].__update ) {
          // console.log('DEFERED!!!!'.cyan.inverse, df, deferUpdates[df][1], stamp )
          deferUpdates[df][0].__update( deferUpdates[df][1], stamp )
        }
      }
    }
    return r
  },
  /**
   * Copies an object and returns a new one, can also pass a merge object
   * @method
   * @param  {Object}        obj       Object to copy
   * @param  {Boolean}       [shallow] [description]
   * @param  {Array|Object}  [list]    Takes any object with .length
   * @param  {Object}        [parent]  [description]
   * @return {Object}                  [description]
   */
  'clone', function(obj, shallow, list, parent) { //support shallow!; check obj copy only what is nessecary added makeshort , made parent shorter
    var copy = new this._class(),
      _val = this._val,
      i;
    if (parent) {
      copy._parent = parent;
    }
    copy.__t = this.__t;
    if (this.__t === 1) {
      copy.length = this.length;
    }
    if (list) {
      //list
      for (var j = list.length - 1, item; j >= 0; j--) {
        item = list[j];

        if (item instanceof Array && this[item[0]]) {
          if(item[1] === true) {
            copy[item[0]] = util.clone(this[item[0]], false, true)
          } else {
            copy[item[0]] = item[1];
          }
        } else if (this[item]) {
          // console.log(item)
          copy[item] = this[item];
        }
      }
    }
    if (_val && (_val instanceof VObject && _val._contained)) {
      copy.val = _val.clone(copy, false, list, copy);
      copy._val._contained = true;
    } else {
      VObject.set.call(copy, _val, false, false, true);
    }
    for (i in this) {
      if (!_c(this._blacklist, i)) {
        // console.log(i)
        if (!shallow) {
          if (this[i] instanceof VObject) {
            //function( name, val, vobj, stamp, noupdate, from )

            // console.log('----->1', i, this[i].clone(void 0, false, list, copy))
            //stamp void 0
            copy.set(i, this[i].clone(void 0, false, list, copy), true, false, true)
          } else {

            // console.log('----->2', i, util.clone(this[i]))

            copy[i] = util.clone(this[i]);
          }
        } else {
          //function( name, val, vobj, stamp, noupdate, from )
          copy.set(i, this[i], false, false, true);
        }
      }
    }
    if (obj !== void 0) {
      if (util.isObj(obj)) {
        // console.log('MERGE----->', obj, shallow)
        copy.merge(obj, shallow);
      } else {
        VObject.set.call(copy, obj, false, false, true)
      }
    }
    copy.__t = this.__t;
    return copy;
  },
  /**
   * Returns object on the end of a defined path
   * @method path
   * @param  {Array}     path           Array of fields in path
   * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
   * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
   * @param  {Function}  [writeHandler] Callback on write
   * @return {*}                        Object on the end of a defined path
   */
  'path', function(path, val, overwrite, writeHandler, vobj, stamp, noupdate, self) {
    if(!(path instanceof Array)) path = path.split('.');
    return util.path(this, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self);
  },
  /**
   * Gets object from specified path. When path is a string checks for 'dotnotation'.
   * @method get
   * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
   * @return {*}                 obj[path]|nested object/value
   */
  'get', function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },

  //(val, stamp, from, noupdate, add)
  // '$set', function( val, stamp, from, update ) { //get does not need an array as path

  //   return VObject.set.call( this, val, stamp, from, !update )
    
  //     '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
  //   if (!noupdate) {
  //     (val, stamp, from, noupdate, add)
  //     // console.log(this._path, val)
  //     this._update(val, stamp, from, remove, added, oldval);
  //   }
    

  // },
  /**
   * Check if obj is empty exclude field names passed to list
   * @method empty
   * @return {Boolean} True/false
   */
  'empty', {
    get: function() {
      return util.empty(this, this._blacklist);
    }
  },
  '$empty', function( excludes, update ) {
      //get does not need an array as path
      var _this = this
      this.each( function( key ) {
        if( 
            !excludes 
              || typeof excludes === 'string'  
                 ? key !== excludes 
                 : !util.checkArray( excludes, key ) 
          )
        {
          if( this.remove ) 
          {
            this.remove( false, false, false, false, false, true )
          } 
          else 
          {
            // console.warn( '$empty non-vObject object.util remove', this, key )
            _this[key] = null
          }
        }
      })
    
      if( this.clearCache ) this.clearCache()

      if( update )
      {
        this._update('empty')
      }
  },
  /**
   * Returns the V.Object from which the current update originated.
   * @method _updateOrigin
   * @return {V.Object} origin of the update
   */
  '_updateOrigin', {
    get: function() {
      var mark = this;
      // console.error('get UPDATE ORIGIN', this._path, this._lfrom)
      while (mark._lfrom) {

        //if V.CloudData
       // console.error( '_update that origin!', mark._path )
        mark = mark._lfrom;
      }
      return mark;
    }
  },
  '_origin', {
    get: function() {
      var mark = this;
      while (mark && mark.__t === 4) {
        mark = mark._val;
      }
      return mark;
    }
  }
)


//add find


},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/index.js":[function(require,module,exports){
(function (__dirname){
var util = require('../')
  , ajax
  , PACKAGE = '/package.json'

module.exports = exports = function( callback, params, packageFile, noReplace ) {

  packageFile = packageFile || ( util.isNode ? {} : window.package )

  var obj = {}
    , req = module.exports
    , cb = callback && function( pckg ) {

      obj = pckg.vigour
      req.parse( obj, packageFile, req._checks )

      if(!noReplace) module.exports = obj
      callback(obj)
    }

  //default option add more!
  if(!params) {
    exports.options.val(obj, cb, false, packageFile )
  } else if(exports.options[params]) {
    exports.options[params](obj, cb, false, packageFile )
  } else {
    exports.options.val(obj, cb, params, packageFile )
  }
  return obj
}

if(util.isNode) {
  exports.options = {
    val:function( obj, callback, params, pckg ) {
      callback( pckg )
    }
  }
} else {
  ajax = require( '../../browser/network/ajax' )
  exports.options = {
    val:function(obj, callback, params) {
      if( !window.package ) {
        var domain = !window.cordova && String(window.location)
            .match(/https?:\/\/([^\/]+)/)

        if(domain) domain = domain[0]
         
        ajax({
          url:params && params.url ? params.url : domain+PACKAGE,
          fallback: [
              { url: PACKAGE } //for testing
            , params && params.fallback ? params.fallback : { url: __dirname+PACKAGE }
            , { url: '../'+PACKAGE }
            , { url: '../../'+PACKAGE }
            , { url: '../../../'+PACKAGE }
          ],
          complete:function(data) {
            window.package = data
            if(callback) callback(data)
          }
        })
      } else if(callback) {
        callback(window.package)
      }
    }
  }
}

exports.inject = function() {
  exports._checks = util.arg(arguments)
  return exports
}

exports.loop = function(obj, option, pckgval, merge, fn, params ) {
  if(fn) {
    var val = option(obj,pckgval,merge, params)
    if(val) { util.merge(obj,val) }
  } else {
    for(var h in obj[option]) {
      if((pckgval===h)) {
        util.merge(obj,merge[h])
        break
      }
    }
  }
}

exports.parse = function( obj, pckg, options, params ) {
 if(!(options instanceof Array)) {
    options = [options]
 }

 for(var i in options) {
    for(var check in options[i]) {
      var pckgval = util.get(pckg,check)
        , option = options[i][check]

      exports.loop(obj, option, pckgval, obj[options[i][check]], typeof option === 'function',params)
    }
  }
  return obj
}

}).call(this,"/node_modules/old-vigour-js/util/config")
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../browser/network/ajax":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/ajax.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/config/ua.js":[function(require,module,exports){
var ua = require('../../browser/ua')
  , util = require('../')
  , Data = require('../../data').inject(require('../../data/selection'))
/*
selection!

*/
bla = exports

exports.parse = function(obj, pckgval, merge, params) {
  var _ua = ua

  if(params && params.ua) {
    _ua = ua.parse(params.ua.toLowerCase(),{})
  }

  // console.log('HERE!',obj,pckgval,merge)
  var cond
    , uaclone = new Data({bla:util.clone(_ua)})

  if(obj.ua) {
    for(var i in obj.ua) {
      if(_ua.platform===i||_ua.device===i||_ua.browser===i) {
        return obj.ua[i]
      } else if(obj.ua[i].condition) {
        if(!cond) {
          cond = new Data(uaclone, obj.ua[i])
        } else {
          cond.filter = obj.ua[i]
        }
        if(cond.length) {
          delete obj.ua[i].condition
          cond.remove()
          return obj.ua[i]
        }
      }
    }
  }


  //blabla

  // console.log('SUBOBJ???',obj)


  delete obj.subsObj

  if(cond) cond.remove()
}


},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../browser/ua":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/ua.js","../../data":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/index.js","../../data/selection":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/data/selection.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/debug/index.js":[function(require,module,exports){
(function (process){
var debug = exports

DEBUG$ = debug

/*
  console.log('util/test \n\nif you want to check memory usage start chrome using: \n\n open -a Google\\ Chrome --args --enable-memory-info \n')
*/
var util = require('../')
  , isNode = util.isNode //has to become part of util
  , V = require('../../')
  , log = debug.log = require('./log')
  , debuglog = log.logger('DEBUG$', 'rainbow')

debug.perf = debug.performance = require('./performance')

//------------------------------------------------------------------------------

if(!isNode) {
  debug.cases = require('../../browser/cases/')
  exports.body = document.body.base
  Object.defineProperty(module.exports, 'domain', {
    get: function() {
      //debugger --- can go away with a transform
      return String(window.location)
        .match(/https?:\/\/([^\/]+)/)[1]
        .replace(/:.+/, '')
    }
  })

} else {
  var DEBUG = process.env.DEBUG
  if(DEBUG){
    var levels = DEBUG.split(',')
    for(var l in levels){
      var two = levels[l].split(':')
      DEBUG$.level[two[0]] = two[1] ? Number(two[1]) : 3
    }
  }
}

//------------------------------------------------------------------------------

exports.int = function(rand, fn) {
  function func() {
    rand = rand||1000
    return ~~(Math.floor(Math.random()*rand))
  }
  return fn ? func() : func
}

exports.text = function (length, fn, str, nolines, strict) {
  if (fn) {
    return function() {
      return exports.text(
        Math.round(Math.random() * length) + 1, false, str, nolines, strict
      )
    }
  }
  else {
    var s = ['.', '.', '.', ';', ',']
      , b = ['ab', 'able', 'zo', 'x', 'lax', 'bur', 'rem', 'lur', 'fur', 'jur', 'lex', 'rex', 'wurd',
        'shur', 'burn', 'heps', 'a', 'i', 'y', 'u', 'e', 'p', 'l', 'splurf']
      , output = ''
      , nospace = 0

    if (str) b = str

    str = function () {
      return b[Math.round(Math.random() * (b.length - 1))]
    }
    if (!length) length = ~~ (Math.random() * 101)
    for (var i = 0, g; i < length; i++) {
      if ( !strict && (!output[output.length - 1]
        || output[output.length - 2] === '.'
        || output[output.length - 2] === '\n')
      ) {
        g = str()
        output += g[0].toUpperCase() + g.slice(1)
      }
      else {
        output += str()
      }
      nospace++
      if (!strict && ~~(Math.random() * (nospace / 2))) {
        var br = false
          , v
        if (!nolines && ~~(Math.random() * 21) > 17) {
          v = s[~~(Math.random() * (s.length - 1))]
          output += v
          if (v === '.' && ~~(Math.random() * 11) > 6) {
            br = true
            output += '\n'
            if (~~(Math.random() * 11) > 7) output += '\n';
          }
        }
        if (!br) output += ' '
        nospace = 0
      }
    }
    return output
  }
}

exports.data = function (populate, level, obj, cnt, prev) {
  if (!obj) obj = {}
  if (!cnt) cnt = 0
  if (!level) level = 0
  for (var i in populate) {
    if ((populate[i] instanceof Object)
      && populate[i].length && populate[i].val
    ) {
      if (populate && populate[i]) {
        obj[i] = []
        for (var j = 0; j < populate[i].length; j++) {
          obj[i][j] = typeof populate[i].val === 'function'
            ? populate[i].val()
            : exports.data(populate[i].val, (level + 1), false, j + 1, obj)
        }
      }
    }
    else if ((populate[i] instanceof Object)
      && (typeof populate[i] !== 'function')
    ) {
      obj[i] = exports.data(populate[i], (level + 1), obj[i], false, cnt, obj)
    }
    else if (populate && populate[i]) {
      obj[i] = (typeof populate[i] === 'function')
      ? populate[i].call(obj, cnt, prev)
      : populate[i];
    }
  }
  return obj;
};

//------------------------------------------------------------------------------
debug.download = function(filename, text) {
  var pom = document.createElement('a');
  pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  pom.setAttribute('download', filename);
  pom.click();
}

//------------------------------------------------------------------------------
debug.remote = function(id) {
  var fileref = document.createElement('script')
  fileref.setAttribute("type", "text/javascript")
  fileref.setAttribute("src", 'http://jsconsole.com/remote.js?'+id)
  document.getElementsByTagName("head")[0].appendChild(fileref)
}

debug.findScript = function(node,name,strict) {

  var children = node.childNodes
    , extension = name.match(/\.([a-zA-Z0-9]{1,30})$/)[1]
    , regExp = !strict && new RegExp(name+'$')
    , field = extension === 'js' ? 'src' : 'href'

  for(var i in children) {

    if(strict ? children[i][field]===name : regExp.test(children[i][field])) {
      return children[i]
    }

  }

  // console.log('notfound', name)
}

function prompty (msg, value, cb) {
    var dialog = document.createElement("div")
        , p = document.createElement("p")
        , input = document.createElement("input")
        , ok = document.createElement("button")
        , cancel = document.createElement("button")
    p.appendChild(document.createTextNode(msg))
    input.type = "text"
    input.value = value
    input.style.display = "block"
    ok.appendChild(document.createTextNode("OK"))
    cancel.appendChild(document.createTextNode("Cancel"))
    ok.addEventListener('click', function () {
        hideDialog()
        cb(input.value)
    })
    cancel.addEventListener('click', function () {
        hideDialog()
        cb(null)
    })
    dialog.appendChild(p)
    dialog.appendChild(input)
    dialog.appendChild(ok)
    dialog.appendChild(cancel)
    dialog.style.position = "absolute"
    dialog.style.top = 25 + "px"
    dialog.style.left = 50 + "px"
    dialog.style.zIndex = 1000
    dialog.style.fontSize =  24 + 'px'
    dialog.style.backgroundColor = "white"
    document.body.appendChild(dialog)
    function hideDialog() {
        dialog.parentNode.removeChild(dialog)
    }
}

debug.native = function(def, parse, cb, file) {
  if(!document.getElementById('dev')) {
    var elem = document.createElement('div')
    elem.id = 'dev'
    elem.style.zIndex = 9999999
    elem.style.position = 'absolute'
    elem.style.left = '2px'
    elem.style.top = '80px'
    elem.style.padding = '15px'
    elem.style.backgroundColor = 'rgba(50,50,50,0.8)'
    elem.style.borderRadius = '50%'
    elem.addEventListener('click',function() {
      prompty('IP', localStorage.getItem('devip') || def || 'http://10.0.1.2:8080', function (ip) {
        if (ip) {
          localStorage.setItem('devip',ip)
           window.location.reload()
        } else {
          // alert('x')
          localStorage.removeItem('devip')
          window.location.reload()
        }
      })
    })
    document.body.appendChild(elem)
  }

  if(!file) {
    file = 'build'
  }

  if( localStorage.getItem('devip') ) {
    DEBUG$.remoteResource(localStorage.getItem('devip')+'/bundle.css',file+'.css',false)
    if(DEBUG$.remoteResource(localStorage.getItem('devip')+'/bundle.js',file+'.js',false)) {
      document.getElementById('dev').style.backgroundColor = 'rgba(0,255,0,0.8)'
      if(cb) cb(localStorage.getItem('devip'))
      return true
    } 
  }
}

//hier remoteresource gebruiken
debug.remoteResource = function(src, replace, strict) {
  console.log('remote resource',src)
  var strict = strict !== void 0 ? strict : true
    , extension = src.match(/\.([a-zA-Z0-9]{1,30})$/)[1]
    , fileref = document.createElement(extension==='js' ? 'script' : 'link')
    , head =  document.getElementsByTagName("head")[0]
    , body = document.body
    , found
    , fileSrc

  if(!replace) {
    strict = false
    replace = src.match(extension==='js'
      ? /(\/)([a-zA-Z0-9-_+$]){0,30}\.js$/
      : /(\/)([a-zA-Z0-9-_+$]){0,30}\.css$/
    )[0].slice(1)


  }

  fileSrc = src+'?'+ ~~(Math.random()*9999999)

  if(extension==='js') {
    fileref.setAttribute("type", "text/javascript")
    fileref.setAttribute("src", fileSrc)
  } else {
    fileref.setAttribute("type", "text/css")
    fileref.setAttribute("rel", "stylesheet")
    fileref.setAttribute("href", fileSrc)
    fileref.setAttribute("id", fileSrc)
  }

  found = debug.findScript(head,replace,strict)

  if(!found) {
      console.log(body, found, '!@!@#!@#JS')

    found = debug.findScript(body,replace,strict)
  }
  if(found) {

    console.log('remote resource found:',found, found.src , fileSrc, src)

    var parent = found.parentNode
    if(String(found.src).indexOf(src)>-1) {
      return
    }

    parent.removeChild(found)
    parent.appendChild(fileref)
    return true
  }
}

}).call(this,require('_process'))
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../../browser/cases/":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js","./log":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/debug/log.js","./performance":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/debug/performance.js","_process":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/process/browser.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/debug/log.js":[function(require,module,exports){
var debug = require('./') 
  , util = require('../') 
  , isNode = util.isNode //has to become part of util
  , V = require('../../')
  , repl
  , colors
  , origConsole = console
  , colors = {
      green:'#56db68',
      red:'#ff0000',
      grey:'#ccc',
      yellow:'#e0e67c',
      cyan:'#00ffff',
      magenta:'#ff00ff',
      blue:'#1111ff',
      white:'#fff'
    }
  , styles = {
      bold:'font-weight:bold;font-size:16px;line-height:15px',
      underline:'border-bottom:1px solid',
      italic:'font-style:italic',
      inverse:function(color) {
        if(color) {
          return color+';background-color:#333;padding:5px;line-height:20px'
        } else {
          return 'color:'+colors.white+';background-color:#333;padding:5px;line-height:20px'
        }
      }
    }

debug.level = 
{ DEBUG$: Infinity
, test:2
}



/*
bold
italic
underline
inverse
yellow
cyan
white
magenta
green
red
grey
blue
rainbow
zebra
random
*/

//------------------------------------------------------------------------------

var logObject
  , parseObject
  , LOG
  , INFO
  , ERROR
  , DETAIL

if (!isNode) { 

  LOG = ':'
  INFO = '::'
  ERROR = 'ERREX!'
  DETAIL = ':::'

  // console = {}
  function loglink(i) {
    return function() {
      // console.log(i, arguments)
      // console.log(new Error().stack)

      origConsole[i].apply(origConsole, arguments)
    }
  }

  // for(var i in origConsole) {
  //   if(i !== 'log') console[i] = loglink(i)
  // }

  var Color = function(val,code,s) {
    this.color =  (s ? code : 'color: '+code)+';'
    this.val = new String('%c'+val)
  }
  
  // console.log = function() {

  //   var next = false

  //   for(var i=0, arg, rargs=[], args = arguments,len = args.length;i<len;i++) {
  //     arg = args[i]
  //     if(arg instanceof Color) {
  //       if(rargs.length){
  //         next = util.arg(args, i)
  //         break
  //       }else{
  //         rargs.push(arg.val.valueOf(), arg.color)
  //       }
  //       // logger(arg.val.valueOf(), arg.color)
  //     } else {
  //       rargs.push(arg)
  //     }
  //   }
  //   // logger('now log', rargs)
  //   if(rargs.length) logger.apply(origConsole,rargs)
  //   // logger('next', next)
  //   if(next.length) console.log.apply(null,next)

  // }

  function color(i, Class, style) {
    util.define(Class || String,i,{
      get:function() {
        if(Class) {
          if(typeof style === 'function') {
            this.color = style(this.color)
          } else {
            this.color+=(style||('color:'+colors[i]))+';'
          }
          return this
        } else {
          var s = colors[i]
          if(style) {
            if(typeof style === 'function') {
              s = style()
            } else {
              s=style
            }
          }
          return new Color(this,s,style)
        }
      }
    })
  }

  // function logger() {


  //   origConsole.log.apply(origConsole,arguments)


  // }

  // for(var i in colors) { color(i) }
  // for(var i in styles) { color(i, false, styles[i]) }  
  // for(var i in colors) { color(i, Color) }
  // for(var i in styles) { color(i, Color, styles[i]) }  

  parseObject = function(obj) {
    if(typeof obj === 'string') return obj
    var str = ''
    for(var i in obj) {
      str += i + ' : ' + (typeof obj[i] === 'string' 
        ?  obj[i] 
        : JSON.stringify(obj[i],false,2)) 
      + '\n'
    }
    return str.inverse.green
  }
  
  logObject = function(obj) {
    console.log(parseObject(obj))
  }
  
} else {
  repl = require('repl')
  colors = require('colors')

  LOG = 'log  '.grey
  INFO = 'info '.green
  ERROR = 'error'.red
  DETAIL = '-----'.grey

  debug.repl = function() {
    repl.start('>')
    return debug
  }
  if(repl.context) repl.context.DEBUG$ = DEBUG$

  console.group = function() {
    console.log('\n____________________________________________________'.grey)
  }      
  console.groupEnd = function() {
    console.log('____________________________________________________\n'.grey)
  }
  var n_util = require('util')
  parseObject = function(obj){
    return n_util.inspect(obj,{colors:true, depth: 50})
  }
  logObject = function(obj){
    console.log(parseObject(obj))
  }
}

//------------------------------------------------------------------------------

util.define(Object,'DEBUG$log', function(msg,s) {
  if(console.group) console.group()
  if(typeof msg === 'string') {
    msg = msg
  } else {
    msg = false
  }
  var h = 'JSON '+(msg||' normal')
  debug.log.header(h)
  if(debug.level.test>1) console.log(JSON.stringify(this,false,2))
  if(s) {
    console.log('\n')
    debug.log.fn.apply(this,util.arg(arguments,1)) 
  }
  // debug.log.end(h)
  if(console.group) console.groupEnd()
  return JSON.stringify(this,false,2)
})

if(!isNode && localStorage) {
  util.define(localStorage,'DEBUG$log', function(msg,s) {
    if(console.group) console.group()
    if(typeof msg === 'string') {
      msg = msg
    } else {
      msg = false
    }
    var h = 'localStorage '+(msg||' normal')
    debug.log.header(h)

    var obj = {}
    for(var i in this) {
      // console.log(i, this)
       try { obj[i] =JSON.parse(this[i]) } catch(e){
        obj[i] = this[i]
       }
    }

    // console.log()

    if(debug.level.test>1) console.log(JSON.stringify(obj,false,2))
    if(s) {
      console.log('\n')
      debug.log.fn.apply(this,util.arg(arguments,1)) 
    }
    // debug.log.end(h)
    if(console.group) console.groupEnd()
    return obj
  })
}

//------------------------------------------------------------------------------

var log = module.exports = exports = {
  stack: false,
  i:function(nr) {
    nr = this.indent
    var str = ''
    for(var i in nr) {
      str+='  '
    }
    return str
  },
  parse: parseObject,
  object: logObject,
  default: function(label, level){
    if(label instanceof Object)
      for(var l in label)
        setDefault(l, label[l])
    else
      setDefault(label, level)
  },
  logger:function(label, color, level){
    log.default(label, level || 1)
    
    function logger(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 2) {
//         console.log.apply(null, [label[color].bold, LOG].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
    }

    logger.info = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 1) {
        console.log.apply(null, [label[color].bold, INFO].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
        
    }
    logger.error = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 0) {
        console.log.apply(null, [label[color].bold, ERROR].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
    }
    logger.detail = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 3) {
        console.log.apply(null, [label[color].bold, DETAIL].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }      
    }
    logger.parse = parseObject
    return logger
  },
  label: function(label, style, log){
      if(isNode) {
        console.log.apply(null, log)
      } else {
        console.log.apply( null
          , ['%c '+label+' ', style].concat(log)
        )
      }
  },
  header:function(msg) {
    this._lh = msg
    console.log(msg.inverse)
  },
  header2:function(msg) {
    this._lh = msg
    console.log(msg.grey.inverse)
  },
  end:function(msg) {
    console.log(('end ['+msg+']').grey.inverse)
  },
  level:function(level,field) {
    if(level >= debug.level.test 
      ||  debug.level[level] 
      || field && debug.level[level]>=field ) 
      console.log.apply(this,util.arg(arguments,1))
  },
  fn:function(arg) {
    debug.log.indent++
    if(typeof arg === 'function') {
      arg.call(this,util.arg(arguments,1))
    } else {
      console.log(arguments)
//       console.log.apply(this,arguments)
    }
    debug.log.indent--
  },
  indent:0
}

//------------------------------------------------------------------------------
function smallStack(lines){
  if(!lines) lines = 1
  var stack = new Error().stack.split('\n')
    , l = 3
    , result = []
    , end

  while(lines--){
    line = stack[l++]
    end = line[line.length-1] === ')' ? line.length-1 : line.length
    result.push(line.slice(line.indexOf('/'), end))
  }

  return result.join('\n').grey
  
}

function setDefault(label, level){
  if(debug.level[label] === void 0) debug.level[label] = level
}

setTimeout(function() {
//   console.log('log levels:\n', log.parse(debug.level))
},0)

//Localstorage

/*
var localStorageSpace = function(){
        var allStrings = '';
        for(var key in window.localStorage){
            if(window.localStorage.hasOwnProperty(key)){
                allStrings += window.localStorage[key];
            }
        }
        return allStrings ? 3 + ((allStrings.length*16)/(8*1024)) + ' KB' : 'Empty (0 KB)';
    };

*/

util.define(debug,'localStorageSize', {
  get:function() {
  var total = 0
  for(var x in localStorage) {
    var kbytes = (((x.length+localStorage[x].length))/(1024))
    total+=kbytes
    // console.log((x+":"+kbytes.toFixed(10)+" KB").grey)
  }
  console.log('LOCAL STORAGE SIZE TOTAL'.inverse.green, (total/1024).toFixed(5)+' MB')
  return total*1024
}
})

util.define(debug,'localStorageKeysSize', {
  get:function() {
  var total = 0
  for(var x in localStorage) {
    var kbytes = (((x.length))/(1024))
    total+=kbytes
    // console.log((x+":"+kbytes.toFixed(10)+" KB").grey)
  }
  console.log('LOCAL STORAGE KEY SIZE TOTAL'.inverse.green, (total/1024).toFixed(5)+' MB')
  return total*1024
}
})



},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/debug/index.js","colors":"/Users/youzi/dev/mtv-play/node_modules/colors/colors.js","repl":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/browserify/lib/_empty.js","util":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/util/util.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/debug/performance.js":[function(require,module,exports){
(function (process){
var util = require('../') 
  , debug = require('./') 
  , isNode = util.isNode //has to become part of util
  , os

if (isNode) { 
  os = require('os')
} else {
  console.log('DEBUG \n\nif you want to check memory usage start chrome using: \n\n open -a Google\\ Chrome --args --enable-memory-info --js-flags="--expose-gc"\n'.grey)
}

function _test(method, name, complete, call, args, nolog) {
  var start = exports.now()
    , memorystart = exports.memory()
    , memoryend
    , mem
    , time
    , end
    , sub 
  if (!name) name = 'TEST PERFORMANCE'
  if (call) {
    sub = method.apply(call, args)
  } 
  else {
    sub = method.apply(this, args)
  }
  end = exports.now()
  memoryend = exports.memory()
  mem = (memoryend - memorystart)
  time = end - start - (sub || 0)
  if (complete) {
    complete(((time) / 1000), (memoryend - memorystart))
  } 
  else if (!nolog) {
    if(debug.level.test>0) {
      console.log( 
        name.inverse , '\nparse time: ' 
        + ((end - start) / 1000) 
        + ' sec' + (mem ? '\nmemory used (approximate): ' 
        + mem + ' bytes' : '')
      )
    }
  }
  return time
}



var oldCheck = []
debug.countNewListeners = function( obj, amount ) {
  
  amount = {val:0}

  var checknow = []

  debug.countListeners( obj, amount, checknow ) 

  var newlistners = []

  for( var i in checknow ) {

    if( util.checkArray( oldCheck, checknow[i] ) === false ) {
      // console.log(checknow[i])
      // if( typeof checknow[i] === 'object' || typeof checknow[i] === 'function' ) {
        // console.log('lets push')
        // if(!util.empty(checknow[i])) {
        newlistners.push( checknow[i] )
        // }
      // }
    }
  }

  oldCheck = checknow

  return {
    amount: amount.val
  , newchecks: newlistners
  }

}


debug.countListeners = function(obj, amount, checked) {
  var amount 
    , checked 

  if(!checked) {
    checked = []
  }

  if(util.checkArray(checked, obj)!==false || !obj) {
    return amount.val
  }
  checked.push(obj)

  if(!amount) amount = {val:0}
  if(obj._listeners) {
    amount.val+=obj._listeners.length
  }

  if(!obj.each) {

    if(obj instanceof Object) {
      for(var i in obj) {
        if(obj[i] && ( obj[i].__t || obj[i]._from || obj._from && i ==='cloud') ) debug.countListeners(obj[i],amount,checked)
      }
    }

  } else {

    obj.each(function(i) {
      debug.countListeners(this,amount,checked)
    })

  }

  return amount.val
}

debug.countSubs = function(obj, amount, key) {
  var amount 
  if(!amount) amount = {val:0}
  if(obj._subs) {
    console.log('!!!!!SUB', obj._path, obj._subs)
    amount.val+=obj._subs.length
  }
    
  if(!obj.each) {
    console.log('no EACH!', key)
  }
  // console.log(obj, obj._subs)
  obj.each(function(i) {
    debug.countSubs(this,amount,i)
  })
  return amount.val
}

function _done(params, time, mem) {
  if (params.complete) {
    params.complete(time, mem, params, exports.average(time)[0], exports.average(time)[1])
  } else {
    if(debug.level.test>0) {
      console.log(
        params.name.inverse 
        , ' n=' + params.loop 
        + '\nparse time:' 
        + (params.extensive 
          ? (' \n\n' + time.join(' sec\n') + ' sec\n\n') 
          : '') 
        + 'average: ' + exports.average(time)[1] 
        + ' sec\ntotal: ' 
        + exports.average(time)[0] + ' sec')
    }
    //+(mem.length>0 ? '\nmemory used (approximate): '+mem+' kb' : '');
  }
}

module.exports = exports = function (params, fn) {
  if (fn && typeof params === 'string') {
    return _test(fn, params)
  } 
  else if (typeof params === 'function') {
    return _test(params)
  } 
  else if (params instanceof Object) {
    if(!params.name) params.name = 'performance test'

    if (params.loop) {
      //testing memory in loop is hard since the gc almost never makes it before next iteration;
      var time = []
        , mem = []
        , callback = function (_time, memory) {
          time.push(_time)
          if (memory) mem.push(memory)
        }

      if(params.interval) {
        var cnt = 0
          , interval = setInterval(function() {
              cnt++
              if(cnt===params.loop-1) {
                 clearInterval(interval)
                 _done(params, time, mem) 
              } else {
                _test(params.method, false, callback)
              }
            },params.interval)
      } else {
        for (var i = params.loop; i > 0; i--) {
          _test(params.method, false, callback)
        }
        _done(params, time, mem) 
      } 
      return exports.average(time)
    } 
    else {
      return _test(params.method
        , params.name
        , params.complete
        , params.call
        , params.args
        , params.nolog)
    }
  }
}

if(debug.log) debug.log.default('test', 4)

exports.now = function () {
  return isNode
    ? process.hrtime()[0] * 1000 + process.hrtime()[1] * 0.000001 
    : (window.performance && window.performance.now 
      ? window.performance.now() 
      : new Date().getTime())
}

exports.memory = function () {
  return isNode 
    ? process.memoryUsage().heapUsed 
    : (window && window.performance && window.performance.memory 
      ? window.performance.memory.usedJSHeapSize * 0.000976562 
      : 0)
}

exports.average = function (array) {
  var number = 0
  for (var i = array.length - 1; i >= 0; i--) {
    number += array[i]
  }
  return [number, number / array.length]
}

}).call(this,require('_process'))
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/debug/index.js","_process":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/process/browser.js","os":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/os-browserify/browser.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/encode64.js":[function(require,module,exports){
/**
*
*  Base64 encode / decode
*  http://www.webtoolkit.info/
*
**/
var Base64 = {

// private property
_keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

// public method for encoding
encode : function (input) {
    var output = "";
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0;

    input = Base64._utf8_encode(input);

    while (i < input.length) {

        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
            enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
            enc4 = 64;
        }

        output = output +
        this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
        this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

    }

    return output;
},

// public method for decoding
decode : function (input) {
    var output = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    while (i < input.length) {

        enc1 = this._keyStr.indexOf(input.charAt(i++));
        enc2 = this._keyStr.indexOf(input.charAt(i++));
        enc3 = this._keyStr.indexOf(input.charAt(i++));
        enc4 = this._keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output = output + String.fromCharCode(chr1);

        if (enc3 != 64) {
            output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
            output = output + String.fromCharCode(chr3);
        }

    }

    output = Base64._utf8_decode(output);

    return output;

},

// private method for UTF-8 encoding
_utf8_encode : function (string) {
    string = string.replace(/\r\n/g,"\n");
    var utftext = "";

    for (var n = 0; n < string.length; n++) {

        var c = string.charCodeAt(n);

        if (c < 128) {
            utftext += String.fromCharCode(c);
        }
        else if((c > 127) && (c < 2048)) {
            utftext += String.fromCharCode((c >> 6) | 192);
            utftext += String.fromCharCode((c & 63) | 128);
        }
        else {
            utftext += String.fromCharCode((c >> 12) | 224);
            utftext += String.fromCharCode(((c >> 6) & 63) | 128);
            utftext += String.fromCharCode((c & 63) | 128);
        }

    }

    return utftext;
},

// private method for UTF-8 decoding
_utf8_decode : function (utftext) {
    var string = "";
    var i = 0;
    var c = c1 = c2 = 0;

    while ( i < utftext.length ) {

        c = utftext.charCodeAt(i);

        if (c < 128) {
            string += String.fromCharCode(c);
            i++;
        }
        else if((c > 191) && (c < 224)) {
            c2 = utftext.charCodeAt(i+1);
            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
        }
        else {
            c2 = utftext.charCodeAt(i+1);
            c3 = utftext.charCodeAt(i+2);
            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }

    }

    return string;
}

}

module.exports = exports = Base64
},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/global.js":[function(require,module,exports){
(function (process,global){
var g = typeof window !== 'undefined'
        ? window
        : typeof global !== 'undefined'
          ? global
          : false
  , hasLS = typeof localStorage !== 'undefined'
  , hasPR = typeof process !== 'undefined'

var G = module.exports = 
  { session: function(key, val){
      return getSet(g, key, val)
    }
  , env: function(key, val){
      if(hasLS)
        return getSet(localStorage, key, val, 'getItem', 'setItem')
      else if(hasPR)
        return getSet(process.env, key, val)
    }
  }

function getSet(thing, key, val, getter, setter){
  if(!thing)
    return

  if(val === void 0){
    if(getter)
      return thing[getter](key)
    else
      return thing[key]
  }else{
    if(setter){
      thing[setter](key, val)
      return val
    }else{
      return thing[key] = val
    }
  }
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/process/browser.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/hash.js":[function(require,module,exports){
//check this for more compression http://www.htmlgoodies.com/html5/client/optimizing-websockets-bandwidth.html#fbid=6QZx8napu20

/*
var crcTable
  , create = function () {
      crcTable = []
      for (var c, n = 0, k; n < 256; c = ++n) {
        for (k = 0; k < 8; k++, c = ((c & 1) ? ((0xEDB88320) ^ (c >>> 1)) : (c >>> 1)));
        crcTable[n] = c
      }
      return crcTable
    }

exports = module.exports = function (str) {
  for (var tab = crcTable || create(), crc = -1, i = 0, l = str.length; i < l; i++) {
    crc = (crc >>> 8) ^ tab[(crc ^ str.charCodeAt(i)) & 0xFF]
  }
  return exports.encode(((crc ^ (-1)) >>> 0))
}


*/

exports = module.exports = function(key, seed) {
  var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;
  seed = 1

  remainder = key.length & 3; // key.length % 4
  bytes = key.length - remainder;
  h1 = seed;
  c1 = 0xcc9e2d51;
  c2 = 0x1b873593;
  i = 0;
  
  while (i < bytes) {
      k1 = 
        ((key.charCodeAt(i) & 0xff)) |
        ((key.charCodeAt(++i) & 0xff) << 8) |
        ((key.charCodeAt(++i) & 0xff) << 16) |
        ((key.charCodeAt(++i) & 0xff) << 24);
    ++i;
    
    k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

    h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
    h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
    h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
  }
  
  k1 = 0;
  
  switch (remainder) {
    case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
    case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
    case 1: k1 ^= (key.charCodeAt(i) & 0xff);
    
    k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= k1;
  }
  
  h1 ^= key.length;

  h1 ^= h1 >>> 16;
  h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
  h1 ^= h1 >>> 16;

  return (h1 >>> 0).toString(36)
}

// exports = module.exports = function( str )
// {
//   var FNV1_32A_INIT = 0x811c9dc5;
//   var hval = FNV1_32A_INIT;
//   for ( var i = 0; i < str.length; ++i )
//   {
//     hval ^= str.charCodeAt(i);
//     hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
//   }
//   return hval >>> 0;
// }

/**
 * Encode to base 62 (url save)
*/
exports.encode = function c (a, b) {
  b = b || ""
  return ~~ a 
       ? c(a / 62, String.fromCharCode(((a %= 62) > 9 
          ? a > 35 ? 29 : 87 
          : 48) + a) + b) 
       : b
}

/**
 * decode base 62
*/
exports.decode = function (a, b, c, d) {
  for (b = c = 0; d = a.charCodeAt(c++); b = b * 62 + d - [ , 48, 29, 87][d >> 5]);
  return b
}


// exports.decode64

},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/id.js":[function(require,module,exports){
module.exports = function id(pre, level){
  var r = rnd()
  if(level) 
    while(level--){
      r += rnd()
    }
  return pre ? pre + r : r
}

function rnd(){
  return Number(String(Math.random()).slice(2)).toString(36)
}
},{}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
require('./object') //these things add extra methods to util for readability in a seperate module
require('./prop')


exports.isNode = (typeof window === 'undefined') ? true : false

/**
 * Add is similar to .push it returns the array instead of length
 * Can be extended to support more types e.g. add an object to another
 * @method add
 * @param  {Array}  obj Target
 * @param  {Object} add Object to add
 * @deprecated
 */
exports.add = function (obj, add) {
  if (add) obj.push.apply(obj, add);
  return obj
}

/**
 * Finds items in an array
 * @method checkArray
 * @param  {Object|Array}                 list  Defines the list where you want to search through, only uses .length field
 * @param  {Object}                       val   Defines the value you want to search for
 * @param  {Boolean|String|Number}        [index] When index is true return the index instead of true or false, when index and index !== true index is used as a field in objects in the array
 * @param  {String}                       [field] When field return field instead of index or true
 * @return {*}
 */
exports.checkArray = function (list, val, index, field) {
  var arr = index instanceof Array
  if(!list) return false
  for (var i = 0, l = list.length, t; i < l; i++) {
    t = list[i]
    if (index !== void 0) {
      if (index === true) {
        if (t === val) return i
      } else if (arr ? exports.path(t,index)===val : t[index] === val) return field ? t : i
    } else {
      if (t === val) return true
    }
  }
  return false
}

/**
 * Pass arguments (arguments) and return a new array, when index return a new array sliced from index
 * @method arg
 * @param  {Arguments} args        Arguments
 * @param  {Number}    [index = 0] When index return a new array sliced from index
 * @return {Array}
 */
exports.arg = function (args, index) {
  return Array.prototype.slice.call(args, !index ? 0 : index)
}

/**
 * Check if obj is empty exclude field names passed to list
 * @method empty
 * @param  {Object}       obj  Object
 * @param  {Object|Array} list Takes any object with .length
 * @return {Boolean}           True/false
 */
exports.empty = function (obj, list) {
  for (var i in obj) {
    if (!list || !this.checkArray(list, i)) return false
  }
  return true
}

exports.inject = require('./inject')

},{"./inject":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/inject.js","./object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/object.js","./prop":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/prop.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/inject.js":[function(require,module,exports){

var V = require('../')
  , util = require('./')

var $TEST
if(!util.isNode) {
  $TEST = window.$TEST
}



module.exports = exports = function(extend) {

  var args = arguments

  if(args[0]&&args[0].$TEST) {
     $TEST = window.$TEST = true
  }

  if( (typeof this === 'function') || (V.Base && (this instanceof V.Base)) || typeof this === 'object') {
    if((V.Base 
        && (this===V.Base 
        || (this.prototype instanceof V.Base)
        || (this instanceof V.Base))
      )) { 
      args = util.arg(args)
      args.unshift(this)
      extend = this
    } else {
      return inject.apply(this,args)
    }
  }
  for(var i = 1; i < args.length; i++) {
   makeExtend(extend, args[i])
  }
  return extend
}

function makeExtend(extend, module) {
  if($TEST) console.log('9', module, extend)
  if(module.extend) {
    if($TEST) console.log('9.1', extend)
     module.extend(extend)
  } else if(module instanceof Array) {
    var arr = module.concat()
      , mod = arr[0]
    arr[0] = extend
     if($TEST) console.log('9.2')
    mod.extend.apply(mod,arr)
  } 
} 

function inject() {
  if($TEST) console.log('5')
  //do special stuff voor blacklist
  // Custom.prototype = new this() //lighter
  var Custom
    , extendResidue = []
    , Aspects = [this]

  for (var i = 0, Aspect, args = arguments, len = args.length; i < len; i++) {
    
    Aspect = args[i]

    if(typeof Aspect === 'function') {
      if(!Custom) {
        Custom = function() {
          for (var j = 0, len = Aspects.length; j < len;  j++) {
            Aspects[j].apply(this, arguments)
          }
        }
        inherits( Custom, this )
      }
      Aspects.push(Aspect)
      for (var method$ in Aspect.prototype) if ({}.hasOwnProperty.call(Aspect.prototype, method$)) {
        if (method$ === 'constructor') continue
        Custom.prototype[method$] = Aspect.prototype[method$]
      }
    } else {
      if($TEST) console.log('6')
      if(Custom) {
              if($TEST) console.log('7')

       makeExtend(Custom , Aspect)
      } else {
        // if($TEST) console.log('8')
        extendResidue.push(Aspect)
      }
    }
  }

  if(!Custom) Custom = this
  
  for(var j in extendResidue) {
    // console.log('8.'+j, extendResidue[j], Custom)
    makeExtend(Custom,extendResidue[j])
  }

  return Custom
}

function inherits(ctor, superCtor) {
  ctor.super_ = superCtor
  ctor.prototype = Object.create
    ( superCtor.prototype
    , { constructor: 
        { value: ctor
        , enumerable: false
        , writable: true
        , configurable: true
        }
      }
    )
}

/*
 Dit moet worden geadd voor V.Objects
/*
  object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)
      if (val !== void 0) this.val = val
      // console.log(constructor)
      if(constructor) constructor.apply(this,arguments)  
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

veel dingen werken als extension niet als losse class -- 

*/


},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , vigour = require('../') //only here to be able to use util without vigour.Object maybe refactor this away?
  , DOT = '.'

/**
 * lookup
 * polyfill if __lookupSetter__ does not exist;
 */
exports.lookup = Object.__lookupSetter__ || function (i) {
  var t = this
    , a
  while (t) {
    a = Object.getOwnPropertyDescriptor(t, i)
    if (a && a.set) return true
    t = Object.getPrototypeOf(t)
  }
  return false
}

/**
 * Used to set a val to an field on a object, whether it is a vigour.Object or a regular object
 * @method set
 * @param {Object} obj   Defines target Object
 * @param {String} field Target field
 * @param {*}      val   Value to set
 * @todo                 Move this function to a different module (e.g. 'convenience' module)
 */
exports.set = function (obj, field, val, vobj, stamp, noupdate) {
  return (vigour.Object && (obj instanceof vigour.Object))
    ? obj.set(field, val, vobj, stamp, noupdate)
    : (obj[field] = val)
}


/**
 * Returns object on the end of a defined path
 * @method path
 * @example
 * // returns obj.a.b.c
 * var obj = { a: { b: { c: 1 }}}
 * V.util.object.path(obj,['a','b','c'])
 * @param  {Object}    obj            Object to search
 * @param  {Array}     path           Array of fields in path
 * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
 * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
 * @param  {Function}  [writeHandler] Callback on write
 * @param  {Boolean}   [noupdate]     When true, updates will be skipped on write
 * @param  {Number}    [i = 0]        Starting point for searching through path
 * @return {*}                        Object on the end of a defined path
 */

exports.path = function ( obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, i ) {
  if (!i) i = 0

  var field = path[i]
    , result
    , c
    , target = (!self && obj && obj.__t === 4) ? obj.from[field] : obj && obj[field]
    , l = i < path.length - 1

  // if(field === void 0) {
  //   throw new Error('path must not contain undefined')
  // }

  if (l && !(target instanceof Object)) target = void 0

  if ((val !== void 0) && (target === void 0 || (!l && overwrite))) {
    c = true
    exports.set(obj, field, l ? {} : val, l ? false : vobj, stamp, noupdate)
    target = obj[field]
  }

  if (l) {
    result = target
      ? this.path(target, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, ++i)
      : target
  } else {
    result = (!self && target && target.__t === 4) ? target.from : target;
    if (c && writeHandler) writeHandler(result)
  }

  return result
}

/**
 * Adds path using 'dot-notation'
 * @method dotField
 * @example
 * // returns blur:{d:{a:{s:{}}}}
 * var blur = {};
 * V.util.object.dotField(blur,'d.a.s');
 * @param  {Object} obj   Object where field will be added
 * @param  {String} field String using 'dot-notation'
 * @return {Object}       Returns field
 */
exports.dotField = function (obj, field) {
  if (~field.indexOf(DOT)) {
    var path = field.split(DOT)
      , first = path.shift()
      , val = {}
    this.path(val, path, obj[field])
    delete obj[field]
    obj[first] = val
    field = first
  }
  return field
}

/**
 * Checks if two lists contain identical content
 * @method compareArrays
 * @param  {Array|Object} a         Takes any object with .length
 * @param  {Array|Object} b         Takes any object
 * @param  {Boolean}      keys      use Object.keys for b
 * @return {Boolean}      True/false
 * @todo                  Maybe change title => compareLists
 */
exports.compareArrays = function(a, b, keys) {
  var bl = keys ? Object.keys(b).length : b.length
  if (a.length !== bl) return false
  for (var i = a.length - 1; i >= 0; i--) {
    if (a[i] != b[i]) return false
  }
  return true
}

/**
 * Gets object from specified path. When path is a string checks for 'dotnotation'.
 * @method get
 * @example
 * // returns 'foo'
 * var a = {b:{c:'foo'}}
 * V.util.object.get(a,'b.c')
 * @param  {Object}       obj  Defines object or V.Value
 * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
 * @return {*}                 obj[path]|nested object/value
 */
exports.get = function (obj, path, self) {
  //TODO: make one interface for get

  if (!obj || !path) return
  if (!self && obj.__t === 4 && !obj._filter) obj = obj.from
  if (!(path instanceof Array)) {
    if (~path.indexOf(DOT)) {
      path = path.split(DOT)
    } else {
      return (!self && obj[path] && obj[path].from) || obj[path]
    }
  }
  //self is too far away in the arguments
  return this.path(obj, path, void 0, false, false, false, false, false, self)
}

/**
 * Returns true if an object is an instance of an object and not a function , V.Object or V.Base
 * @method isObj
 * @param  {Object}  obj Object to inspect
 * @return {Boolean}     True/False
 */
exports.isObj = function (obj) {
  return (obj instanceof Object
    && typeof obj !== 'function'
    && (!vigour.Object || !(obj instanceof vigour.Object))
    && (!vigour.Base || !(obj instanceof vigour.Base)))
}

/**
 * Creates new object with the same value , takes custom objects into account (new obj.constructor())
 * @method clone
 * @param  {Object} obj Object to clone
 * @return {Object}     Returns clone
 */
exports.clone = function (obj, exclude, shallow) {
  if (this.isObj(obj)) {
    var copy = new obj.constructor()
    for (var i in obj) {
      if(!exclude || !exclude[i])
        copy[i] = !shallow
          ? this.clone(obj[i], exclude)
          : obj[i]
    }
    return copy
  }
  return obj
};

/**
 * Merges object b into object a and returns object a
 * @method merge
 * @param  {Object} a Object a
 * @param  {Object} b Object b
 * @return {Object}   Object a
 */
exports.merge = function (a, b, norefs, overwrite) {
  for (var i in b) {
    var aisobj = util.isObj(a[i])
      , bisobj = util.isObj(b[i])

    if (aisobj && bisobj) {
      util.merge(a[i], b[i], norefs, overwrite)
    } else if(!norefs || !bisobj){
      if( overwrite === void 0
       || !(i in a)
       || typeof overwrite === 'function' && overwrite(a[i], b[i])
        ){
        a[i] = b[i]
      }

    }else{
      a[i] = b[i] instanceof Array ? [] : {}
      util.merge(a[i], b[i], norefs, overwrite)
    }
  }
  return a
}

// exports.resolve = function(a, b, bFrom, j) {
//   var same = true;
//   if(b instanceof Object) {
//     for(var i in b) {
//       if(a[i]!==void 0) {
//         if(exports.resolve(a[i],b[i],bFrom ? bFrom[i] : b[i],i)) {
//           if(bFrom) {
//             delete bFrom[i]
//           }
//         } else {
//           same = false
//         }
//       } else {
//         same = false
//       }
//     }
//     if(same) {
//       if(!(bFrom&&j!==void 0)) return true
//       delete bFrom[j]
//     }
//     return same;
//   } else {
//     if(a==b) {
//       if(bFrom&&j!==void 0) {
//         delete bFrom[j]
//       }
//       return true
//     }
//   }
// }

exports.resolve = function(a, b, bFrom, j) {
  // console.log('lolresolve\n',bFrom)
  var same = true;
  if(b instanceof Object) {
    for(var i in b) {
      if(a[i]!==void 0) {
        if(exports.resolve(a[i],b[i],(bFrom!==void 0 && bFrom!==null) ? bFrom[i] : b[i],i)) {
          if(bFrom!==void 0 && bFrom!==null) {
            if(bFrom[i]===null) {
              same = false
            } else {
              delete bFrom[i]
            }
          }
        } else {
          same = false
        }
      } else {
        same = false
      }
    }
    if(same) {
      if(!(bFrom&&j!==void 0)) return true
      delete bFrom[j]
    }
    return same;
  } else {
    if(a==b) {
      if(bFrom&&j!==void 0) {
        delete bFrom[j]
      }
      return true
    }
  }
}

/**
 * Adds value to array if it is not contained in array, executes handler on encountering val in array
 * @method include
 * @param  {Object|Array}   obj       Takes any object with .length
 * @param  {*}              val       Value to add
 * @param  {Function}       [handler] Function to execute on encountering val in array
 * @param  {Boolean}        arr       Include elements of val separately rather than including val itself
 * @return {Boolean}                  True/false
 */
exports.include = function (obj, val, handler, arr) {

  if(arr && val instanceof Array) {
    var ret = false
    for(var i = 0 , len = val.length; i < len; i++) {
      ret = exports.include(obj, val[i], handler)
    }
    return ret
  }

  var i = 0
    , l = obj.length
    , field
    , check

  if (obj.__t === 1) {
    for (;i < l; i++) {
      field = check = obj[i]
      if (check.__t === 4) check = check.from
      if (check === val || check.val === val) {
        if (handler) handler(field)
        return false
      }
    }
    obj.push(val)
    return true
  } else if (obj instanceof Array) {
    for (;i < l; i++) {
      if (obj[i] === val) {
        return false
      }
    }
    obj.push(val)
    return true
  }
}

exports.changeType = function( obj ) {
  var result
  if(obj instanceof Array) {
    result = {}
    for(var i=0,len=obj.length;i<len;i++) {
      result[i]=obj[i]
    }
  } else {
    result = []
    for(var i in obj) {
      result.push(obj[i])
    }
  }
  return result
}

/**
 * Ensures a value is not or contains no V.Objects, only their "raw" versions
 * This needs to be unified with convert, or at least get a better name.
 * @method raw
 * @param  {*}   val   the value to be processed
 * @return {*}         the processed value
 */
exports.raw = function( val, rparams ) {
  if (val instanceof Object) {
    if (val instanceof vigour.Object) {
      return val.raw
    } else {
      var result
      if (val instanceof Array) {
        result = []
        for (var i = 0, l = val.length; i < l; i++) {
          result[i] = this.raw(val[i], rparams)
        }
      } else {
        result = {}
        for (var f in val) {
          result[f] = this.raw(val[f], rparams)
        }
      }
      return result
    }
  } else {
    return val
  }
}

//add level and stops for certain branches
exports.walk = function(obj, fn ) {
  for(var i in obj) {
    if(obj[i] instanceof Object) {
      if(!fn(i, obj[i], obj, true)) {
        if(exports.walk(obj[i], fn)) return true
      } else {
        return true
      }
    } else {
      if(fn(i, obj[i], obj)) {
        return true
      }
    }
  }
}

exports.checkParentFactory = function( parentField ) {
  return function(field, get, links, match) {
    if(get&&get!==true) {
      match = get
      get = false
    }
    var fields = field instanceof vigour.Object ? false : field,
      curr = this,
      found;
    while (curr) {
      found = fields === false ? curr === field : exports.get(curr, fields, !links);
      if (found) {
        if(match) {
          if(match === found || (found instanceof vigour.Object) && found.val === match) {
            return !get && fields ? curr : found;
          }
        } else {
          return !get && fields ? curr : found;
        }
      }
      curr = curr[parentField];
    }
  }
}

exports.disjoin = function disjoin(a, b, check) {
  // console.log('disjoin!')
  var fncheck = typeof check === 'function'
  
  a = getEndpoint(a)
  b = getEndpoint(b)

  a.each(function(){
    var item_a = this
    var item_a_from = item_a.from
    var remove
    b.each(function(){
      var item_b = this
      var item_b_from = item_b.from
      
      
      if(fncheck){
        remove = check(item_a_from, item_b_from)
      } else if(check === true){
        remove = item_a_from === item_b_from
      } else {
        // console.log('compare a', item_a_from.raw, 'to b', item_b_from.raw)
        // console.log('field', check)
        // console.log('a:', item_a_from[check].val)
        // console.log('b:', item_b_from[check].val)
        // console.log('same:', item_a_from[check].val === item_b_from[check].val)

        remove = item_a_from[check] && item_b_from[check] &&
          item_a_from[check].val === item_b_from[check].val
      }
      return remove
    })
    if(remove){
      // console.log('YES CHECK REMOVE')
      // TODO: 
      item_a.remove()
    }
  })

}

function getEndpoint(obj){
  while(obj && obj.__t === 4 && !obj._filter){
    obj = obj._val
  }
  return obj
}

},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/process.js":[function(require,module,exports){
//processes
var vObject = require('../object')

// console.log('init process!')

module.exports = {}

},{"../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/prop.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , V = require('../')
/**
 * Setstores are used to avoid updates troughout prototype chains for changes of fields on objects
 * It uses two fields
 *   .__ to indicate own values for pieces of an object inherited trough the prototype chain
 *   ._ is the refence back to the objects as ste in the prototype
 * @constructor setstore
 */
exports.setstore = function() {
  if ( !this.__ ) this.__ = {}
}

//TODO: reconstruct value using pieces of objects in __

exports.getStore = function( name ) {
  return this.__ 
          ? ( this.__[name] !== void 0 
            ? this.__[name] 
            : this._[name]
            ) 
          : this._ && this._[name]
}

function extensions( extend, fn, base, args, extended ) {
    
  if(window.$TEST) {
    console.log(12, extend)
  }

  if( !extend.extensions ) 
  {
    if(base) {
      extend.extensions = []
    } else {
      // console.log(extend)
      if(V.Object && extend instanceof V.Object ) {
        util.define( extend, 'extensions',[])
      } else {
        //gebruik deze extension stylo
        util.define( extend, 'extensions',{val:[], setClass:true} )
      }
    }
  }

  // console.log( 'EXTEND'.red, extend.extensions, base, fn, this, extended )

  if( util.checkArray( extend.extensions, this )===false ) 
  {

    // console.log( 'EXTEND -2'.red, this )

    if( !extended ) extend.extensions = [ this ].concat( extend.extensions ) 

      // console.log( 'EXTEND -3'.red, extend.extensions )
      //somethin weird!

    // console.log( 'EXTEND -3'.red, this, extend, extend.extensions.length )

    var myArgs = util.arg( args )
    if( base && !extended ) {
      myArgs[0] = base
    }
    if(window.$TEST) console.error('??xxx?', myArgs, fn, this)
    var ret = fn.apply( this, myArgs ) //this is the app, extend is the extension 
    if(window.$TEST, ret)
    return ret
  } else {
    if(window.$TEST) console.error('???')
  }

}

exports.extend = function() {


  var extendArray = util.arg( arguments )

  return function(extend) {

    if(window.$TEST) console.log('10 --->', extend)

    var base
      , proto

    if( typeof extend === 'function' ) 
    {
      if( V.Base && ( extend.prototype instanceof V.Base ) ) {
        base = extend.base
        proto = true
      } else {
        proto = extend.prototype
      }
    } else if( V.Base && ( extend instanceof V.Base ) ) 
    {
      proto = extend
    }

    for
    ( 
      var fn
        , ret
        , args = util.arg( arguments )
        , extendArr
        , xArg
        , i = 0
        , len = extendArray.length
        ; i < len
        ; i ++ 
    ) 
    {    
      if(extendArray[i] instanceof Array) 
      {
        extendArr = extendArray[i][0]
        xArg = util.arg(extendArray[i],1)
        xArg.unshift(extend)
      } else 
      {
        xArg = args
        extendArr = extendArray[i]
      }

      if(window.$TEST) {
        console.log('11',  extendArr.extend ?  extendArr : this, base || proto  )
      }

      ret = extensions.call 
      ( extendArr.extend ?  extendArr : this 
      , base || proto || extend
      , extendArr.extend ||  extendArr
      , base
      , xArg
      , extendArr.extend ? true : false 
      ) 
      || extend

    }
    return ret
  }

}

/**
 * Add is used as a shortcut method for Object.defineProperty and extends setstore functionality to normal prototypes
 * @method add
 * @param  {Object}          obj  When obj is a constructor it selects obj.prototype, when obj is a normal object this is used instead
 * @param  {String|Array}    name When name is a string it adds the name for the object, when name is a array do the same setting for each name
 * @param  {Object|Function} val  When val is an object , use this object for Object.defineProperty with default for enummerable:false, when object is empty adds {value:{},ennumerable:false}, when val is a function it automatically wraps a property definition object with {value: val , enummerable:false}, when val is not a function and not an object (boolean, string, number) adds special setstore value
 * @param  {Function}        [set]  Adds custom setters to a setstore object, when set is a string the add functions interprets the arguments as name : property definition pairs
 * @param  {Function}        [get]  Adds custom getters to a setstore object
 * @
 */
exports.define = function (obj, name, val, set, get, id) {
  if (typeof set === 'string') {
    var _args = util.arg(arguments)
    for (var i = 1, l = _args.length; i < l; i += 2) {
      exports.define(obj, _args[i], _args[i + 1])
    }
  } else {
    if (name instanceof Array) {
      for (var i = 0, l = name.length; i < l; i++) {
        exports.define(obj, name[i], val)
      }
    } else {
      if (typeof val === 'function' || val instanceof Array) {
        val = {
          enumerable: false,
          value: val,
          configurable: true
        }
      } else if (!val || ( !(val instanceof Object) || val.setClass  )) {

        if( val && val.setClass ) {
          val = val.val
        }

        var proto = obj.prototype || obj


        //

        //TODO: not a good solution -- has to redefine constantly ( too heavy )
        // if( proto !== obj.prototype && proto._ ) {
        //    //TODO: this can go completely wrong when you expect inheritance not to break when making a new class!
        //    if( proto.constructor.prototype._ === proto._ ) {
        //       var old = proto._
        //       proto._ = {}
        //       for(var key in old) {
        //         proto._[key] = old[key]
        //       }
        //    }
        // }
        
        //maybe make into a method
        if( id) {
          // console.log('DEFINE! DO IT'.red.inverse, name, id, proto)
          if (!proto.__) proto.__ = {}
          proto.__[name] = val
        } else {
          if (!proto._) proto._ = {}
          proto._[name] = val
        }



      

        //if proto is not a prototype (how to check?) then use __ perhaps?

        //moet hier niet altijd ze eiguh worden gemaakt?

       //default dit is eigenlijk het enige dat mis gaat

        var setter = function(val) {
              exports.setstore.call(this)
              //TODO: fix closure for val
              if (val || val === 0 || val === false) this.__[name] = val
            }
          , wset = function(val) {
              val = set.call(this, val);
              setter.call(this, val);
            }
          , getter = function() {
              return exports.getStore.call(this, name);
            }
          , wget = function() {
              var prop = getter.call(this);
              return get.call(this, prop);
            }

        val = {
          enumerable: false,
          configurable: true,
          get: get ? wget : getter,
          set: set ? wset : setter
        }

      } else if (!val.enumerable) {
        if (util.empty(val)) val.value = {}
        val.configurable = true
        val.enumerable = false
      }

      Object.defineProperty(obj.prototype || obj, name, val)

      // Object.defineProperty(obj.prototype || obj, name, val)
      //mayeb do both?
    }
  }
}
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../base')
  , Value = require('./')
  , objectSet = require('../object').set
  , util = require('../util')
  // , raf = require('../browser/animation/raf')

exports.clonelist = [
  [ '_base', false ], '_caller', '_prop', '_name', '_skip'
]

function resolveListener( listener, val, prop, instance ) {
  if (listener) {
    if ( listener._bind === instance && listener.__t === 4 ) {
      // console.log('bind resolve'.red.bold, val )
      listener.val = val
    }
    else if (!listener._bind ) { 

      if( listener.__t === 4 && listener._val === prop )
      {
        // listener.val = 
        listener.val = val
        console.log('----------', listener.__t )
      }
      else
      {
        // console.log('ultimate ugly!')
        val.addListener(listener) //dit fixed  
      }

      //TODO: implement this later
      // if( listener instanceof Array ) {
      //   var mark = listener[1]
      //   if( mark ) {
      //     if( mark === prop._base || mark === instance || instance instanceof mark._class ) {
      //       //TODO: propably need to check for inheritance ( mark instance of prop._base)
      //       // console.log('mark resolve'.green.inverse, listener)
      //       // val.addListener([ listener[0] , instance ], true)
      //     }
      //   }
      // }

      
      // val.addListener(_listeners[i])
    }
  }
}

// function resolveListener( ) {

// }

/**
 * V.value.base.type
 * Defines the base type used in V.Value
 * @type
 */
exports.type = {
  type: Value,
  /**
   * Defines what this type will do on creation.
   * @method create
   * @param  {*} val              Value
   * @param  {[type]}  [prop]     [description] //WORDT NIET GEBRUIKT
   * @param  {Object}  [settings] Settingobject
   * @param  {Boolean} [noupdate] When true, doesn't update the V.Value
   * @return {Object}             Returns the V.Value
   */
  create: function(val, prop, settings, noupdate) {
    var v = new Value()
    v._base = this
    v._caller = v._base
    v._prop = settings
    // console.log('set')
    objectSet.call(v, val, false, false, true)
    // console.log('done setting')
    if (this._class) this._class.prototype._[settings.name] = v
    if (settings.set) {
      if (!settings._vset) {
        settings._vset = function(stamp, from, remove, cval) {
          // var t = this
          // t.__s = true
          // if(!t._s) {
            // raf(function() {
              // console.log('IM HERE?')
              // t.__s = null
              settings.set.call(
                   this._caller
                || this._base
                || this, this, stamp, from, remove, cval
              )
            // })
          // }

        }
      }
      if (!noupdate) {
        // console.log('UPDATE creation')
        v._update(val)
      }
    }
    return v
  },
  /**
   * Defines what this type will do on set.
   * @method set
   * @param  {*}      val      Value
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingsobject
   * @return {*}               Returns value
   */
  set: function(val, prop, settings) {

    if(!prop) return
    // console.log('SET FUN!')
    prop._caller = this
    //deze bind zou alleen moeten werken voor als je iets op het exact goede momment changed!

    prop._bind = false
    if (this !== prop._base) {
      var _listeners = prop._listeners
        , _b = prop._base
        , i
        , _this = this

      util.setstore.call(this)
      exports.clonelist[0][1] = this //beetje dirty...

      //clone is always used to get rid of flags
      if (val !== void 0 && !val.clear) {
        val = prop.clone(val, false, exports.clonelist)
      } else {
        // if(prop._flag) {
        //   value.flags[prop._flag[0]].remove && value.flags[prop._flag[0]].remove.call(this,prop._flag)
        // }
        //listener on nested child on parent

         //--->  new width for this one
         // --->  hey a listener on me /w a bind on my instance!
         //  ----> add listener to me (listener on class prop)
         //   -----> hey lets reset this little guys width
         //    ------>  lets add Listener
         //     -------->  double listeners on this one
        var v = new Value()
        v._base = this
        v._prop = settings
        v._caller = this

        // clean FLAGS from node!
        if(val) delete val.clear
        v.val = val
        val = v
      }

      this.__[settings.name] = val

      if( this._class ) this._class.prototype._[settings.name] = val

      // for each field (only 1 level deep for now)
      prop.each
      ( 
        function(key) {
          // console.log('resolve', prop._prop.name, key)
           if( this._listeners ) {
            for (i =  this._listeners.length - 1; i >= 0; i--) {
              resolveListener( this._listeners[i], val[key], prop, _this )
            }
            //TODO: check if this is nessecary
            if(val[key].val !== this.val)
            {
              // console.log(val[key]) 
              // val[key]._update()
            }
          }
        }
      )

      if( _listeners ) {

        for (i = _listeners.length - 1; i >= 0; i--) {
          resolveListener( _listeners[i], val, prop, _this )
        }

      }

      val = null
      // console.log('UPDACE ----'.yellow)
      this[settings.name]._update(val)
    }

    return val
  },
  /**
   Defines what this type will do on get.
   * @method get
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingobject
   * @return {Object}          [description]
  */
  get: function(prop, settings) {
    // console.log('GETTING!', prop, settings.name)
    if (prop) prop._caller = this
    if (settings.get) return settings.get.call(this, prop)
    return prop
  }
}
},{"../base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js","../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./'),
  util = require('../../util'),
  object = require('../../object'),
  ownModel = function(base) {
    if (!base.__ || !base.__.model) { //maybe a utility? use it at different spots like settings
      base.model = {};
      if (!base._.model) {
        base._dListen();
      }
    }
    return base.model;
  };
/**
 * data
 * data adds a reference to the data property of the current base class;
 * if there is not _base.model use data.base.extend(baseClass);
 * @flag
 */
flags.data = {
  useVal:true, //(reset???)
  set: function(val, stamp, reset) {

    var current = this.checkParent('_prop.name'),
      name = current._prop.name,
      base = current._base,
      model = ownModel(base);
    if (model.flags && model.flags[name]) {
      if (!(model.flags[name] instanceof Array)) {
        model.flags[name] = [model.flags[name]];
      }
      if (!util.checkArray(model.flags[name], this)) {
        model.flags[name].push(this);
      }
    } else {
      if (!base.model.flags) {
        base.model.flags = {};
      }
      base.model.flags[name] = this;
    }

    // console.log('LEZZ SET IT!', val, stamp, reset, current)

    var getData = function() {
      var data = this._d;
      if (data === void 0) {
        var parent = this;
        while (data === void 0 && parent) {

          // if(parent.model && (!parent.model.inherit || parent.model.inherit.val!==false)) {
          //   return data
          // }

          if (parent._d) {
            data = this._dSet(parent._d, true);
          } else {
            parent = parent.node.parentNode;
            if (parent) {
              parent = parent.base;
            }
          }
        }
      }
      return data;
    };
    if (val instanceof Object) {
      var v = val.val || val;
      this._val = function() {
        var data = getData.call(this);
        // console.log('---->',v,data)
        return data && v.call(this, data);
      };
      val = val.listen || true;
    } else {
      this._val = function() {
        var data = getData.call(this),
          ret;
        data = val === true ? data : util.get(data, val);
        if (data !== void 0) {
          ret = data.__t && !data._filter && data.val;
          if (!ret && ret !== 0 && ret !== '') { //weird
            ret = data;
          }
        } else {
          ret = '';
        }
        return ret;
      };
    }
    if(!this._flag) this._flag = {}

    // this.__lval = false
    // current._caller.setSetting({
    //   name: name,
    //   parent: function(parent) {
    //     console.log('!@#!@#!@#')
    //     this.updateData()
    //   }
    // });

    this._flag.data = ['data', this._val, val, name];
  },
  remove: function() {
    var current = this.checkParent('_prop.name'),
      model = ownModel(current._base),
      t = this;
    if (model && model.flags) {
      for (var i in model.flags) {
        if (i === current._prop.name) {
          var item = model.flags[i];
          if (item instanceof object || item.length === 1) {
            model.flags[i] = null;
            delete model.flags[i];
          } else {
            model.flags[i].splice(util.checkArray(item, t), 1);
          }
        }
      }
    }
    this._update() //pas hiermee op!
    // var t = this
    setTimeout(function() {
      //deze pas uitvoeren nadat alle klaar is! dit is dirty!
      t._update()
    },0)
  }
};
},{"../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var value = require('../'),
    base = require('../base'),
    flags = require('../../object/flags');
    
    base.clonelist.push(['_flag', true]); //true clone!
    flags.extend(value);
    module.exports = value.flags;
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../../object/flags":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/flags.js","../base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/base.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/parent.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./')
  , value = require('../')
  , util = require('../../util')
  , vObject = require('../../object')


//todo add element signature in from so it can travel trough updates --- if parent (need less funky things)

/**
 * parent
 * parent makes it possible to add listeners to parent properties
 * using multiple parent properties in one property is still very wrong
 * @flag
 */
value.prototype._blacklist.push('_parentStore')

function baseReset(base,name) {
  if(base && base.node) {
    if(name==='x' || name ==='y') base.cleanCoordinates(name)
    if(base[name]) {
      base[name]._prop._vset.call(base[name])
    }
  }
}


// window.pcheck = 0

// window.pprops = {}

//base,vset,t,type,mparent,fbase, v, val, stamp, from, remove, added, oldval, true, firstSkip
function checker(vset, t, type, mparent, fbase, v, val, stamp, from, remove, added, oldval, first, firstSkip, p) {
  if(p&&(this.parent instanceof mparent) ||  (!p && this.parent===mparent) || firstSkip ) {

    // pcheck++

    var s
      , base = this._from.base.node && this._from.base
      , name = t._prop.name

    // if(!window.pprops[name]) window.pprops[name] = 0

    // window.pprops[name]++


    t._caller = this

    //gaurd voor changes -- if no change -- do nothing
    vset.call(t, stamp, from, remove, val)

    if(base&&base[name]&&base[name+'__p']!==stamp) {
      t._caller = base
      t._caller[name+'__p'] = stamp
      vset.call(t, stamp, from, remove, val)
      t._caller = this
      s=true
    }

    // console.log(this.node)
    for(var i in t._listeners) {
      if(t._listeners[i].pop && t._listeners[i][2]==='parent') {
        if(t._listeners[i][1]._lstamp===stamp) {
          t._listeners[i][1]._lstamp=null
        }
        t._listeners[i][0].call(t._listeners[i][1], type, this, base, v, val, stamp, from, remove, added, oldval, true)
      }
    }

    //reset this._from.base[t._prop.name]===t
    if(s) baseReset(base, name)

  }
}

function updateHandler(type,mparent,fbase,v, val, stamp, from, remove, added, oldval,firstSkip,inherit) {

  var t = this

  this._parentStore[0] = mparent

  this._update(val, from ? this.stamp() : stamp, from, remove, added, oldval, false, false, function() {
    var vset =  this.checkParent('_prop._vset', true)
      , base = this.checkParent('_base', true)
      , complexParent = true
      , p

    if( (mparent===base.parent && from)  ) {
      p = true
    }

    checker.call(base,vset,t,type,mparent,fbase, v, val, stamp, false, remove, added, oldval, true, firstSkip)

    base.eachInstance(function() {
     checker.call(this, vset, t,type, mparent,fbase, v, val, stamp, false, remove, added, oldval, false, p)
    }, t._prop.name)

    vObject.prototype._update.call(this, val, stamp, false, remove, added, oldval, function(l) {
      return l[2]==='parent'
    })

    if(!inherit && v._caller && mparent!==v._caller) {
      updateHandler.call(this,type,v._caller,fbase, v, val, stamp, false, remove, added, oldval,firstSkip,true)
    }

  })
}

function _parent(parent, noupdate, prop, flag, reset) {

  // console.log('_parent call'.cyan.inverse, flag)

  var _lparent = prop._parentStore[0]
    , pname = flag[2]   //flags.parent.val
    , pprop = parent[pname]
    , fbase = this._from.base
    , newP
    , baseSet

  if (!pprop) return

  // console.log('ADD LISTENER TO PARENT')

  pprop.addListener(
    [ updateHandler
    , prop
    , 'parent'
    , parent
    , this //fbase
  ], function(l,listeners,index) {

    if(l[3]!==parent &&  _lparent!==parent && l[4]!==fbase) {
      prop._parentStore[0] = parent
      l[4] = fbase
      newP = true //hoe deze smart afvangen?
    }
  }, false, true)

  // if(reset) {
  //   for(var i in pprop._listeners) {
  //     if(pprop._listeners[i].pop && pprop._listeners[i][1]===fbase[prop._prop.name]) {
  //       if(pprop!==parent._from.base[pname]) {
  //         pprop._listeners.splice(i,1)
  //         break;
  //       }
  //     }
  //   }
  // }

  if (newP || (!_lparent || (_lparent !== parent && _lparent[pname] !== pprop) ) ) {
    prop._parentStore[0] = parent
    if (!noupdate) {
      prop._caller = (baseSet = fbase.node && fbase || prop._base)
      prop._prop._vset.call(prop, prop)
      prop._caller = this
      updateHandler.call(prop,'parent',parent,fbase,pprop,false,vObject.stamp(),false,false,false,false,true,true)
      baseReset(baseSet,prop._prop.name)
    }
  }
}

function _init(val, flag, reset) {
  var parent = this.parent
  // console.log('try parent', flag, parent)
  if (parent) _parent.call(this, parent, true, val, flag, reset)
}

function _val(val) {
  var parent = this.parent || val.checkParent('_parentStore.0', true)
  //flags.parent.val
  if(parent && !val._flag.parent) {
    console.error('NO PARENT FLAG!')
    return
  }
  // console.log('---->',val._flag.parent[2])
  if (parent ) return parent[val._flag.parent[2]].val
}

flags.parent =
{ reset: true
, useVal: true
, set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name'),
      name = current._prop.name
    //flags.parent.val
    if(!this._flag) this._flag = {}

      //overwriting previous parent
      //
    // console.log('SET PARENT---->')
    this._flag.parent = ['parent', _val, val, this]
    if (!current._parentStore) current._parentStore = [false]

    // console.log('GOTS PARENTSTORE!', reset, current._parentStore, this._flag.parent)

    current._parentStore.push(this)
    //setParent settings
    // console.log('---> CREATE SETTING'.yellow.inverse)
    current._caller.setSetting({
      name: name,
      parent: function(parent) {

        // console.log('---> SET SETTING'.yellow.inverse)

        for (var store = this[name]._parentStore, i = store ? store.length - 1 : 0; i > 0; i--) {
          if(store[i]._flag.parent) {
            _parent.call(this, parent, false, this[name], store[i]._flag.parent)
          } else {
            console.error('2 NO PARENT FLAG!')
          }
        }
      }
    });
    //try to minimize val calulations
    this._val = _val
    this._skip = true
    //onInit (if it already has some parents)
    _init.call(current._base, current, this._flag.parent, reset)
    //reAttach listeners for instances
    current._base.eachInstance(_init, name, current, this._flag.parent)
  }
, remove: function(flag) {

    // console.log('REMOVE PARENT'.cyan.inverse)

    var current = this.checkParent('_prop.name'),
      base = current._base,
      listens = current._listens,
      name = current._prop.name,
      val = flag[2],  //flags.parent.val
      parentStore = current._parentStore,
      removelistener = function() {
        var parent = this.parent
        if (parent && parent[val]) {
          if (listens.length > 0) {
            if (util.checkArray(listens, parent[val])) {
              // console.log('REMOVE LISTENER!', parent[val], listens.length, parent[val]._listeners.length, parent[val]._listeners , current)


              //more specific only remove if val matches --- store function
              parent[val].removeListener( false, current )

              //mark = false


              // console.log('REMOVE LISTENER! -- result -- no update?', listens.length)

            }
          } else {
            return true
          }
        }
      }

    this._val = 0

    if (listens && !removelistener.call(base)) {
      base.eachInstance(removelistener, name)
    }

    // console.log('PARENTSTORE', parentStore, current)
    parentStore.splice(util.checkArray(parentStore, this, true), 1)

    if (parentStore.length === 1) {
      // console.log('---> REMOVE SETTING'.yellow.inverse, parentStore)
      base.removeSetting(name, 'parent') //ff corigeren voor andere parent settings!!! op andere fields
      //dit maakt het helemaal kapot!
      // console.warn('REMOVE PARENTSTORE!')
      current._parentStore = null
    }
  }
}
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

//TODO: flags on the basis of path ( similair to cases )

//TODO: make Value flags more injectable
var flags = module.exports = require( './' )
  , processes = require( '../../util/process' )
  , Value = require( '../' )
  , util = require( '../../util' )
  , ajax = require('../../browser/network/ajax')
  , vObject = require('../../object')

//TODO: maybe add promise

exports.create = function( flag, settings, Constructor, extendflags ) {

  if( !extendflags ) extendflags = flags
  if( !Constructor ) Constructor = Value

  var tempStore = '__temp'+flag+'__'
    , inProgress =  '__inprogress'+flag+'__'
    , origUpdate = Constructor.prototype._update
    , once = settings && settings.once
    , deferMethod = settings && settings.deferMethod
    , origSet
    , origRemove
    , deferflag = 
      { reset: true
      , set: function( val, stamp, reset ) {
          if( !this._flag ) this._flag = {}
          this._flag[flag] = [ flag, false, val, this ]
        }
      , remove: function() {
          var defer = this._flag && this._flag[flag]
            , vobj

          if( defer && defer[1] )
          {

            // if( deferMethod ) 
            // {
              // vobj = deferMethod.call( _this, arr, defer[2], _this[tempStore], origUpdate, Constructor )
            // }
            // if() {
              vobj = typeof defer[2] === 'string'
                   ? processes[defer[2]]
                   : typeof defer[2] !== 'function' && defer[2]
            // }

            if( vobj && vobj.removeListener )
            {
              vobj.removeListener( defer[1] )
            }
            else if( vobj && vobj !== true )
            {
              for( var vobj$ in vobj )
              {
                vobj.removeListener( vobj[vobj$] )
              }
            }
          }
        }
      }


  Constructor.prototype._blacklist.push
  ( tempStore
  , inProgress
  , '_history'
  // , '_initialised'
  )

  if( deferMethod ) {
    settings.deferMethod = null
  }

   if( once ) {
    settings.once = null
    Constructor.prototype._blacklist.push( once )
  }

  if( settings ) {
    for( var key in settings )
    {
      if( key === 'set' )
      {
        origSet = deferflag.set
        deferflag.set = function( val, stamp, reset ) {
          settings.set.call( this, origSet, arguments )
        }
      }
      else if( key === 'remove' )
      {
        origRemove = deferflag.remove
        deferflag.remove = function( val, stamp, reset ) {
          settings.remove.call( this, origRemove, arguments )
        }
      }
      else 
      {
        deferflag[key] = settings[key]
      }
    }
  }

  extendflags[flag] = deferflag

  //extend update
  util.define
  ( Constructor
  , '_update'
  , function( val, stamp ) {



      if( ( this._flag && this._flag[flag] ) && ( !once || !this[once] ) ) //&& !this._initialised 
      {

        // this.clearCache()

        // console.error('_updace', val, this._path)

        // console.error( '$EEEEE1', this._path)

        // console.log(this._path, val, stamp)
        var _this = this
          , defer = _this._flag && _this._flag[flag]
          , tempdefer = _this[tempStore]
          , add
          , arr
          , vobj
          , recur
          , fn

        if( !tempdefer )
        {
          _this[tempStore] = tempdefer = []
          add = true
        } else {
          //TODO: fix caching stamp, most efficient but may break things /w instances etc
          // console.log('stamp cahcing', this._path)

          if( stamp && tempdefer[0][1] !== stamp )
          {

            // tempdefer.push(util.arg( arguments ))
            // console.log('stamp cahcing pass' , this._path, tempdefer)
            // tempdefer[0][0] = val
            // tempdefer[0][1] = stamp
            var arg = util.arg(arguments)
            for(var i in arg) {
              tempdefer[0][i] = arg[i]
            }
          }


        // console.error('_updace 3', val, this._path)

         // if(this._name === '$test') console.log('stop its')
          return
        }

        arr = util.arg( arguments )

        // console.error('_updace 2', val, this._path)

        tempdefer.push( arr )

        if( add )
        {
          // if(this._name === '$test') console.error('do it 1')

          if( deferMethod ) 
          {
            vobj = deferMethod.call( _this, arr, defer[2], tempStore, origUpdate, Constructor, inProgress )
          }
          else 
          {
            vobj = typeof defer[2] === 'string'
               ? processes[defer[2]]
               : defer[2]
          }

          if( vobj )
          {

              // console.log('heyho2!!!!!', val,this._path)

          
            //TODO: replace with a standard function, lose the extra closure!
            recur = function() {

              if( once ) 
              {
                _this[once] = true
              }
              //dit ook kunnen meegeven
                // console.error('LETS TRY')

              //TODO: using a closure here may not be nessecary anymore, use another identifier
              for( var i = 0; i < tempdefer.length; i++ ) { //length needs to update
                // _this._caller = tempdefer[i].splice( tempdefer[i].length-1, 1 )
                // tempdefer[i][1] = this.stamp()
                // try{
                  // console.error('LETS TRY go go go',val, i, tempdefer[i])
                  // var stampx = tempdefer[i][1]
                    // , valx = tempdefer[i][0]

                  origUpdate.apply( _this, tempdefer[i] )  

                  // if( (tempdefer[i][1] && tempdefer[i][1]!==stampx) || (tempdefer[i][0] && tempdefer[i][0]!==valx) ) {
                  //   console.warn('defer new update within the loop now it fires! -- be carefull may break')
                  //   var ref = tempdefer[i]
                  //   // setTimeout( function() { 
                  //     _this.clearCache()
                  //     _this[tempStore] = null
                  //     _this[inProgress] = null
                  //     _this.clearReferencesCache()
                  //     // console.log('?????',ref)
                  //     _this._update.apply( _this, ref ) 
                  //   // } ,100) 
                  //   // alert('new update set within loop!')

                  // }
                // }catch(e){console.error('WA', e)}
                
              }

              //listener gets removed but order is different
              if( this.removeListener ) this.removeListener( recur )

              _this[tempStore] = null
            }

            if( typeof vobj === 'function' )
            {

              if( !_this[inProgress] )
              {
               
                fn = function( val ) {
                  
                  if( val!==true && _this[inProgress] ) {
                    _this[inProgress]()
                  }
                  _this[inProgress] = null
                  _this[tempStore] = null
                }

                _this[inProgress] = recur

                if( vobj.call( this, fn , arr, tempdefer ) === true )
                {
                  _this[tempStore] = null
                  _this[inProgress] = null
                }
                // else
                // {
                //   console.log( '?' )
                //   //TODO: check if this is the best way, (updating recur, or mayeb just use the same recur)
                //   _this._deferinprogress = recur
                // }

              }

            }
            else if( vobj === true )
            {

              if( this.val || this.val === 0 )
              {
                origUpdate.apply( _this, arr )
                _this[tempStore] = null
              }  
              else
              {
                console.error( 'no value! from defer type:', flag)
              }
            }
            else if( !vobj.addListener )
            {
              for( var vobj$ in vobj )
              {
                vobj[vobj$].addListener( recur )
              }
            }
            else
            {

              vobj.addListener( recur )
            }

            defer[1] = recur
          }
        }

      }
      else
      {
        // console.log( flag, once, 'should do orig update bitches!', arguments, this )
        origUpdate.apply( this, arguments )
      }

    }
  )

} 

//TODO: injectable
//TODO:_tempdefer hoeft niet altijd maak create -- update type flag
//always update method
// exports.create( 'force', 
// { deferMethod: function( args, vobj, tempStore, update ) {
//     var _this = this
//     //dit zit natuurlijk dieper!
//     _this._skip = true //maybe check if it rly gets reset?
//     _this._ignoreValue = true
//     _this.clearCache()
//     _this[ tempStore ] = null
//     update.apply( _this, args )
//   }  
// })
//deze moet nog wat dieper

// exports.create( 'history', 
// { deferMethod: function( args, vobj, tempStore, update, Constructor ) {
//     //vobj option voor flag
//     if(!this._history) this._history = []

//     this._history.unshift( args )
//     this[tempStore] = null //total control! (old including arguments)

//     //allright that works this.clearCache() //cache dingen adden
//     update.apply( this, args )
//   }
// })

// exports.create( '$type', 
// { deferMethod: function( args, vobj, tempStore, update ) {
//     var _this = this
//       , haveToUpdate

//     //arrays etc
//     _this.clearCache()

//     if( vobj === true )
//     {
//       if( _this.val ) haveToUpdate = true
//     }
//     else if( vobj === 'string' )
//     {
//       if( typeof _this.val === 'string' ) haveToUpdate = true
//     }
//     else if( vobj === 'number' )
//     {
//       if( typeof _this.val === 'number' ) haveToUpdate = true
//     }
//     else if( typeof vobj === 'function' )
//     {
//       if( vobj.apply( _this, args ) ) haveToUpdate = true
//     }

//     if( haveToUpdate ) {
//       _this[tempStore] = null
//       update.apply( _this, args )
//     }
//   }  
// })

exports.create( '$bubble', { 
  deferMethod: function( args, vobj, tempStore, update ) {
    var _this = this
    var doUpdate
    var references
    _this[tempStore] = null

    if( vobj ) {
      // console.log('deep check') 

      if(references = vobj.references) {

        if(references instanceof Object) {
          if(references.$lte 
            && _this.referenceLevel(_this._updateOrigin) <= references.$lte 
          ) {
            doUpdate = true
          }
        } else if(references > -1) {
          //also maximum for example
          // console.error(_this._path, _this.referenceLevel(_this._updateOrigin), 'uOriginPath', _this._updateOrigin._path, '._val',_this._val._path,  'cloud', !!_this._val.cloud)
          if( _this.referenceLevel(_this._updateOrigin) === references ) {
            doUpdate = true
          } 
        } else if(references === true) {
          //only if refference
          if(_this.referenceLevel(_this._updateOrigin)!==false) {
            doUpdate = true
          } 
        
        }

      } else if( vobj && vobj.self === true ){

          if( args[2] === void 0 || this._val === args[0] || !args[0] && this._updateOrigin===this) {
            doUpdate = true
          }
        }
        
        if(doUpdate) {  
          update.apply(_this, args)
        } else {
          _this.clearReferencesCache()
        }

      } else {
        update.apply(_this, args)
      }

   
  }  
})

exports.create( 'defer' )

//TODO: vObj flag ( accessable trough object[flag] )

Value.operators.responseData = function( val, operator ) {
  return operator===false ? val : operator
}

//vobj parser!

exports.create( 'ajax', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
//     console.log('set ajax defer')
    if( ! this.loading ) {
      //name, val, vobj, stamp, noupdate, from
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor ) {
    var _this = this  

    return vobj && function( update, args ) {

      var origu = update

      update = function( type, kill ) {
        _this.clearCache()
        _this._skip = true
        _this._ignoreValue = true
        if( type ) {
          args[0] = type
          if(! ( _this._val instanceof vObject ) ) {
            _this.val = type
          } 
        }
        if( _this.loading ) _this.loading.val = false
        origu( kill )
        _this._ignoreValue = null
      }

      if( typeof vobj === 'object' )
      {
        var params = vobj
        vobj = {}
        for( var key in params ) {
          if( key === 'defer' ) {
            vobj[key] = params[key]
          } else {
            if(!vobj[key]) {
              if( key !== 'complete' && key !== 'error' && typeof params[key] === 'function' ) {
                vobj[ key ] = params[ key ].call( _this, vobj, args[0], args )
                if( !vobj[key] ) {
                  return true
                }
              } else {
                vobj[key] = params[key]
              }

              if( vobj[key] instanceof vObject ) {
                vobj[key] = vobj[key].val //custom get or raw
              } 
            }
          }
        }
      }

      if( typeof vobj === 'function' ) 
      {
        vobj = vobj.call( _this, vobj, args[0], args )
        if(!vobj) return true
      }

      if( typeof vobj === 'string' ) 
      {
        vobj = { url: vobj }
      }

      if( vobj.url instanceof vObject ) {
        vobj.url = vobj.url.val
      }

      if( !vobj || !( vobj.url || vobj.api ) ) 
      {
        return true
      }

      var complete = vobj.complete
        , error = vobj.error

      vobj.complete = function( data ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, null, data, vobj )
        }
        else
        {
          if(!_this.responseData) {
            _this.set( 'responseData', data )
          }
          else {
            _this.responseData.merge( data )
          }
          ;complete && complete( data )
          update( 'success' )
        }
      }

      vobj.error = function( err ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, err, vobj )
        }
        else
        {
          if( _this.responseData )
          { 
            _this.responseData.each( function( key ) {
              if( !Constructor.operators[key] && !Constructor.flags[key] )
              {
                this.remove()
              }
            })
          }
          _this.set( 'responseData' , void 0 )
          if( error ) error( data )
          update( 'error' )
        }
      }

      if( _this.loading ) {
        //TODO:correct responses managemet -- pretty easy todo
        _this.loading.val = true
      }

      ajax( vobj ) //TODO: let it return a promise
    }  
  }
})

//temp args 

//TODO: dit later vervangen met local flags (api)
//TODO: unify ajax hiermee voor oncsitent error handeling -- of extension op ajax
exports.create( 'apiDefer', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
    if(! this.loading ) {
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor, inProgress ) {
    var _this = this  
   
    return vobj && function( update, args ) {

      if( !args[0] || args[0].apiDefer ) return true

      var wrappedUpdate = function( val, kill ) {

        // console.error('DO DO DO', val, _this, tempStore, _this[tempStore])

        // _this[tempStore] = null
           
        // _this[inProgress] = null


        _this.loading.val = false
        if( val && val!==true ) 
        {
          _this.val = args[0] = val
          try {
            update( val ) //val -- val
          } catch( err ) {
            // console.error( 'DEEPER ERROR IN API DEFER , SOMETHING WRONG /w this API', val )
            //best example is facebook login true and gone but only weh the .loading is there
            //most be a very deep issues i geuss... hard to recreate 
            _this.type = err

            //this is wrong misses _this call and other args
            update( 'error' )
          }

          _this.clearCache()
          _this._val = false
        }
        else 
        {
          //this is wrong misses _this call and other args
          update( val )
        }
      }
      
      _this.loading.val = true
      var api = _this.checkParent( 'api', true )

      if( api && api.val !== true ) 
      {

        api.once(function( val ) {
          if( val === 'error' ) 
          {
            _this.clearCache() //hier ff een functie voor maken!
            _this.val = args[0] = 'error'
            _this.type = this.type || 'api'
            _this.loading.val = false
            wrappedUpdate()
          }
          else if( val === true )
          {
            vobj.call( _this, wrappedUpdate, args )
          }
        })
        api.val = true
      } 
      else
      {
        vobj.call( _this, wrappedUpdate, args )
      }
    }
  }
})

exports.create( 'init', 
{ set: function( set, args ) {
    if( !this.initialised )
    {
      set.apply( this, args ) //niet nodig!
    }
  }
, remove: function( remove, args ) {
    remove.apply( this, args )
    this.initialised = null
  }
, once: 'initialised'
})

module.exports = exports

},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js","../../browser/network/ajax":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/network/ajax.js","../../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","../../util/process":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/process.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/self.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./');

/**
 * self
 * @flag
 */
flags.self = {
  reset: true,
  useVal:true,
  set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name')
    if (current._base && current._base[val]) {
      current._base[val].addListener(this)
      this._val = function() {
        return this[val] && this[val].val
      }
      if(!this._flag)  this._flag = {}
      this._flag.self = ['self', this._val, val, this]
    }
  }
};

},{"./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = module.exports = require('./')
/**
 * listen
 * adds listeners to a V.Value
 * @property
 **/
flags.listen = {
  reset:true,
  set: function(val, stamp, reset) {
    if(!val)
    {
      console.error('no val in flags listen!')
//       debugger
      return
    }
    if(!this._flag) this._flag = {}
    //eventueel mergen!
      
    // console.log('listen'.cyan.inverse, reset, val)
    //if reset make sure its resetted correctly!
    this._flag.listen = ['listen', false, val, this ] 
    if (val instanceof Array) {
      for (var i = val.length - 1; i >= 0; val[i--].addListener(this));
    } else {
      //ok
      var _this = this
      // val.addListener(function() {
      //   console.log('TROUGH LISTEN!!!!'.magenta.inverse, val._path)
      //   // _this._update.apply(_this, arguments)
      // }) 
      val.addListener(this) //dit moet beter (remove listener if possible)
    }
  },
  remove:function() {
    if(this._flag&&this._flag.listen) {
      var val = this._flag.listen[2]
      if (val instanceof Array) {
        for (var i = val.length - 1; i >= 0; val[i--].removeListener(this));
      } else {
        val.removeListener(this) //dit moet beter (remove listener if possible)
      }
    }
  }
}

},{"./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/flags/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var object = require( '../object' )
  , util = require( '../util' )
  , vigour = require( '../' )

/**
 * vigour.Value
 * v values are optimized for use in combination /w instances of vigourBase, have operators and support method values
 * @Class
 */
module.exports = exports = vigour.Value = object.new(
{ mixed: true
, merge: true
})

//parent problems

var _getOperator = function( val, force, i, t, bind, operators ) {
  var f = t[i]._get(bind, force, val);
  if (f !== void 0 && f !== null) {
    val = operators[i](val || ((typeof f === 'string') ? '' : 0), f);
  }
  return val;
};

exports.prototype._blacklist.push('_lstamp', '_clearCache', '_lval', '__lval','___lval', '_base', '_caller', '_bind', '_prop', '_instances', '_skip', '_overwrite')
//_caller stamp for get for lvals (last values)
util.define(exports,
  'clearCache', function() {
    this.___lval = null
    this.__lval = null
    this._lval = null 
  },
  'clearReferencesCache', function() {
    from = this._val
    while(from) {
      if(from.clearCache) from.clearCache()
      if(from && from._val) {
        from = from._val
      } else {
        from = null
      }
    }
  },
  'ignoreCache', { get:function() {
      var t = this
      while(t) {
        // console.log('hoe zit het??',t )
        if( t._prop && t._prop.cache === false ) return true
        t = t._parent
      } 
    } 
  },
  /**
   * Used to get .val which calculates a constructed value
   * _bind is very important binds listeners to specific instances
   * @method _get
   * @param  {[type]} bind  [description]
   * @param  {[type]} force [description]
   * @return {[type]}       [description]
   */
   '_get', function(bind, force, currentVal) {

    if(this._clearCache) {
      this.clearCache()
    }

    // console.log('_get',this._name, this._val,this);
    if (this._overwrite) {
      return this._overwrite;
    }
    if (!this._lval && this._lval !== 0 || force) {
      var val = this._val,
        nolval,
        operators = this.operators;

      if (val instanceof object) {
        val = val._get(this._bind || bind, force, currentVal);
      } else if (typeof val === 'function') {

        // console.log('RIGHT HERE', currentVal)
        var a = this;
        if (!bind) {
          while (a._parent && !a._caller) {
            a = a._parent;
          }
        }
        val = val.call(bind || a._caller || a._base || this, this, currentVal); //if currentval else something else;
        nolval = true;
        //for functions you need to clear _lval since you never know if there is something in the function updated
      }
      if (operators) {
        if (this.__t === 1 && operators[this._name]) { 
          //operator is an array
          val = 0; //string
          for (var j = 0, l = this.length; j < l; j++) {
            if (this[j]) {
              vj = this[j]._get(bind, false, (currentVal || 0) + val);
              if (!vj) {
                vj = 0; //string
              }
              if (typeof vj === 'string' && val === 0) {
                val = '';
              }
              val += vj; //only add no operator stuff
              if (!this[j]._lval) {
                nolval = true;
              }
            }
          }
        } else {
          //also add before
          var ordered;
          for (var i in this) {
            if (operators[i]) {
              if (!operators[i].order) {
                if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) {
                  force = true;
                }
                val = _getOperator(val, force, i, this, bind, operators);
                if (!nolval && !this[i]._lval) {
                  nolval = true;
                }
              } else {
                if (ordered) {
                  if (!ordered.pop) {
                    ordered = [ordered];
                  }
                  var o = operators[i].order,
                    ol = ordered.length - 1;
                  for (var h = 0; h !== true && h <= ol; h++) {
                    if (h === ol) {
                      if (o < operators[ordered[h]].order) {
                        var a = ordered[h];
                        ordered[ol] = i;
                        ordered.push(a);
                      } else {
                        ordered.push(i);
                      }
                      h = true;
                    } else if (h === ol && o > operators[ordered[h]].order) {
                      ordered.push(i);
                      h = true;
                    }
                  }
                } else {
                  ordered = i;
                }
              }
            }
          }
          //shorter
          if (ordered) {
            // console.log(ordered);
            var x;
            i = ordered.pop ? (x = 1) && ordered[0] : ordered;
            while (i && this[i]) {
              if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) force = true
              val = _getOperator(val, force, i, this, bind, operators);
              if (!nolval && !this[i]._lval) nolval = true
              i = ordered[x++];
            }
          }
        }
      }
      if (!nolval && !force) {
        this._lval = val;
        this.__lval = val;
      } else if (!(this._base && this._base.instances)) {
        this.__lval = val;
      }
      return val;
    } else {
      return this.__lval;
    }
  },
  /**
   * Fires all listeners
   * @method update
   * @param  {[type]} instance    [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @return {[type]}             [description]
   */
  'update',
  function(instance, noinstances, instancesUpdates, stamp, from, remove, added) {
    //is this really nessecary?
    this._update.call( this, void 0, stamp || this.stamp(), from, remove, false, false, noinstances, instance, instancesUpdates  ); //this.val
    return this;
  },
  /**
   * Extends vigourObject._update
   * Adds loads of stuff to optimize updates for calculations
   * @method _update
   * @param  {[type]} val         [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} instance    [description]
   * @return {[type]}             [description]
   */
  '_update',
  function( val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates ) {

    var t = this,
      base = t._base;

    if (val instanceof exports && !t._bind) 
    {
      if (val._caller) {
        t._bind = val._caller;
      }
    }

    if ( (!t._lstamp) || t._lstamp !== stamp  ) {

    // var operators = t.operators
    // var lval 
    // var calcVal
    // var passValueCache 

    // if( !t.ignoreCache ) {
    //   //TODO: this is a temporary fix needs to be faster
    //   //make this a method
    //   function cleanup(t) {
    //   	t._lval = void 0
    //   	t.__lval = void 0 
    //   	if(t._val instanceof object ) {
    //   		//TODO: if stuff doesnt update uncomment this line
    //   		// cleanup(t._val)
    //   	}
  	 //    for(var $field in t) {
  	 //    	if(operators[$field]) {
  	 //    		cleanup(t[$field])
  	 //    	} else if($field > -1) {
  	 //    		cleanup(t[$field])
  	 //    	}
  	 //    }
    // 	}
    //   cleanup(t)

    //   lval = t.___lval
    //   calcVal = t.val
    //   passValueCache = lval === void 0 || lval !== calcVal
    //   t.___lval = calcVal

    // } else {

      // t.clearCache()
      // passValueCache = true
    // }

     // if (  passValueCache || ( base && base.instances ) || t._skip ) { //pass this calculation to vset else its too heavy;

    t._lval = false  
    // t._skip = true
    if(base && base.instances || t._skip || t.__lval === void 0 || t.___lval !== t.val ) {

      // if(window.smut) {
        // console.log('wtf is happening!!!!', t._path, t, t._updateOrigin, arguments)
      // }

        var prop = t._prop,
          parent = t._parent,
          vset = prop && prop._vset;

        var operators = t.operators
  
        //make this better
        if (!(from && remove) && operators && (operators[t._name] || (parent && parent.__t === 1 && operators[parent._name] && (!from || t._name == parent.length - 1)))) {
          //works for arrays since arrays are always replaced on update , updating an individual item using .set will not result in an update at this pont which has to be resolved
          var _op = this._parent;
          while (operators[_op._name]) {
            _op._lval = false; //if no change to lval can go wrong...
            _op = _op._parent;
          }
          if (_op) {
          	//this geatly increases updates may be important for animation but not nessecary for anything else!
            _op._update(val, stamp, this, remove, added, oldval, noinstances, instance, instancesUpdates);
          }
        }

        if (instancesUpdates) {
          instancesUpdates.call(t, val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates);
        } else {
          if (instance) {
            base = instance;
          }
          if (vset) {
            t._caller = base;
            vset.call(t, stamp, from, remove, val);
          }
          if (base && vset && base.instances && !noinstances && prop.updateinstances !== false) {
            base.eachInstance(function() { //look for current caller instance perhaps?
              t._caller = this;
              vset.call(t, stamp, from, remove, val);
            }, prop.name, t);
            t._caller = base;
          }
          //form gone lets see!
          //from self doorgeven in chain ==-- if ! not from from ---> , extra arg
          object.prototype._update.call(t, val, stamp, from || t, remove, added, oldval)
        }

        //pas op met deze!
        t._lstamp = stamp;
    }
    else {
      // if(window.smut) console.log('catch it!', arguments)
    }


    }
  })

//requiring operators does not automaticly require vigourValue, may be handy?
util.define(exports, 'operators', {
  value: exports.operators = require('./operators')
})




},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./operators":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/operators.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/length.js":[function(require,module,exports){
var Value = require('old-vigour-js/value'),
  util = require('old-vigour-js/util'),
  VObject = require('old-vigour-js/object')

exports.extend = util.extend(
  function(Target){
    if( Target.prototype instanceof VObject || Target === VObject) {
      // TODO: fix this to affect all VObject blacklists...
      Target.prototype._blacklist.push('_$length')

      util.define( Target,
        '$length', {
          get: function () {
            // TODO: ...so we dont have to do blacklist check:
            util.include(this._blacklist, '_$length')
            return this._$length || (this._$length = makeLength(this))
          }
        }
      )
    } else {
      throw new Error('cannot extend "$length" on non VObject Class')
    }
  }
)

function makeLength(instance) {
  var $length = new Value({
    val: function(){
      return getLength(instance)
    }
  })

  instance.on(function(val){

    // var identifier = instance._path.length 
    //   ? instance._path
    //   : instance._prop && instance._prop.name
    // console.log('UPDATE ON', identifier, 'SHINE DAT LENGTH?!', $length.val
    // )
    // TODO: only update if added or removed
    $length._update.apply($length, arguments)
  })

  return $length
}

function getLength (current) {
  if(!current){
    return 0
  } if (current._filter) {
    return current.length
  } else if (current.__t === 4) {
    return getLength(current._val)
  } else if (current.__t < 3) {
    return current.keys.length
  } else if (typeof current._val === 'string') {
    return current._val.length
  } else {
    return 0
  }
}

},{"old-vigour-js/object":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/object/index.js","old-vigour-js/util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","old-vigour-js/value":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/on.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    Extension for Base classes to create an inheritable on - value
  */

var Value = require('./')
  , util = require('../util')
  , Base = require('../base')

exports.extend = util.extend
( function(base)
  {
    if( base instanceof Base )
    {

      base.extend
      (
        {
          name:'on',
          set:function(val) {
            
          },
          remove:function(val) {
            //remove
            // console.log('im being removed!')
             if(this.on.$remove) {
              this.on.$remove.update()
            }
          },
          new:function(val) {
            //init
            // console.log('INIT!----', this, val, arguments)
            if(this.on.$new) {
              this.on.$new.update()
            }
          },
          parent:function(val) {
            //init
            if(this.on.$parent) {
              this.on.$parent.update()
            }
          },
          render:function(val) {
            //init
            // console.log('RENDER!----', this, val, arguments)
            if(this.on.$render) {
              this.on.$render.update()
            }
          }
        }
      )

    }
    else
    {
      throw new Error('cannot extend "on" on non Base Class')
    }
  }
)

},{"../base":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/base/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js","./":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/value/operators.js":[function(require,module,exports){
/**
 * operators
 * operators can be set on V.Value.operators
 * define operators on this module
 * @property
 */
var util = require('../util')
  , V = require('../')

exports.add = function( val, operator ) {
  return val + operator
}
exports.sub = function( val, operator ) {
  return val - operator
}
exports.multiply = function( val, operator ) {
  return val * operator
}
exports.divide = function( val, operator ) {
  return val / operator
}
exports.max = function( val, operator ) {
  return val > operator ? operator : val
}
exports.min = function( val, operator ) {
  return val < operator ? operator : val
}
exports.transform = function( val, operator ) {
  return operator===false ? val : operator
}
exports.abs = function( val, operator ) {
  return operator ? Math.abs(val) : val
}
exports.floor = function( val, operator ) {
  return val | 0
}
exports.ceil = function ( val, operator ) {
  return Math.ceil( val )
}
exports.$convertType = function ( val, operator ) {
  //convertType
  if( operator === 'boolean' )
  { 
    return val ? true : false
  } 
  else if( operator === 'number' )
  {
    //do isNan start using loDash for this kind of stuff ( almost nothing )
    //convert falsy or NaN values to 0
    return Number( val )
  }
}

exports.default = function( val, operator ) {

// console.log( '????', val )
  
  //pas op met die 0
  if( (!val && val !== 0) || val._val === false || val === 'error' || val === 'success' )
  {
    //TODO: Arrays for default operator
    return operator
  }
  return val
}
exports.default.order = 1000
},{"../":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/index.js","../util":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/util/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/parsejson/index.js":[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/Users/youzi/dev/mtv-play/node_modules/parseqs/index.js":[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],"/Users/youzi/dev/mtv-play/node_modules/parseuri/index.js":[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],"/Users/youzi/dev/mtv-play/node_modules/promise/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./lib/core.js')
require('./lib/done.js')
require('./lib/es6-extensions.js')
require('./lib/node-extensions.js')
},{"./lib/core.js":"/Users/youzi/dev/mtv-play/node_modules/promise/lib/core.js","./lib/done.js":"/Users/youzi/dev/mtv-play/node_modules/promise/lib/done.js","./lib/es6-extensions.js":"/Users/youzi/dev/mtv-play/node_modules/promise/lib/es6-extensions.js","./lib/node-extensions.js":"/Users/youzi/dev/mtv-play/node_modules/promise/lib/node-extensions.js"}],"/Users/youzi/dev/mtv-play/node_modules/promise/lib/core.js":[function(require,module,exports){
'use strict';

var asap = require('asap')

module.exports = Promise;
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    asap(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject(e) }
  }

  function reject(newValue) {
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  doResolve(fn, resolve, reject)
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, onFulfilled, onRejected) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return
      done = true
      onFulfilled(value)
    }, function (reason) {
      if (done) return
      done = true
      onRejected(reason)
    })
  } catch (ex) {
    if (done) return
    done = true
    onRejected(ex)
  }
}

},{"asap":"/Users/youzi/dev/mtv-play/node_modules/asap/asap.js"}],"/Users/youzi/dev/mtv-play/node_modules/promise/lib/done.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    asap(function () {
      throw err
    })
  })
}
},{"./core.js":"/Users/youzi/dev/mtv-play/node_modules/promise/lib/core.js","asap":"/Users/youzi/dev/mtv-play/node_modules/asap/asap.js"}],"/Users/youzi/dev/mtv-play/node_modules/promise/lib/es6-extensions.js":[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Promise.prototype

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.resolve = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    })
  });
}

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
}

},{"./core.js":"/Users/youzi/dev/mtv-play/node_modules/promise/lib/core.js","asap":"/Users/youzi/dev/mtv-play/node_modules/asap/asap.js"}],"/Users/youzi/dev/mtv-play/node_modules/promise/lib/node-extensions.js":[function(require,module,exports){
'use strict';

//This file contains then/promise specific extensions that are only useful for node.js interop

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop()
      }
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      var res = fn.apply(self, args)
      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
        resolve(res)
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    var ctx = this
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx)
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        asap(function () {
          callback.call(ctx, ex)
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value)
    })
  }, function (err) {
    asap(function () {
      callback.call(ctx, err)
    })
  })
}

},{"./core.js":"/Users/youzi/dev/mtv-play/node_modules/promise/lib/core.js","asap":"/Users/youzi/dev/mtv-play/node_modules/asap/asap.js"}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/manager.js","./socket":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/socket.js","./url":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/url.js","debug":"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js","socket.io-parser":"/Users/youzi/dev/mtv-play/node_modules/socket.io-parser/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/manager.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function(){
  this.lastPing = new Date;
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function(){
  this.emitAll('pong', new Date - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function(){
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  debug('cleanup');

  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' == this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/on.js","./socket":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/socket.js","backo2":"/Users/youzi/dev/mtv-play/node_modules/backo2/index.js","component-bind":"/Users/youzi/dev/mtv-play/node_modules/component-bind/index.js","component-emitter":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js","engine.io-client":"/Users/youzi/dev/mtv-play/node_modules/engine.io-client/index.js","indexof":"/Users/youzi/dev/mtv-play/node_modules/indexof/index.js","socket.io-parser":"/Users/youzi/dev/mtv-play/node_modules/socket.io-parser/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/on.js":[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/socket.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function(compress){
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/on.js","component-bind":"/Users/youzi/dev/mtv-play/node_modules/component-bind/index.js","component-emitter":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js","has-binary":"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/node_modules/has-binary/index.js","socket.io-parser":"/Users/youzi/dev/mtv-play/node_modules/socket.io-parser/index.js","to-array":"/Users/youzi/dev/mtv-play/node_modules/to-array/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/lib/url.js":[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js","parseuri":"/Users/youzi/dev/mtv-play/node_modules/parseuri/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/node_modules/component-emitter/index.js":[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-client/node_modules/has-binary/index.js":[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":"/Users/youzi/dev/mtv-play/node_modules/isarray/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-parser/binary.js":[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is-buffer":"/Users/youzi/dev/mtv-play/node_modules/socket.io-parser/is-buffer.js","isarray":"/Users/youzi/dev/mtv-play/node_modules/isarray/index.js"}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-parser/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":"/Users/youzi/dev/mtv-play/node_modules/socket.io-parser/binary.js","./is-buffer":"/Users/youzi/dev/mtv-play/node_modules/socket.io-parser/is-buffer.js","component-emitter":"/Users/youzi/dev/mtv-play/node_modules/component-emitter/index.js","debug":"/Users/youzi/dev/mtv-play/node_modules/debug/browser.js","isarray":"/Users/youzi/dev/mtv-play/node_modules/isarray/index.js","json3":"/Users/youzi/dev/mtv-play/node_modules/json3/lib/json3.js"}],"/Users/youzi/dev/mtv-play/node_modules/socket.io-parser/is-buffer.js":[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/Users/youzi/dev/mtv-play/node_modules/to-array/index.js":[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],"/Users/youzi/dev/mtv-play/node_modules/utf8/utf8.js":[function(require,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/Users/youzi/dev/mtv-play/node_modules/yeast/index.js":[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],"/Users/youzi/dev/mtv-play/platform/all.js":[function(require,module,exports){
var app = require('../app')
var Switcher = require('../components/switcher')
var cases = require('old-vigour-js/browser/cases')
var CookieBar = require('../components/cookiebar')
var msg

app.set({
  switcher: new Switcher({
    on: {
      navigation: app.user.navigation,
      play: app.playing,
      receiver: app.user.receiver,
      favourites: app.user.favourites,
      usage: app.user.usage,
      content: app.content,
      highlight: app.user.highlight,
      search: app.user.search,
      scroll: app.user.scroll,
      carousel: app.user.carousel,
      volume: app.volume,
      notification: app.notification,
      watched: app.user.watched.from,
      state: app.state,
      popup: app.popup,
      overlay: app.overlay,
      loading: app.loading,
      profilepic: app.user.profilepic,
      activeClient: app.user.activeClient
    },
    display: 'none'
  })
})

app.ready.once(true, function () {
  app.switcher.display = 'block'
  if (app.region.val !== 'CH') {
    var showCookieMessage = cases.desktop || (!cases.native && (cases.phone || cases.tablet))
    if (showCookieMessage && !window.localStorage.getItem('cookieApproved')) {
      if (app.region.val !== 'NL') {
        app.set({
          cookiewall: new CookieBar()
        })
      } else {
        app.add(new CookieBar(), 'switcher')
      }
    }
  }
})

if (cases.phone && !cases.native) {
  var rotateMsg = function () {
    var w = window.innerWidth
    var h = window.innerHeight
    if (w > h) {
      app.set({
        message: new (msg || (msg = require('../components/rotate-message')))()
      })
    } else if (app.message) {
      app.message.remove()
    }
  }
  app.w.on(rotateMsg)
  rotateMsg()
}

app.initialised.val = true

},{"../app":"/Users/youzi/dev/mtv-play/app/index.js","../components/cookiebar":"/Users/youzi/dev/mtv-play/components/cookiebar/index.js","../components/rotate-message":"/Users/youzi/dev/mtv-play/components/rotate-message/index.js","../components/switcher":"/Users/youzi/dev/mtv-play/components/switcher/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/platform/cast.js":[function(require,module,exports){
var app = require('../app')
var Switcher = require('../components/switcher')
var cases = require('old-vigour-js/browser/cases')
var msg

app.state.val = {
  defer: function ( update, args ) {
    if ( this._val === 'first') this._val = 'second'
    update()
  }
}

app.set({
  switcher: new Switcher({
    on: {
      navigation: app.user.navigation,
      play: app.playing,
      receiver: app.user.receiver,
      favourites: app.user.favourites,
      usage: app.user.usage,
      content: app.content,
      fullscreen: app.fullscreen,
      highlight: app.user.highlight,
      search: app.user.search,
      scroll: app.user.scroll,
      carousel: app.user.carousel,
      volume: app.volume,
      notification: app.notification,
      watched: app.user.watched.from,
      state: app.state,
      popup: app.popup,
      overlay: app.overlay,
      loading: app.loading,
      profilepic: app.user.profilepic,
      activeClient: app.user.activeClient
    }
  })
})

app.initialised.val = true

},{"../app":"/Users/youzi/dev/mtv-play/app/index.js","../components/switcher":"/Users/youzi/dev/mtv-play/components/switcher/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/dev/mtv-play/platform/tv.js":[function(require,module,exports){
var tv = require('old-vigour-js/app/ui/tv')
var app = require('../app')
var Switcher = require('../components/switcher')
var cases = require('old-vigour-js/browser/cases')
var msg

app.set({
  switcher: new Switcher({
    on: {
      navigation: app.user.navigation,
      play: app.playing,
      receiver: app.user.receiver,
      favourites: app.user.favourites,
      usage: app.user.usage,
      content: app.content,
      fullscreen: app.fullscreen,
      highlight: app.user.highlight,
      search: app.user.search,
      scroll: app.user.scroll,
      carousel: app.user.carousel,
      volume: app.volume,
      notification: app.notification,
      watched: app.user.watched.from,
      state: app.state,
      popup: app.popup,
      overlay: app.overlay,
      loading: app.loading,
      profilepic: app.user.profilepic,
      activeClient: app.user.activeClient
    }
  })
})

app.initialised.val = true

},{"../app":"/Users/youzi/dev/mtv-play/app/index.js","../components/switcher":"/Users/youzi/dev/mtv-play/components/switcher/index.js","old-vigour-js/app/ui/tv":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/app/ui/tv/index.js","old-vigour-js/browser/cases":"/Users/youzi/dev/mtv-play/node_modules/old-vigour-js/browser/cases/index.js"}],"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/browser-resolve/empty.js":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/common.less"][0].apply(exports,arguments)
},{}],"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/browserify/lib/_empty.js":[function(require,module,exports){
arguments[4]["/Users/youzi/dev/mtv-play/common.less"][0].apply(exports,arguments)
},{}],"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/os-browserify/browser.js":[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/util/util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/util/support/isBufferBrowser.js","_process":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/process/browser.js","inherits":"/Users/youzi/npm-global/lib/node_modules/gaston/node_modules/inherits/inherits_browser.js"}],"package.json":[function(require,module,exports){
module.exports={"name":"mtv-play","version":"1.2.88","description":"mtv's multiscreen adventure","main":"index.js","scripts":{"test":"test/test.js","build":"gaston build -x -s ./index.js -o . -i && cd xhr && gaston build -s ./index.js -o . && cp build.js bundle.js && rm build.css","bundle":"gaston bundle -s ./index.js -o . -i","ios":"npm run build && ./node_modules/.bin/wrapper build --native.selectedPlatforms ios","release":"cp build.css bundle.css && ./node_modules/.bin/ferry --release --mergeFiles '[\"./package.json\",\"./.package.json\"]'"},"repository":{"type":"git","url":"https://github.com/vigour-io/mtv-play","branch":"develop"},"keywords":["multiscreen","play","shows","smart","tv","js"],"dependencies":{"autolinker":"^0.18.1","jquery":"^2.2.0","lodash":"3.2.0","markdown":"^0.5.0","monotonic-timestamp":"0.0.9","old-vigour-js":"git+ssh://git@github.com:vigour-io/vigour-js.git#hotfix/iosBrowser","package-branch-config":"^1.2.2","promise":"6.1.0","through2":"^2.0.0","zepto-browserify":"x"},"devDependencies":{"vigour-wrapper":"^2.0.1","vigour-ferry":"^3.0.0"},"author":"Jim de Beer","license":"other","bugs":{"url":"https://github.com/vigour-io/mtv-play/issues"},"homepage":"https://github.com/vigour-io/mtv-play","vigour":{"ga":"UA-43955457-3","hashUrl":true,"defaultRegion":false,"regionOverride":"DE","availableRegions":["DE","NL","CH","PL","BE","NO","AT","DK"],"geo":"https://wwwmtvplay-a.akamaihd.net/geo/","development":{"button":true},"cloud":"http://mtv-hub.dev.vigour.io:80","othercloud":"http://localhost:10001","languages":["en","de","nl","pl","it","fr","no","dk"],"mtvmobile":["de","ch"],"roles":["free","premium","mtv","trial"],"countrycodes":{"de":49,"ch":41,"nl":31},"dictionary":"https://mtv-develop.vigour.io/translations/lang_$language.json","epg":"https://wwwmtvplay-a.akamaihd.net/xhr/index.html","img":"https://imgmtvplay-a.akamaihd.net","imgOrigin":"http://staging.riptide.mtvnn.com/","api":{"type":"staging","url":"https://utt-staging.mtvnn.com/","acceptHeader":"application/json","key":"4e99c9381b74354fbae9f468497912f0"},"player":{"debug":false,"web":"http://player.mtvnn.com/html5player/production/player.js?v=2","settings":{"homadURL":"/homad/config.json","ad_playpostrolls":true,"domain":"mtv","tld":"de","localization":{"language":"de","country":"DE"},"ads":{"autoSID":false,"context":null,"defaultAssetID":41349526,"defaults":{"interval":0},"enabled":true,"engine":"Freewheel","fallbackID":41349526,"midroll_intervals":{"longer_than_15":null,"longer_than_20":null,"longer_than_30":null},"networkID":174975,"profileID":"174975:MTVNE_live_HTML5","server":"http://2ab7f.v.fwmrm.net/ad/p/1","viralSID":"mtvplaytv/test"},"controls":false,"blankVideo":"http://player.mtvnn.com/codebase/blank.m4v","simulcastApiKey":"c153f28d950ae49a"}},"chromecast":{"id":"30C914C1","web":"https://www.gstatic.com/cv/js/sender/v1/cast_sender.js"},"facebook":{"id":"720547754665171","web":"https://connect.facebook.net/de_DE/sdk.js"},"wrapper":{"assets":{"build.html":true,"build.js":true,"build.css":true,"bundle.css":true,"fonts.css":true,"fonts":"*","img":"*","assets":"*","translations":"*"}},"fburl":"http://play.mtvutt.com/","packer":{"language":"https://wwwmtvplay-a.akamaihd.net/translations/","url":"https://wwwmtvplay-a.akamaihd.net/","domain":"http://mtv-develop.vigour.io"},"ferry":{"assets":{"build.html":true,"build.js":true,"build.css":true,"bundle.css":true,"fonts.css":true,"fonts":"*","img":"*","assets":"*","translations":"*","cast":"*","cast.html":true,"xhr":"*","homad":"*","googleebecff275dd42f4a.html":true,"google2c4a46fac7686373.html":true,"sitemap.xml":true,"robots.txt":true,"meta":"*"},"transforms":{"build.js":["inform"],"bundle.css":["rebase"],"build.css":["rebase"],"build.html":["meta"]},"main":"build.js","web":"build.html","fbDefaults":{"title":"MTV Play","description":"Mtv's new app to view shows on all devices","image":"http://img.mtvutt.com/image/180/180?url=http://play.mtvutt.com/apple-touch-icon-180x180.png"}},"store":{"customAvailablility":{"DK":{"monthly":true,"yearly":true,"single":false}},"ios":{"monthly":"$region_subscription_monthly","yearly":"$region_subscription_annual","single":"$region_single_purchase"},"android":{"monthly":"mtvplay_subscription_monthly","yearly":"mtvplay_subscription_annually","single":"mtvplay_single_purchase"},"windows":{"monthly":"mtvplay_subscription_monthly","yearly":"mtvplay_subscription_annual","single":"mtvplay_single_purchase"},"amazon":{"monthly":"com.mtvplay.app.sub.month","yearly":"com.mtvplay.app.sub.year","single":"com.mtvplay.app.episode"}}},"gaston":{"transforms":{"package-branch-config":{"section":"vigour"}},"less-options":{},"source-maps":false,"package":true,"index-path":"index.html","es5":true,"aliasify":{}},"sha":"1.2.88"}
},{}]},{},["/Users/youzi/dev/mtv-play/index.js"]);
